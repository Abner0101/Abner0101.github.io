<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Old C</title>
  
  <subtitle>老黄瓜VIP专属折腾区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jdsheng.cn/"/>
  <updated>2019-10-13T04:09:53.166Z</updated>
  <id>https://jdsheng.cn/</id>
  
  <author>
    <name>老黄瓜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6的Set和Map数据结构</title>
    <link href="https://jdsheng.cn/2019/10/13/ES6%E7%9A%84Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://jdsheng.cn/2019/10/13/ES6的Set和Map数据结构/</id>
    <published>2019-10-13T03:57:09.490Z</published>
    <updated>2019-10-13T04:09:53.166Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写业务代码的时候经常碰到数组或者对象去重问题，常用的方法当然就是遍历，然后，<a id="more"></a>我自己搜了一下有没有更简洁的做法，发现了es6的Set和Map数据结构也可以用于去重，最主要的是省了好多代码。</p><p>那么Set和Map到底是何方神圣呢，刚开始看的时候越看越懵逼，因为我不明白实现这样的数据结构，目的是什么，意义又是什么呢？</p><p>Set和Map主要的应用场景在于数组去重和数据存储，幸运的是在读了关于数据结构和算法之类的书籍后，恍然大悟的发现</p><p>原来Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构</p><p>那么下面就跟随我一起去了解下这两种数据结构，最后来亲手实现的一个ES6中的Set和Map吧</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ol><li>集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组</li><li>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值 </li><li><p>Set 本身是一个构造函数，用来生成 Set数据结构 </p><p>这里说的Set其实就是我们所要讲到的集合，先来看下基础用法</p></li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(i);   <span class="hljs-comment">// 2 3 5 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 去除数组的重复成员</span></span><br><span class="line"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>];</span><br><span class="line">[...new <span class="hljs-built_in">Set</span>(array)]     <span class="hljs-comment">// [1, 2, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><p><strong>Set的属性：</strong></p><ul><li>size：返回集合所包含元素的数量</li></ul><p><strong>Set的方法：</strong><br>操作方法——</p><ul><li>add(value)：向集合添加一个新的项</li><li>delete(value)：从集合中移除一个值</li><li>has(value)：如果值在集合中存在，返回true,否则false</li><li>clear(): 移除集合里所有的项</li></ul><p>遍历方法——</p><ul><li>keys()：返回一个包含集合中所有键的数组</li><li>values()：返回一个包含集合中所有值的数组</li><li>entries：返回一个包含集合中所有键值对的数组(感觉没什么用就不实现了)</li><li>forEach()：用于对集合成员执行某种操作，没有返回值</li></ul><p><strong>Set完整实现</strong><br>在此，先给大家贴一下完整的实现代码</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set</span>(<span class="hljs-params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// has方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.has = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// add方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 如果没有存在items里面就可以直接写入</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.has(val)) &#123;</span><br><span class="line">            items[val] = val;</span><br><span class="line">            <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    arr.forEach(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.add(val);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// delete方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.delete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.has(val)) &#123;</span><br><span class="line">            <span class="hljs-keyword">delete</span> items[val];  <span class="hljs-comment">// 将items对象上的属性删掉</span></span><br><span class="line">            <span class="hljs-keyword">this</span>.size--;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// clear方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// keys方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.keys = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(items);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// values方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.values = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(items);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// forEach方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, context = this</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> item = <span class="hljs-built_in">Object</span>.keys(items)[i];</span><br><span class="line">            fn.call(context, item, item, items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 并集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.union = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">        <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            union.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        values = other.values();    <span class="hljs-comment">// 将values重新赋值为新的集合</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            union.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> union;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 交集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.intersect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">        <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (other.has(values[i])) &#123;</span><br><span class="line">                intersect.add(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> intersect;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 差集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.difference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">        <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!other.has(values[i])) &#123;</span><br><span class="line">                difference.add(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> difference;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 子集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.subset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size &gt; other.size) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(values[i])</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(other.values())</span><br><span class="line">                <span class="hljs-keyword">if</span> (!other.has(values[i])) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>写了辣么多一起来测试一下吧</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Set</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Set.js'</span>);</span><br><span class="line"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.keys());    <span class="hljs-comment">// [ '1', '2', '3' ]</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.values());  <span class="hljs-comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.size);      <span class="hljs-comment">// 3</span></span><br><span class="line">set.delete(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.values());  <span class="hljs-comment">// [ 2, 3 ]</span></span><br><span class="line">set.clear();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.size);      <span class="hljs-comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 并集</span></span><br><span class="line"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(a).union(b).values();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(union);     <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 交集</span></span><br><span class="line"><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).intersect(c).values();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(intersect); <span class="hljs-comment">// [ 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 差集</span></span><br><span class="line"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).difference(d).values();</span><br><span class="line"><span class="hljs-comment">// [1,2,3]和[4,3,2]的差集是1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(difference);    <span class="hljs-comment">// [ 1 ]</span></span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>在数据结构还有一种结构叫做字典，它就是实现基于ES6中的Map类的结构</p><p>那么集合又和字典有什么区别呢：</p><ul><li>共同点：集合、字典可以存储不重复的值</li><li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li><li>所以这一下让我们明白了，Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“值—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适</li></ul><p>下面来看一下基本使用：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();</span><br><span class="line"><span class="hljs-keyword">const</span> o = &#123;<span class="hljs-attr">p</span>: <span class="hljs-string">'Hello World'</span>&#125;;</span><br><span class="line">m.set(o, <span class="hljs-string">'content'</span>)</span><br><span class="line">m.get(o) <span class="hljs-comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="hljs-comment">// true</span></span><br><span class="line">m.delete(o) <span class="hljs-comment">// true</span></span><br><span class="line">m.has(o) <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><p>以上是Map的基本使用，还有更多有用的方法稍后会随着实现的深入分别展示</p><h4 id="Map的属性和方法"><a href="#Map的属性和方法" class="headerlink" title="Map的属性和方法"></a>Map的属性和方法</h4><p><strong>属性：</strong></p><ul><li>size：返回字典所包含的元素个数</li></ul><p><strong>操作方法：</strong></p><ul><li>set(key, val): 向字典中添加新元素</li><li>get(key):通过键值查找特定的数值并返回</li><li>has(key):如果键存在字典中返回true,否则false</li><li>delete(key): 通过键值从字典中移除对应的数据</li><li>clear():将这个字典中的所有元素删除</li></ul><p><strong>遍历方法：</strong></p><ul><li>keys():将字典中包含的所有键名以数组形式返回</li><li>values():将字典中包含的所有数值以数组形式返回</li><li>forEach()：遍历字典的所有成员</li></ul><p><strong>Map完整实现</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Map</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 操作方法</span></span><br><span class="line">    <span class="hljs-comment">// has方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.has = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// set(key, val)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.set = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, val</span>) </span>&#123;</span><br><span class="line">        items[key] = val;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// get(key)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.has(key) ? items[key] : <span class="hljs-literal">undefined</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// delete(key)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.delete = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.has(key)) &#123;</span><br><span class="line">            <span class="hljs-keyword">delete</span> items[key];</span><br><span class="line">            <span class="hljs-keyword">this</span>.size--;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// clear()方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 遍历方法</span></span><br><span class="line">    <span class="hljs-comment">// keys()方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.keys = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(items);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// values()方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.values = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(items);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// forEach(fn, context)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context = this</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> key = <span class="hljs-built_in">Object</span>.keys(items)[i];</span><br><span class="line">            <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Object</span>.values(items)[i];</span><br><span class="line">            fn.call(context, value, key, items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Map</span>;</span><br></pre></td></tr></table></figure><p>再来看看下面的测试：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// map.js</span></span><br><span class="line">  <span class="hljs-comment">// 使用Map类</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-built_in">Map</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Map.js'</span>);</span><br><span class="line">  <span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();</span><br><span class="line">  m.set(<span class="hljs-string">'Jay'</span>, <span class="hljs-string">'Jay的Chou'</span>);</span><br><span class="line">  m.set(<span class="hljs-literal">true</span>, <span class="hljs-string">'真的'</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.has(<span class="hljs-string">'Chou'</span>));  <span class="hljs-comment">// false</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.size);        <span class="hljs-comment">// 2</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.keys());      <span class="hljs-comment">// [ 'Jay', 'true' ]</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.values());    <span class="hljs-comment">// [ 'Jay的Chou', '真的' ]</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.get(<span class="hljs-string">'jay'</span>));  <span class="hljs-comment">// undefined</span></span><br><span class="line">  </span><br><span class="line">  m.delete(<span class="hljs-literal">true</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.keys());      <span class="hljs-comment">// [ 'Jay' ]</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.values());    <span class="hljs-comment">// [ 'Jay的Chou' ]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写业务代码的时候经常碰到数组或者对象去重问题，常用的方法当然就是遍历，然后，&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="es6" scheme="https://jdsheng.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（四）——绑定例外和this词法</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96%E5%92%8Cthis%E8%AF%8D%E6%B3%95/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（四）——绑定例外和this词法/</id>
    <published>2019-10-13T03:57:00.968Z</published>
    <updated>2019-10-13T04:09:42.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1绑定例外"><a href="#1-1绑定例外" class="headerlink" title="1.1绑定例外"></a>1.1绑定例外</h2><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。<a id="more"></a></p><h4 id="1-1-1-被忽略的this"><a href="#1-1-1-被忽略的this" class="headerlink" title="1.1.1 被忽略的this"></a>1.1.1 被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">foo.call( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>那么什么情况下你会传入 null 呢？</p><p>一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。 类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a:"</span> + a + <span class="hljs-string">", b:"</span> + b ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 把数组“展开”成参数 </span></span><br><span class="line">foo.apply( <span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span></span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ); </span><br><span class="line">bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure><p>这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你 仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</p><p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。 </p><p>显而易见，这种方式可能会导致许多难以分析和追踪的 bug。</p><h5 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h5><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized zone，非军事区）对象——它就是一个空的非委托的对象（下面会讲到）。</p><p> 如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何 对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。 </p><p>由于这个对象完全是一个空对象，我自己喜欢用变量名 ø（这是数学中表示空集合符号的 小写形式）来表示它。在大多数键盘（比如说 Mac 的 US 布局键盘）上都可以使用⌥ +o （Option-o）来打出这个符号。有些系统允许你为特殊符号设定快捷键。如果你不喜欢 ø 符 号或者你的键盘不太容易打出这个符号，那你可以换一个喜欢的名字来称呼它。 </p><p>无论你叫它什么，在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null) 。Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object. prototype 这个委托，所以它比 {}“更空”：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a:"</span> + a + <span class="hljs-string">", b:"</span> + b ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 我们的 DMZ 空对象 </span></span><br><span class="line"><span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>.create( <span class="hljs-literal">null</span> ); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 把数组展开成参数 </span></span><br><span class="line">foo.apply( ø, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span></span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( ø, <span class="hljs-number">2</span> ); </span><br><span class="line">bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure><p>使用变量名 ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为 ø 表示 “我希望 this 是空”，这比 null 的含义更清楚。不过再说一遍，你可以用任何喜欢的名字 来命名 DMZ 对象。</p><h4 id="1-1-2-间接引用"><a href="#1-1-2-间接引用" class="headerlink" title="1.1.2 间接引用"></a>1.1.2 间接引用</h4><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。 </p><p>间接引用最容易在赋值时发生：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;; </span><br><span class="line">o.foo(); <span class="hljs-comment">// 3 </span></span><br><span class="line">(p.foo = o.foo)(); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p><blockquote><p> 注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。</p></blockquote><h4 id="1-1-3-软绑定"><a href="#1-1-3-软绑定" class="headerlink" title="1.1.3 软绑定"></a>1.1.3 软绑定</h4><p>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 </p><p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><p> 可以通过一种被称为软绑定的方法来实现我们想要的效果：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Function</span>.prototype.softBind) &#123; </span><br><span class="line"><span class="hljs-built_in">Function</span>.prototype.softBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123; </span><br><span class="line"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 捕获所有 curried 参数</span></span><br><span class="line"><span class="hljs-keyword">var</span> curried = [].slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span> );</span><br><span class="line"><span class="hljs-keyword">var</span> bound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> fn.apply( </span><br><span class="line">(!<span class="hljs-keyword">this</span> || <span class="hljs-keyword">this</span> === (<span class="hljs-built_in">window</span> || global)) ? </span><br><span class="line">obj : <span class="hljs-keyword">this</span></span><br><span class="line">curried.concat.apply( curried, <span class="hljs-built_in">arguments</span> ) </span><br><span class="line">); </span><br><span class="line">&#125;;</span><br><span class="line">bound.prototype = <span class="hljs-built_in">Object</span>.create( fn.prototype );</span><br><span class="line"><span class="hljs-keyword">return</span> bound; </span><br><span class="line">&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里 化（详情请查看之前和 bind(..) 相关的介绍）。</p><p>下面我们看看 softBind 是否实现了软绑定功能：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"name: "</span> + <span class="hljs-keyword">this</span>.name); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"obj"</span> &#125;, </span><br><span class="line">  obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"obj2"</span> &#125;,</span><br><span class="line">   obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"obj3"</span> &#125;;</span><br><span class="line">   </span><br><span class="line"><span class="hljs-keyword">var</span> fooOBJ = foo.softBind( obj ); </span><br><span class="line"></span><br><span class="line">fooOBJ(); <span class="hljs-comment">// name: obj </span></span><br><span class="line"></span><br><span class="line">obj2.foo = foo.softBind(obj); </span><br><span class="line">obj2.foo(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！ </span></span><br><span class="line"></span><br><span class="line">fooOBJ.call( obj3 ); <span class="hljs-comment">// name: obj3 &lt;---- 看！ </span></span><br><span class="line"></span><br><span class="line">setTimeout( obj2.foo, <span class="hljs-number">10</span> ); </span><br><span class="line"><span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span></span><br></pre></td></tr></table></figure><p>可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默 认绑定，则会将 this 绑定到 obj。</p><h2 id="1-2-this词法"><a href="#1-2-this词法" class="headerlink" title="1.2 this词法"></a>1.2 this词法</h2><p>我们之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用 这些规则的特殊函数类型：箭头函数。</p><p> 箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。 </p><p>我们来看看箭头函数的词法作用域：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-comment">// 返回一个箭头函数</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="hljs-comment">//this 继承自 foo() </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123; </span><br><span class="line">a:<span class="hljs-number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.call( obj1 ); </span><br><span class="line">bar.call( obj2 ); <span class="hljs-comment">// 2, 不是 3 ！</span></span><br></pre></td></tr></table></figure><p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不 行！）</p><p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; </span><br><span class="line"><span class="hljs-comment">// 这里的 this 在此法上继承自 foo() </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;,<span class="hljs-number">100</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体 现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// lexical capture of this </span></span><br><span class="line">setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( self.a ); </span><br><span class="line">&#125;, <span class="hljs-number">100</span> ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替 代的是 this 机制。 </p><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数 来否定 this 机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码； </li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li></ol><p>当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混 合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。</p><h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。 </p><ol><li>由 new 调用？绑定到新创建的对象。 </li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 </li><li>由上下文对象调用？绑定到那个上下文对象。 </li><li><p>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</p><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。</p></li></ol><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1绑定例外&quot;&gt;&lt;a href=&quot;#1-1绑定例外&quot; class=&quot;headerlink&quot; title=&quot;1.1绑定例外&quot;&gt;&lt;/a&gt;1.1绑定例外&lt;/h2&gt;&lt;p&gt;在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（二）——调用位置和绑定规则</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（三）——绑定规则的优先级/</id>
    <published>2019-10-13T03:56:51.711Z</published>
    <updated>2019-10-13T04:09:23.865Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。<a id="more"></a>但是，如果某个调用位置可以应用多条规则该怎么办？为了 解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。 </p><p>毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。 </p><p>隐式绑定和显式绑定哪个优先级更高？我们来测试一下：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123; </span><br><span class="line">a: <span class="hljs-number">3</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo(); <span class="hljs-comment">// 2 </span></span><br><span class="line">obj2.foo(); <span class="hljs-comment">// 3 </span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); <span class="hljs-comment">// 3 </span></span><br><span class="line">obj2.foo.call( obj1 ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看到，<strong>显式绑定优先级更高</strong>，也就是说在判断时应当先考虑是否可以应用显式绑定。</p><p>现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.a = something; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">obj1.foo( <span class="hljs-number">2</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2 </span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2, <span class="hljs-number">3</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj2.a ); <span class="hljs-comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.foo( <span class="hljs-number">4</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( bar.a ); <span class="hljs-comment">// 4</span></span><br></pre></td></tr></table></figure><p>可以看到 <strong>new 绑定比隐式绑定优先级高</strong>。但是 new 绑定和显式绑定谁的优先级更高呢？</p><blockquote><p>new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。</p></blockquote><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们 提供的对象绑定到 this 上。 </p><p>这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。</p><p>我们看看是不是这样：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.a = something; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( obj1 ); </span><br><span class="line">bar( <span class="hljs-number">2</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar(<span class="hljs-number">3</span>); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( baz.a ); <span class="hljs-comment">// 3</span></span><br></pre></td></tr></table></figure><p>出乎意料！ bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。</p><h5 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h5><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断：</p><ol><li><p>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo()</span><br></pre></td></tr></table></figure></li><li><p>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = foo.call(obj2)</span><br></pre></td></tr></table></figure></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = obj1.foo()</span><br></pre></td></tr></table></figure></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 </p></li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = foo()</span><br></pre></td></tr></table></figure><p>就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（三）——绑定规则的优先级</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%92%8C%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（二）——调用位置和绑定规则/</id>
    <published>2019-10-13T03:56:40.270Z</published>
    <updated>2019-10-13T04:09:36.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-调用位置"><a href="#1-1-调用位置" class="headerlink" title="1.1 调用位置"></a>1.1 调用位置</h2><p>在理解 this 的绑定过程之前首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）<a id="more"></a>。只有仔细分析调用位置才能回答这个问题：这个 this 到底引 用的是什么？ </p><p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。 </p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的 调用位置就在当前正在<strong>执行的函数的前一个调用中</strong>。 </p><p>下面我们来看看到底什么是调用栈和调用位置：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"> <span class="hljs-comment">// 当前调用栈是：baz </span></span><br><span class="line"> <span class="hljs-comment">// 因此，当前调用位置是全局作用域 </span></span><br><span class="line"> <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"baz"</span> ); </span><br><span class="line"> bar(); <span class="hljs-comment">// &lt;-- bar 的调用位置 </span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 当前调用栈是 baz -&gt; bar </span></span><br><span class="line"><span class="hljs-comment">// 因此，当前调用位置在 baz 中 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"bar"</span> ); </span><br><span class="line">foo(); <span class="hljs-comment">// &lt;-- foo 的调用位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class="line"><span class="hljs-comment">// 因此，当前调用位置在 bar 中 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo"</span> ); </span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure><p>注意我们是如何（从调用栈中）分析出真正的调用位置的，因为它决定了 this 的绑定。</p><blockquote><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所 写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法 是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的 第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger;语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数 调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。</p></blockquote><h2 id="1-2-绑定规则"><a href="#1-2-绑定规则" class="headerlink" title="1.2 绑定规则"></a>1.2 绑定规则</h2><h4 id="1-2-1-默认绑定"><a href="#1-2-1-默认绑定" class="headerlink" title="1.2.1 默认绑定"></a>1.2.1 默认绑定</h4><p>最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用 其他规则时的默认规则。<br>思考一下下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">foo(); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。 </p><p>接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了this 的默认绑定，因此<strong>this指向全局对象</strong>。 </p><p>那么我们怎么知道这里应用了默认绑定呢？<strong>可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</strong></p><p>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-meta"> "use strict"</span>; </span><br><span class="line"> <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">foo(); <span class="hljs-comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure><p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只 有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；<strong>严格模式下与 foo() 的调用位置无关</strong>：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; </span><br><span class="line"><span class="hljs-meta">"use strict"</span>;</span><br><span class="line"> foo(); <span class="hljs-comment">// 2 </span></span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><h4 id="1-2-2隐性绑定"><a href="#1-2-2隐性绑定" class="headerlink" title="1.2.2隐性绑定"></a>1.2.2隐性绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包 含，不过这种说法可能会造成一些误导。<br>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。</p><p>然而，<strong>调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥 有”或者“包含”它</strong>。 </p><p>无论你如何称呼这个模式，<strong>当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</strong></p><p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123; </span><br><span class="line">a: <span class="hljs-number">42</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>,</span><br><span class="line">obj2: obj2 </span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="hljs-comment">// 42</span></span><br></pre></td></tr></table></figure></p><h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题就是<strong>被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</strong></p><p>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = obj.foo; <span class="hljs-comment">// 函数别名！</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a 是全局对象的属性 </span></span><br><span class="line">bar(); <span class="hljs-comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFoo</span>(<span class="hljs-params">fn</span>) </span>&#123; </span><br><span class="line"><span class="hljs-comment">// fn 其实引用的是 foo </span></span><br><span class="line">fn(); <span class="hljs-comment">// &lt;-- 调用位置！ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a 是全局对象的属性 </span></span><br><span class="line">doFoo( obj.foo ); <span class="hljs-comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一 个例子一样。</p><p> 如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一 样的，没有区别：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a 是全局对象的属性 </span></span><br><span class="line">setTimeout( obj.foo, <span class="hljs-number">100</span> ); <span class="hljs-comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-显性绑定"><a href="#1-2-3-显性绑定" class="headerlink" title="1.2.3 显性绑定"></a>1.2.3 显性绑定</h4><p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函 数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 </p><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么 做呢？ </p><p>JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。 </p><p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。</p><p>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p><blockquote><p>从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现 在其他的参数上，但是现在我们不用考虑这些。</p></blockquote><p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><p><strong>1.硬绑定</strong><br>但是显式绑定的一个变种可以解决这个问题。 思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line">foo.call( obj ); </span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="hljs-comment">// 2 </span></span><br><span class="line">setTimeout( bar, <span class="hljs-number">100</span> ); <span class="hljs-comment">// 2 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this </span></span><br><span class="line">bar.call( <span class="hljs-built_in">window</span> ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们来看看这个变种到底是怎样工作的。我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 <code>Function.prototype. bind</code>，它的用法如下：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a, something );</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + something; </span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( obj );</span><br><span class="line"><span class="hljs-keyword">var</span> b = bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( b ); <span class="hljs-comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>2.API调用的“上下文”</strong><br>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。</p><p>举例来说：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">el</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( el, <span class="hljs-keyword">this</span>.id ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">id: <span class="hljs-string">"awesome"</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 调用 foo(..) 时把 this 绑定到 obj </span></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach( foo, obj ); </span><br><span class="line"><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。</p><h4 id="1-2-4-new绑定"><a href="#1-2-4-new绑定" class="headerlink" title="1.2.4 new绑定"></a>1.2.4 new绑定</h4><p>这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见 的关于 JavaScript 中函数和对象的误解。 </p><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会 调用类中的构造函数。通常的形式是这样的：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = <span class="hljs-keyword">new</span> MyClass(..);</span><br></pre></td></tr></table></figure></p><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它：</p><blockquote><p>当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的 对象。</p></blockquote><p>所以，包括内置对象函数（比如 Number(..)，详情请查看第 3 章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。 </li><li>这个新对象会被执行 [[ 原型 ]] 连接。</li><li>这个新对象会绑定到函数调用的 this。 </li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol><p>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.a = a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo(<span class="hljs-number">2</span>); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( bar.a ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-调用位置&quot;&gt;&lt;a href=&quot;#1-1-调用位置&quot; class=&quot;headerlink&quot; title=&quot;1.1 调用位置&quot;&gt;&lt;/a&gt;1.1 调用位置&lt;/h2&gt;&lt;p&gt;在理解 this 的绑定过程之前首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（一）</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（一）/</id>
    <published>2019-10-13T03:56:18.487Z</published>
    <updated>2019-10-13T04:09:03.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-为什么要用this"><a href="#1-1-为什么要用this" class="headerlink" title="1.1 为什么要用this"></a>1.1 为什么要用this</h2><p>如果对于有经验的JavaScript开发者来说this都是一种非常复杂的机制，那它到底有用在哪里呢？<a id="more"></a>真的值得我们付出这么大的代价学习吗？的确，在介绍怎么做之前我们需要先明白为什么。</p><p>下面我们来解释一下为什么要使用 this：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identify</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.toUpperCase(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">"Hello, I'm "</span> + identify.call( <span class="hljs-keyword">this</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( greeting ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> me = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Kyle"</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> you = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Reader"</span> &#125;;</span><br><span class="line">identify.call( me ); <span class="hljs-comment">// KYLE </span></span><br><span class="line">identify.call( you ); <span class="hljs-comment">// READER </span></span><br><span class="line">speak.call( me ); <span class="hljs-comment">// Hello, 我是 KYLE </span></span><br><span class="line">speak.call( you ); <span class="hljs-comment">// Hello, 我是 READER</span></span><br></pre></td></tr></table></figure><p>看不懂这段代码？不用担心！我们很快就会讲解。现在请暂时抛开这些问题，专注于为 什么。 这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。 如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identify</span>(<span class="hljs-params">context</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> context.name.toUpperCase(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params">context</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">"Hello, I'm "</span> + identify( context );</span><br><span class="line"> <span class="hljs-built_in">console</span>.log( greeting ); </span><br><span class="line">&#125;</span><br><span class="line">identify( you ); <span class="hljs-comment">// READER </span></span><br><span class="line">speak( me ); <span class="hljs-comment">//hello, 我是 KYLE</span></span><br></pre></td></tr></table></figure><p>然而，this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计 得更加简洁并且易于复用。 随着你的使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。当我们介绍对象和原型时，你就会明白函数可以自动引用合适的上下文对象 有多重要。</p><h2 id="1-2-误解"><a href="#1-2-误解" class="headerlink" title="1.2 误解"></a>1.2 误解</h2><h4 id="1-2-1-指向自身"><a href="#1-2-1-指向自身" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h4><p>人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说得通的。 </p><p>那么为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函 数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。 </p><p>JavaScript 的新手开发者通常会认为，既然函数看作一个对象（JavaScript 中的所有函数都 是对象），那就可以在调用函数时存储状态（属性的值）。这是可行的，有些时候也确实有 用，但是在本书即将介绍的许多模式中你会发现，除了函数对象还有许多更合适存储状态 的地方。 </p><p>不过现在我们先来分析一下这个模式，让大家看到 this 并不像我们所想的那样指向函数 本身。</p><p>我们想要记录一下函数 foo 被调用的次数，思考一下下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo: "</span> + num );</span><br><span class="line"> <span class="hljs-comment">// 记录 foo 被调用的次数</span></span><br><span class="line"><span class="hljs-keyword">this</span>.count++; </span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; </span><br><span class="line">foo( i ); </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="hljs-comment">// foo: 6 </span></span><br><span class="line"> <span class="hljs-comment">// foo: 7 </span></span><br><span class="line"> <span class="hljs-comment">// foo: 8 </span></span><br><span class="line"> <span class="hljs-comment">// foo: 9 </span></span><br><span class="line"> <span class="hljs-comment">// foo 被调用了多少次？ </span></span><br><span class="line"> <span class="hljs-built_in">console</span>.log( foo.count ); <span class="hljs-comment">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure><p>console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然 是 0。显然从字面意思来理解 this 是错误的。 </p><p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相 同，困惑随之产生。</p><p>遇到这样的问题时，许多开发者并不会深入思考为什么 this 的行为和预期的不一致，也不 会试图回答那些很难解决但却非常重要的问题。他们只会回避这个问题并使用其他方法来 达到目的，比如创建另一个带有 count 属性的对象。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo: "</span> + num ); </span><br><span class="line"><span class="hljs-comment">// 记录 foo 被调用的次数 </span></span><br><span class="line">data.count++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; </span><br><span class="line">foo( i ); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// foo: 6 </span></span><br><span class="line"><span class="hljs-comment">// foo: 7 </span></span><br><span class="line"><span class="hljs-comment">// foo: 8 </span></span><br><span class="line"><span class="hljs-comment">// foo: 9 </span></span><br><span class="line"><span class="hljs-comment">// foo 被调用了多少次？ </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( data.count ); <span class="hljs-comment">// 4</span></span><br></pre></td></tr></table></figure><p>从某种角度来说这个方法确实“解决”了问题，但可惜它忽略了真正的问题——无法理解 this 的含义和工作原理——而是返回舒适区，使用了一种更熟悉的技术：<strong>词法作用域</strong>。</p><p>另一种方法是强制 this 指向 foo 函数对象：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo: "</span> + num ); </span><br><span class="line"><span class="hljs-comment">// 记录 foo 被调用的次数 </span></span><br><span class="line"><span class="hljs-comment">// 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo</span></span><br><span class="line"><span class="hljs-keyword">this</span>.count++; </span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; </span><br><span class="line"><span class="hljs-comment">// 使用 call(..) 可以确保 this 指向函数对象 foo 本身 </span></span><br><span class="line">foo.call( foo, i ); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// foo: 6 </span></span><br><span class="line"><span class="hljs-comment">// foo: 7 </span></span><br><span class="line"><span class="hljs-comment">// foo: 8 </span></span><br><span class="line"><span class="hljs-comment">// foo: 9 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// foo 被调用了多少次？ </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( foo.count ); <span class="hljs-comment">// 4</span></span><br></pre></td></tr></table></figure><p>这次我们接受了 this，没有回避它。如果你仍然感到困惑的话，不用担心，之后我们会详 细解释具体的原理。</p><h4 id="1-2-2-它的作用域"><a href="#1-2-2-它的作用域" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它 是正确的，但是在其他情况下它却是错误的。 </p><p><strong>需要明确的是，this 在任何情况下都不指向函数的词法作用域</strong>。在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，<strong>它存在于 JavaScript 引擎内部</strong>。</p><p>思考一下下面的代码，它试图（但是没有成功）跨越边界，使用 this 来隐式引用函数的词 法作用域：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.bar(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="hljs-comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实 际上它出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感） 地展示了 this 多么容易误导人。 </p><p>首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的，我们之 后会解释原因。调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。 </p><p>此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你不能使用 this 来引用一 个词法作用域内部的东西。 </p><p><strong>每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</strong></p><h2 id="1-3-this到底是什么"><a href="#1-3-this到底是什么" class="headerlink" title="1.3 this到底是什么"></a>1.3 this到底是什么</h2><p>排除了一些错误理解之后，我们来看看 this 到底是一种什么样的机制。 </p><p>之前我们说过 <strong>this 是在运行时进行绑定的，并不是在编写时绑定</strong>，它的上下文取决于函数调 用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式</strong>。 </p><p><strong>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到</strong>。 </p><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>对于那些没有投入时间学习 this 机制的 JavaScript 开发者来说，this 的绑定一直是一件非常令人困惑的事。</p><p>this 是非常重要的，但是猜测、尝试并出错和盲目地从 Stack Overflow 上复制和粘贴答案并不能让你真正理解 this 的机制。 </p><p>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被 这样的解释误导过，但其实它们都是错误的。 </p><p><strong>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-为什么要用this&quot;&gt;&lt;a href=&quot;#1-1-为什么要用this&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要用this&quot;&gt;&lt;/a&gt;1.1 为什么要用this&lt;/h2&gt;&lt;p&gt;如果对于有经验的JavaScript开发者来说this都是一种非常复杂的机制，那它到底有用在哪里呢？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue中axios的封装和API接口的管理</title>
    <link href="https://jdsheng.cn/2019/10/01/vue%E4%B8%ADaxios%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8CAPI%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://jdsheng.cn/2019/10/01/vue中axios的封装和API接口的管理/</id>
    <published>2019-09-30T16:22:46.881Z</published>
    <updated>2019-10-02T03:18:39.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、axios的封装"><a href="#一、axios的封装" class="headerlink" title="一、axios的封装"></a>一、axios的封装</h1><p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，<a id="more"></a>它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步<a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios文档</a>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC83LzIzLzE2NGM3MDg1MmY0MWIwNGM?x-oss-process=image/format,png" alt="面对一团糟代码的你"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="hljs-keyword">install </span>axios<span class="hljs-comment">; // 安装axios</span></span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 在http.js中引入axios</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>; <span class="hljs-comment">// 引入axios</span></span><br><span class="line"><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>; <span class="hljs-comment">// 引入qs模块，用来序列化post类型的数据，后面会提到</span></span><br><span class="line"><span class="hljs-comment">// vant的toast提示框组件，大家可根据自己的ui组件更改。</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="环境的切换"><a href="#环境的切换" class="headerlink" title="环境的切换"></a>环境的切换</h3><p>我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。</p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 环境的切换</span></span><br><span class="line"><span class="hljs-built_in">if</span> (<span class="hljs-built_in">process</span>.env.NODE_ENV == <span class="hljs-string">'development'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'https://www.baidu.com'</span>;&#125; </span><br><span class="line"><span class="hljs-built_in">else</span> <span class="hljs-built_in">if</span> (<span class="hljs-built_in">process</span>.env.NODE_ENV == <span class="hljs-string">'debug'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'https://www.ceshi.com'</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-built_in">else</span> <span class="hljs-built_in">if</span> (<span class="hljs-built_in">process</span>.env.NODE_ENV == <span class="hljs-string">'production'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'https://www.production.com'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置请求超时"><a href="#设置请求超时" class="headerlink" title="设置请求超时"></a>设置请求超时</h3><p>通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。</p><figure class="highlight abnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = <span class="hljs-number">10000</span><span class="hljs-comment">;</span></span><br></pre></td></tr></table></figure><h3 id="post请求头的设置"><a href="#post请求头的设置" class="headerlink" title="post请求头的设置"></a>post请求头的设置</h3><p>post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为<code>application/x-www-form-urlencoded;charset=UTF-8</code></p><figure class="highlight ada hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="hljs-symbol">'Content</span>-<span class="hljs-keyword">Type</span>'] = <span class="hljs-symbol">'application</span>/x-www-form-urlencoded;charset=UTF-<span class="hljs-number">8</span>';</span><br></pre></td></tr></table></figure><h3 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h3><p>我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。</p><figure class="highlight stata hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 先导入vuex,因为我们要使用到里面的状态对象</span></span><br><span class="line"><span class="hljs-comment">// vuex的路径根据自己的路径去写</span></span><br><span class="line">import store from '@/store/index';</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 请求拦截器axios.interceptors.request.use(    </span></span><br><span class="line">    config =&gt; &#123;        </span><br><span class="line">        <span class="hljs-comment">// 每次发送请求之前判断vuex中是否存在token        </span></span><br><span class="line">        <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况</span></span><br><span class="line">        <span class="hljs-comment">// 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 </span></span><br><span class="line">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">token</span> = store.state.<span class="hljs-keyword">token</span>;        </span><br><span class="line">        <span class="hljs-keyword">token</span> &amp;&amp; (config.headers.Authorization = <span class="hljs-keyword">token</span>);        </span><br><span class="line">        <span class="hljs-keyword">return</span> config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="hljs-keyword">error</span> =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> Promise.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">error</span>);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。</p><p>然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊。</p><h3 id="响应的拦截"><a href="#响应的拦截" class="headerlink" title="响应的拦截"></a>响应的拦截</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(    </span><br><span class="line">    response =&gt; &#123;   </span><br><span class="line">        <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据     </span></span><br><span class="line">        <span class="hljs-comment">// 否则的话抛出错误</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response);        </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="hljs-comment">// 服务器状态码不是2开头的的情况</span></span><br><span class="line">    <span class="hljs-comment">// 这里可以跟你们的后台开发人员协商好统一的错误状态码    </span></span><br><span class="line">    <span class="hljs-comment">// 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等</span></span><br><span class="line">    <span class="hljs-comment">// 下面列举几个常见的操作，其他需求可自行扩展</span></span><br><span class="line">    error =&gt; &#123;            </span><br><span class="line">        <span class="hljs-keyword">if</span> (error.response.status) &#123;            </span><br><span class="line">            <span class="hljs-keyword">switch</span> (error.response.status) &#123;                </span><br><span class="line">                <span class="hljs-comment">// 401: 未登录</span></span><br><span class="line">                <span class="hljs-comment">// 未登录则跳转登录页面，并携带当前页面的路径</span></span><br><span class="line">                <span class="hljs-comment">// 在登录成功后返回当前页面，这一步需要在登录页操作。                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:                    </span><br><span class="line">                    router.replace(&#123;                        </span><br><span class="line">                        path: <span class="hljs-string">'/login'</span>,                        </span><br><span class="line">                        query: &#123; </span><br><span class="line">                            redirect: router.currentRoute.fullPath </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// 403 token过期</span></span><br><span class="line">                <span class="hljs-comment">// 登录过期对用户进行提示</span></span><br><span class="line">                <span class="hljs-comment">// 清除本地token和清空vuex中token对象</span></span><br><span class="line">                <span class="hljs-comment">// 跳转登录页面                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:</span><br><span class="line">                     Toast(&#123;</span><br><span class="line">                        message: <span class="hljs-string">'登录过期，请重新登录'</span>,</span><br><span class="line">                        duration: <span class="hljs-number">1000</span>,</span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-comment">// 清除token</span></span><br><span class="line">                    localStorage.removeItem(<span class="hljs-string">'token'</span>);</span><br><span class="line">                    store.commit(<span class="hljs-string">'loginSuccess'</span>, <span class="hljs-literal">null</span>);</span><br><span class="line">                    <span class="hljs-comment">// 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 </span></span><br><span class="line">                    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                        </span><br><span class="line">                        router.replace(&#123;                            </span><br><span class="line">                            path: <span class="hljs-string">'/login'</span>,                            </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;                        </span><br><span class="line">                        &#125;);                    </span><br><span class="line">                    &#125;, <span class="hljs-number">1000</span>);                    </span><br><span class="line">                    <span class="hljs-keyword">break</span>; </span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// 404请求不存在</span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:</span><br><span class="line">                    Toast(&#123;</span><br><span class="line">                        message: <span class="hljs-string">'网络请求不存在'</span>,</span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,</span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-comment">// 其他错误，直接抛出错误提示</span></span><br><span class="line">                <span class="hljs-keyword">default</span>:</span><br><span class="line">                    Toast(&#123;</span><br><span class="line">                        message: error.response.data.message,</span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,</span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。</p><blockquote><p>要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。</p></blockquote><h3 id="封装get方法和post方法"><a href="#封装get方法和post方法" class="headerlink" title="封装get方法和post方法"></a>封装get方法和post方法</h3><p>我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：<strong>get和post</strong>。</p><p><strong>get方法</strong>：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * get方法，对应get请求</span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址]</span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数]</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, params</span>)</span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;        </span><br><span class="line">        axios.get(url, &#123;            </span><br><span class="line">            params: params        </span><br><span class="line">        &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;</span><br><span class="line">            reject(err.data)        </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;);&#125;</span><br></pre></td></tr></table></figure><p>post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们<code>import QS from &#39;qs&#39;</code>;的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * post方法，对应post请求 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址] </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数] </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, params</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         axios.post(url, QS.stringify(params))</span><br><span class="line">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;</span><br><span class="line">            reject(err.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个小细节说下，<code>axios.get()</code>方法和<code>axios.post()</code>在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！</p><h1 id="二、api的统一管理"><a href="#二、api的统一管理" class="headerlink" title="二、api的统一管理"></a>二、api的统一管理</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzcvMTY1MTM0OWUwODY0YmVlNA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。上面说了，我们会新建一个api.js,然后在这个文件中存放我们所有的api接口。</p><p>首先我们在api.js中引入我们封装的get和post方法</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**   </span></span><br><span class="line"><span class="hljs-comment"> * api接口统一管理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">get</span>, post &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span></span><br></pre></td></tr></table></figure><p>现在，例如我们有这样一个接口，是一个post请求：</p><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="hljs-regexp">//</span>www.baiodu.com<span class="hljs-regexp">/api/</span>v1<span class="hljs-regexp">/users/my</span>_address<span class="hljs-regexp">/address_edit_before</span></span><br></pre></td></tr></table></figure><p>我们可以在api.js中这样封装：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiAddress = <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> post(<span class="hljs-string">'api/v1/users/my_address/address_edit_before'</span>, p);</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>apiAddress</code>方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的<code>post</code>方法，<code>post</code>方法的第一个参数是我们的接口地址，第二个参数是<code>apiAddress</code>的p参数，即请求接口时携带的参数对象。最后通过<code>export</code>导出<code>apiAddress</code>。</p><p>然后在我们的页面中可以这样调用我们的api接口：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; apiAddress &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/request/api'</span>;<span class="hljs-comment">// 导入我们的api接口</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;        </span><br><span class="line">    name: <span class="hljs-string">'Address'</span>,    </span><br><span class="line">    created () &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.onLoad();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;            </span><br><span class="line">        <span class="hljs-comment">// 获取数据            </span></span><br><span class="line">        onLoad() &#123;</span><br><span class="line">            <span class="hljs-comment">// 调用api接口，并且提供了两个参数                </span></span><br><span class="line">            apiAddress(&#123;                    </span><br><span class="line">                <span class="hljs-keyword">type</span>: <span class="hljs-number">0</span>,                    </span><br><span class="line">                sort: <span class="hljs-number">1</span>                </span><br><span class="line">            &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 获取数据成功后的其他操作</span></span><br><span class="line">                ………………                </span><br><span class="line">            &#125;)            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的api接口，就在pai.js中继续往下面扩展就可以了。</p><blockquote><p>友情提示，为每个接口写好注释哦！！！api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就规格gg了。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。</p></blockquote><p><strong>好了，最后把完成的<code>axios</code>封装代码奉上。</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**axios封装</span></span><br><span class="line"><span class="hljs-comment"> * 请求拦截、相应拦截、错误统一处理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'../store/index'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 环境的切换</span></span><br><span class="line"><span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'development'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'/api'</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'debug'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">''</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'production'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'http://api.123dailu.com/'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 请求超时时间</span></span><br><span class="line">axios.defaults.timeout = <span class="hljs-number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// post请求头</span></span><br><span class="line">axios.defaults.headers.post[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(    </span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="hljs-comment">// 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了</span></span><br><span class="line">        <span class="hljs-comment">// 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</span></span><br><span class="line">        <span class="hljs-keyword">const</span> token = store.state.token;        </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);        </span><br><span class="line">        <span class="hljs-keyword">return</span> config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    error =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.error(error);    </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(    </span><br><span class="line">    response =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response);        </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-comment">// 服务器状态码不是200的情况    </span></span><br><span class="line">    error =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">if</span> (error.response.status) &#123;            </span><br><span class="line">            <span class="hljs-keyword">switch</span> (error.response.status) &#123;                </span><br><span class="line">                <span class="hljs-comment">// 401: 未登录                </span></span><br><span class="line">                <span class="hljs-comment">// 未登录则跳转登录页面，并携带当前页面的路径                </span></span><br><span class="line">                <span class="hljs-comment">// 在登录成功后返回当前页面，这一步需要在登录页操作。                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:                    </span><br><span class="line">                    router.replace(&#123;                        </span><br><span class="line">                        path: <span class="hljs-string">'/login'</span>,                        </span><br><span class="line">                        query: &#123; <span class="hljs-attr">redirect</span>: router.currentRoute.fullPath &#125; </span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-comment">// 403 token过期                </span></span><br><span class="line">                <span class="hljs-comment">// 登录过期对用户进行提示                </span></span><br><span class="line">                <span class="hljs-comment">// 清除本地token和清空vuex中token对象                </span></span><br><span class="line">                <span class="hljs-comment">// 跳转登录页面                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:                     </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: <span class="hljs-string">'登录过期，请重新登录'</span>,                        </span><br><span class="line">                        duration: <span class="hljs-number">1000</span>,                        </span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span>                    </span><br><span class="line">                    &#125;);                    </span><br><span class="line">                    <span class="hljs-comment">// 清除token                    </span></span><br><span class="line">                    localStorage.removeItem(<span class="hljs-string">'token'</span>);                    </span><br><span class="line">                    store.commit(<span class="hljs-string">'loginSuccess'</span>, <span class="hljs-literal">null</span>);                    </span><br><span class="line">                    <span class="hljs-comment">// 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面</span></span><br><span class="line">                    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                        </span><br><span class="line">                        router.replace(&#123;                            </span><br><span class="line">                            path: <span class="hljs-string">'/login'</span>,                            </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;                        </span><br><span class="line">                        &#125;);                    </span><br><span class="line">                    &#125;, <span class="hljs-number">1000</span>);                    </span><br><span class="line">                    <span class="hljs-keyword">break</span>; </span><br><span class="line">                <span class="hljs-comment">// 404请求不存在                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:                    </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: <span class="hljs-string">'网络请求不存在'</span>,                        </span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,                        </span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span>                    </span><br><span class="line">                    &#125;);                    </span><br><span class="line">                <span class="hljs-keyword">break</span>;                </span><br><span class="line">                <span class="hljs-comment">// 其他错误，直接抛出错误提示                </span></span><br><span class="line">                <span class="hljs-keyword">default</span>:                    </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: error.response.data.message,                        </span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,                        </span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span>                    </span><br><span class="line">                    &#125;);            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response);        </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * get方法，对应get请求 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址] </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数] </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, params</span>)</span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;        </span><br><span class="line">        axios.get(url, &#123;            </span><br><span class="line">            params: params        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;            </span><br><span class="line">            resolve(res.data);        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;            </span><br><span class="line">            reject(err.data)        </span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * post方法，对应post请求 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址] </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数] </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, params</span>) </span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;         </span><br><span class="line">        axios.post(url, QS.stringify(params))        </span><br><span class="line">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;            </span><br><span class="line">            resolve(res.data);        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;            </span><br><span class="line">            reject(err.data)        </span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>axios的封装根据需求的不同而不同。我也对此进行了思考和针对不同需求的改善。主要有以下改变：</p><ol><li>优化axios封装，去掉之前的get和post</li><li>断网情况处理</li><li>更加模块化的api管理</li><li>接口域名有多个的情况</li><li>api挂载到vue.prototype上省去引入的步骤</li></ol><p>http.js中axios封装的优化，先直接贴代码：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * axios封装</span></span><br><span class="line"><span class="hljs-comment"> * 请求拦截、响应拦截、错误统一处理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'../router'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'../store/index'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 提示函数 </span></span><br><span class="line"><span class="hljs-comment"> * 禁止点击蒙层、显示一秒后关闭</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> tip = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;    </span><br><span class="line">    Toast(&#123;        </span><br><span class="line">        message: msg,        </span><br><span class="line">        duration: <span class="hljs-number">1000</span>,        </span><br><span class="line">        forbidClick: <span class="hljs-literal">true</span>    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 跳转登录页</span></span><br><span class="line"><span class="hljs-comment"> * 携带当前页面路由，以期在登录页面完成登录后返回当前页面</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> toLogin = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.replace(&#123;</span><br><span class="line">        path: <span class="hljs-string">'/login'</span>,        </span><br><span class="line">        query: &#123;</span><br><span class="line">            redirect: router.currentRoute.fullPath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 请求失败后的错误统一处理 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Number&#125; status 请求失败的状态码</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">status, other</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 状态码判断</span></span><br><span class="line">    <span class="hljs-keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="hljs-comment">// 401: 未登录状态，跳转登录页</span></span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:</span><br><span class="line">            toLogin();</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-comment">// 403 token过期</span></span><br><span class="line">        <span class="hljs-comment">// 清除token并跳转登录页</span></span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:</span><br><span class="line">            tip(<span class="hljs-string">'登录过期，请重新登录'</span>);</span><br><span class="line">            localStorage.removeItem(<span class="hljs-string">'token'</span>);</span><br><span class="line">            store.commit(<span class="hljs-string">'loginSuccess'</span>, <span class="hljs-literal">null</span>);</span><br><span class="line">            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">                toLogin();</span><br><span class="line">            &#125;, <span class="hljs-number">1000</span>);</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-comment">// 404请求不存在</span></span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:</span><br><span class="line">            tip(<span class="hljs-string">'请求的资源不存在'</span>); </span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">default</span>:</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(other);   </span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 创建axios实例</span></span><br><span class="line"><span class="hljs-keyword">var</span> instance = axios.create(&#123;    timeout: <span class="hljs-number">1000</span> * <span class="hljs-number">12</span>&#125;);</span><br><span class="line"><span class="hljs-comment">// 设置post请求头</span></span><br><span class="line">instance.defaults.headers.post[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 请求拦截器 </span></span><br><span class="line"><span class="hljs-comment"> * 每次请求前，如果存在token则在请求头中携带token </span></span><br><span class="line"><span class="hljs-comment"> */</span> </span><br><span class="line">instance.interceptors.request.use(    </span><br><span class="line">    config =&gt; &#123;        </span><br><span class="line">        <span class="hljs-comment">// 登录流程控制中，根据本地是否存在token判断用户的登录情况        </span></span><br><span class="line">        <span class="hljs-comment">// 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token        </span></span><br><span class="line">        <span class="hljs-comment">// 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码        </span></span><br><span class="line">        <span class="hljs-comment">// 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。        </span></span><br><span class="line">        <span class="hljs-keyword">const</span> token = store.state.token;        </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);        </span><br><span class="line">        <span class="hljs-keyword">return</span> config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    error =&gt; <span class="hljs-built_in">Promise</span>.error(error))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 响应拦截器</span></span><br><span class="line">instance.interceptors.response.use(    </span><br><span class="line">    <span class="hljs-comment">// 请求成功</span></span><br><span class="line">    res =&gt; res.status === <span class="hljs-number">200</span> ? <span class="hljs-built_in">Promise</span>.resolve(res) : <span class="hljs-built_in">Promise</span>.reject(res),    </span><br><span class="line">    <span class="hljs-comment">// 请求失败</span></span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> &#123; response &#125; = error;</span><br><span class="line">        <span class="hljs-keyword">if</span> (response) &#123;</span><br><span class="line">            <span class="hljs-comment">// 请求已发出，但是不在2xx的范围 </span></span><br><span class="line">            errorHandle(response.status, response.data.message);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 处理断网的情况</span></span><br><span class="line">            <span class="hljs-comment">// eg:请求超时或断网时，更新state的network状态</span></span><br><span class="line">            <span class="hljs-comment">// network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏</span></span><br><span class="line">            <span class="hljs-comment">// 关于断网组件中的刷新重新获取数据，会在断网组件中说明</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.navigator.onLine) &#123;</span><br><span class="line">               store.commit(<span class="hljs-string">'changeNetwork'</span>, <span class="hljs-literal">false</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance;</span><br></pre></td></tr></table></figure><p>这个axios和之前的大同小异，做了如下几点改变：</p><ul><li>去掉了之前get和post方法的封装，通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。</li><li>去掉了通过环境变量控制baseUrl的值。考虑到接口会有多个不同域名的情况，所以准备通过js变量来控制接口域名。这点具体在api里会介绍。</li><li>增加了请求超时，即断网状态的处理。说下思路，当断网时，通过更新vuex中network的状态来控制断网提示组件的显示隐藏。断网提示一般会有重新加载数据的操作，这步会在后面对应的地方介绍。</li><li><p>公用函数进行抽出，简化代码，尽量保证单一职责原则。</p><p><strong>下面说下api这块，考虑到一下需求：</strong></p></li><li><p>更加模块化</p></li><li>更方便多人开发，有效减少解决命名冲突</li><li><p>处理接口域名有多个情况</p><p>这里这里呢新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。</p></li></ul><p>先放index.js代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * api接口的统一出口</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-comment">// 文章模块接口</span></span><br><span class="line"><span class="hljs-keyword">import</span> article <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/article'</span>;</span><br><span class="line"><span class="hljs-comment">// 其他模块的接口……</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 导出接口</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    </span><br><span class="line">    article,</span><br><span class="line">    <span class="hljs-comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js是一个api接口的出口，这样就可以把api接口根据功能划分为多个模块，利于多人协作开发，比如一个人只负责一个模块的开发等，还能方便每个模块中接口的命名哦。</p><p>base.js:</p><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 接口域名的管理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">base</span> = &#123;    </span><br><span class="line">    sq: <span class="hljs-string">'https://xxxx111111.com/api/v1'</span>,    </span><br><span class="line">    bd: <span class="hljs-string">'http://xxxxx22222.com/api'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="hljs-keyword">default</span> <span class="hljs-keyword">base</span>;</span><br></pre></td></tr></table></figure><p>通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。</p><p>最后就是接口模块的说明，例如上面的article.js:</p><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * article模块接口列表</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"></span><br><span class="line">import <span class="hljs-keyword">base</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./base'</span>; <span class="hljs-comment">// 导入接口域名列表</span></span><br><span class="line">import axios <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/http'</span>; <span class="hljs-comment">// 导入http中创建的axios实例</span></span><br><span class="line">import qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>; <span class="hljs-comment">// 根据需求是否导入qs模块</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> article = &#123;    </span><br><span class="line">    <span class="hljs-comment">// 新闻列表    </span></span><br><span class="line">    articleList () &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> axios.<span class="hljs-keyword">get</span>(`$&#123;<span class="hljs-keyword">base</span>.sq&#125;/topics`);    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="hljs-comment">// 新闻详情,演示    </span></span><br><span class="line">    articleDetail (id, <span class="hljs-keyword">params</span>) &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> axios.<span class="hljs-keyword">get</span>(`$&#123;<span class="hljs-keyword">base</span>.sq&#125;/topic/$&#123;id&#125;`, &#123;            </span><br><span class="line">            <span class="hljs-keyword">params</span>: <span class="hljs-keyword">params</span>        </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-comment">// post提交    </span></span><br><span class="line">    login (<span class="hljs-keyword">params</span>) &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> axios.post(`$&#123;<span class="hljs-keyword">base</span>.sq&#125;/accesstoken`, qs.stringify(<span class="hljs-keyword">params</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 其他接口…………</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="hljs-keyword">default</span> article;</span><br></pre></td></tr></table></figure><ol><li>通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对<code>post</code>请求时提交的数据进行一个qs序列化的处理等。</li><li>请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，<code>axios</code>文档说的很清楚，这个顺序是：在 <code>lib/defaults.js</code> 找到的库的默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者将优先于前者。</li><li>restful风格的接口，也可以通过这种方式灵活的设置api接口地址。</li></ol><p>最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中：</p><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span></span><br><span class="line"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span> <span class="hljs-comment">// 导入路由文件</span></span><br><span class="line"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span> <span class="hljs-comment">// 导入vuex文件</span></span><br><span class="line"><span class="hljs-keyword">import</span> api <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span> <span class="hljs-comment">// 导入api接口</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$api = api; <span class="hljs-comment">// 将api挂载到vue的原型上</span></span><br></pre></td></tr></table></figure><p>然后我们可以在页面中这样调用接口，eg：</p><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;    </span><br><span class="line">    onLoad(id) &#123;      </span><br><span class="line">        this.<span class="hljs-variable">$api</span><span class="hljs-selector-class">.article</span><span class="hljs-selector-class">.articleDetail</span>(id, &#123;        </span><br><span class="line">            api: <span class="hljs-number">123</span>      </span><br><span class="line">        &#125;).then(res=&gt; &#123;</span><br><span class="line">            <span class="hljs-comment">// 执行某些操作      </span></span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再提一下断网的处理，这里只做一个简单的示例：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  </span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    </span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!network"</span>&gt;</span>      </span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我没网了<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      </span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"onRefresh"</span>&gt;</span>刷新<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      </span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    </span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span>      </span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  </span></span><br><span class="line"><span class="hljs-actionscript">        name: <span class="hljs-string">'App'</span>,  </span></span><br><span class="line"><span class="hljs-undefined">        computed: &#123;    </span></span><br><span class="line"><span class="hljs-actionscript">            ...mapState([<span class="hljs-string">'network'</span>])  </span></span><br><span class="line"><span class="hljs-undefined">        &#125;,  </span></span><br><span class="line"><span class="hljs-undefined">        methods: &#123;    </span></span><br><span class="line"><span class="hljs-actionscript">            <span class="hljs-comment">// 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的</span></span></span><br><span class="line"><span class="hljs-undefined">            onRefresh () &#123;      </span></span><br><span class="line"><span class="hljs-actionscript">                <span class="hljs-keyword">this</span>.$router.replace(<span class="hljs-string">'/refresh'</span>)    </span></span><br><span class="line"><span class="hljs-undefined">            &#125;  </span></span><br><span class="line"><span class="hljs-undefined">        &#125;</span></span><br><span class="line"><span class="hljs-undefined">    &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其<code>beforeRouteEnter</code>钩子中再返回当前页面。</p><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// refresh.vue</span></span><br><span class="line">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">next</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">next</span>(vm =&gt; &#123;            </span><br><span class="line">        vm.$router.replace(<span class="hljs-keyword">from</span>.fullPath)        </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种全局通用的断网提示，当然了，也可以根据自己的项目需求操作。具体操作就仁者见仁智者见智了。</p><p>如果更多的需求，或者说是不一样的需求，可以根据自己的需求进行一个改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、axios的封装&quot;&gt;&lt;a href=&quot;#一、axios的封装&quot; class=&quot;headerlink&quot; title=&quot;一、axios的封装&quot;&gt;&lt;/a&gt;一、axios的封装&lt;/h1&gt;&lt;p&gt;在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://jdsheng.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Git 基本知识与常用指令</title>
    <link href="https://jdsheng.cn/2019/10/01/Git%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://jdsheng.cn/2019/10/01/Git 基本知识与常用指令/</id>
    <published>2019-09-30T16:22:19.486Z</published>
    <updated>2019-10-02T03:30:11.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git代码状态转换图"><a href="#一、Git代码状态转换图" class="headerlink" title="一、Git代码状态转换图"></a>一、Git代码状态转换图</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM3NTAzOC8yMDE4MDUvMTM3NTAzOC0yMDE4MDUyMjE2MDk0Mjc2NS0xNDg4MjU0MzkyLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>其中：</p><ul><li>未被Git跟踪的状态为unstage状态；<a id="more"></a></li><li><p>已被Git跟踪的状态为stage状态（stage：阶段），因此包括staging状态和staged状态。</p><p>untrack files：是指<strong>尚未被git所管理的文件</strong>；</p><p>changed but not updated：是指文件被git管理，并且发生了改变，但改动还没被git管理；这两种状态，都可以看成是改动还没被git管理的状态，我们这里称unstage状态。</p><p>staging是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。</p></li></ul><p>changes to be commited是指进入staged状态的文件。</p><p><code>.gitignore</code>中的文件，不会出现在以上三个状态中。</p><blockquote><p>注：</p><ul><li>这个图也解释了为啥从远端库拉代码，不需要add、commit。</li><li>代码一旦修改，就会成为未被git库跟踪的状态。需要add、commit。</li></ul></blockquote><h2 id="二、大白话Git"><a href="#二、大白话Git" class="headerlink" title="二、大白话Git"></a>二、大白话Git</h2><ol><li>Git 管理代码，保证代码版本迭代连续性，即：向A分支merge或者push代码时，A分支代码必须是当前代码的上一个版本，不然会产生冲突。（换句话说：Git确保当前的本地的代码为最新）</li><li>Git有修改就有提交，就有新的代码版本，git管理维护的是修改。</li><li>Git分支存储的是代码副本。</li><li><p>push ：实际上就是将本地分支合并到远端库分支；pull：实际就是将远端分支合并到本地分支。</p><h2 id="三、Git本地常用操作指令"><a href="#三、Git本地常用操作指令" class="headerlink" title="三、Git本地常用操作指令"></a>三、Git本地常用操作指令</h2></li></ol><p><strong>1、创建git库</strong></p><p>　<code>git init</code>   #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库）</p><p><strong>2、注册git用户</strong></p><p>—&gt;用于在团队合作开发中，表明代码作者。</p><p>　　</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git<span class="hljs-built_in"> config </span>--global user.name XXX  #用户名</span><br><span class="line"></span><br><span class="line">git<span class="hljs-built_in"> config </span>--global user.email XXX   #用户邮箱</span><br><span class="line"></span><br><span class="line">git<span class="hljs-built_in"> config </span>--list  #查看用户信息</span><br></pre></td></tr></table></figure><blockquote><p>注：加–global，全局设置。</p></blockquote><p><strong>3、向git库添加修改</strong></p><p><code>git add [path］</code> #会把对应目录或文件，添加到stage状态<br><code>git add .</code>  #会把当前所有的untrack files和changed but not updated添加到stage状态</p><p>实际上是为修改内容添加index索引。</p><p><strong>4、向版本库提交修改</strong></p><p><code>git commit –m “XXXX”</code>     #提交修改,添加注释</p><blockquote><p>注：git 提示： 未有add红色字体，未有commit绿色字体，已提交则worktree是干净的</p></blockquote><p><strong>5、查看当前代码库的状态</strong></p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git status</span></span><br></pre></td></tr></table></figure><p><strong>6、查看版本信息</strong></p><p>—&gt;实际是查看修改提交信息</p><figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">log</span></span><br></pre></td></tr></table></figure><p><code>git log --graph</code>  #以图形化（节点）展示当前git库的提交信息。</p><p><strong>7、查看指定版本信息</strong></p><p><code>git show sdjf974654dd….</code>  #(show后面为每次提交系统自动生成的一串哈希值)</p><p><code>git show sdji97</code> #一般只使用版本号的前几个字符即可</p><p><strong>8、撤销修改</strong></p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git reset</span></span><br></pre></td></tr></table></figure><p>（1）撤销整体修改</p><p><code>git reset --hard</code>  #回到原来编辑的地方,改动会丢失。（同样适用于团队对于其他人的修改恢复）<br><code>git reset --hard sdv143kvf…...</code> #可回到指定的版本#(hard后面为每次提交系统自动生成的一串哈希值)<br><code>git reset [path]</code> 会改变path指定的文件或目录的stage状态，到非stage状态。<br><code>git reset</code> 会将所有stage的文件状态，都改变成非stage状态。</p><p>（2）撤销某次修改</p><p>回退1个change的写法就是git reset HEAD^，<br>2个为HEAD^^，<br>3个为HEAD~3，以此类推。</p><p><strong>9、向远端库推送修改（提交修改）</strong></p><p><code>git push origin</code> 分支名</p><p><strong>10、暂存修改</strong></p><p>git stash可以把当前的改动（stage和unstage，但不包括untrack的文件）暂存。</p><p>然后通过git stash list查看。</p><p>并通过git stash apply重新取出来。但apply之前要保证worktree是干净的。</p><h2 id="四、Git团队开发常用操作指令"><a href="#四、Git团队开发常用操作指令" class="headerlink" title="四、Git团队开发常用操作指令"></a>四、Git团队开发常用操作指令</h2><p><strong>1、获取远端库项目</strong></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  <span class="hljs-built_in">clone</span>/pull</span><br></pre></td></tr></table></figure><p><strong>2、团队开发的基本流程（多分支合并一个分支）</strong></p><p><code>git add .</code>   #添加改动的文件<br><code>git commit</code>  #（提交至本地）<br><code>git pull --rebase</code>  #（将服务器项目与本地项目合并）<br><code>git push</code>    #（将本地项目上传至远端库）<br>（在提交前要git pull –rebase 一下，确保当前的本地的代码为最新。）</p><h2 id="五、Git-分支管理"><a href="#五、Git-分支管理" class="headerlink" title="五、Git 分支管理"></a>五、Git 分支管理</h2><p><strong>1、建立分支</strong></p><p><code>git branch AAA</code>   #建立分支AAA</p><p><strong>2、分支切换</strong></p><p><code>git checkout AAA</code>   #从当前分支切换到AAA分支 (若AAA分支不存在，则自动新建)</p><p><strong>3、将分支与主枝master合并</strong></p><p><code>git checkout master</code>   #（首先切换回主枝）<br><code>git merge AAA</code>    #（将分支AAA与主枝合并）</p><blockquote><p>注：git merge：默认情况下，Git执行”快进式合并”（fast-farward<br>merge），会直接将Master分支指向Develop分支。</p></blockquote><p>使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰（保持提交曲线为直线），建议采用这种方法。</p><p><strong>4、当前分支查看</strong></p><p><code>git branch</code>    #默认有master（也称为主枝）<br><code>git branch -r</code>  #查看远端库分支<br><code>git branch –a</code>  #查看当前所有分支（包括本地分支和远端库分支）</p><p><strong>5、删除分支</strong></p><p><code>git branch –d  AAA</code>   #删除分支AAA</p><p><strong>6、切下远端库A分支到本地库A分支</strong></p><p><code>git checkout -b  A origin/A</code>  （若本地A分支不存在，则自动新建）</p><blockquote><p>注：上面只是一些基本的操作命令，更多的命令可通过帮助文档查询。</p></blockquote><p>帮助文档的使用：<br><code>man git-</code>&lt;需查询的指令&gt;  #（git后面有“-”）<br>如commit的查询为  <code>man git-commit</code></p><h2 id="六、本地代码上传Github"><a href="#六、本地代码上传Github" class="headerlink" title="六、本地代码上传Github"></a>六、本地代码上传Github</h2><ol><li>Gtthub上建立远端仓库，复制下载链接。</li><li>本地指定目录下，Gitbash粘贴远端仓库下载链接拉取远端仓库代码</li><li>复制本地需要提交的代码到远端仓库目录。</li><li><code>Git add、commit、push</code> 提交本地代码至Github远端仓库。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Git代码状态转换图&quot;&gt;&lt;a href=&quot;#一、Git代码状态转换图&quot; class=&quot;headerlink&quot; title=&quot;一、Git代码状态转换图&quot;&gt;&lt;/a&gt;一、Git代码状态转换图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM3NTAzOC8yMDE4MDUvMTM3NTAzOC0yMDE4MDUyMjE2MDk0Mjc2NS0xNDg4MjU0MzkyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未被Git跟踪的状态为unstage状态；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="git" scheme="https://jdsheng.cn/categories/git/"/>
    
    
      <category term="git" scheme="https://jdsheng.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语法（预备篇）：到底要不要写分号呢？</title>
    <link href="https://jdsheng.cn/2019/07/25/JavaScript%E8%AF%AD%E6%B3%95%EF%BC%88%E9%A2%84%E5%A4%87%E7%AF%87%EF%BC%89%EF%BC%9A%E5%88%B0%E5%BA%95%E8%A6%81%E4%B8%8D%E8%A6%81%E5%86%99%E5%88%86%E5%8F%B7%E5%91%A2%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/07/25/JavaScript语法（预备篇）：到底要不要写分号呢？/</id>
    <published>2019-07-25T14:34:54.007Z</published>
    <updated>2019-09-30T16:30:05.320Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>在我们介绍 JavaScript 语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。</p><br>  <p>这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。</p><a id="more"></a><br>  <p>实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。</p><br><br>  <p>但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。</p><br><br>  <p>这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。</p><br>  <p>我们首先来了解一下自动插入分号的规则。</p><br>  <h2>自动插入分号规则</h2><br>  <p>自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。</p><br>  <ul><br>    <li>要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</li><br>    <li>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</li><br>    <li>源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</li><br>  </ul><br>  <p>这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;(a);</span><br></pre></td></tr></table></figure><br><br><p>在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入换行符。</p><br><br><figure class="highlight asciidoc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1, b = 1, c = 1;</span><br><span class="line">a</span><br><span class="line">++</span><br><span class="line">b</span><br><span class="line">++</span><br><span class="line">c</span><br></pre></td></tr></table></figure><br><br><p>这也是个著名的例子，我们看第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有 [no LineTerminator here] 这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容：</p><br><br><figure class="highlight hsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UpdateExpression[<span class="hljs-keyword">Yield</span>, <span class="hljs-keyword">Await</span>]:</span><br><span class="line">    LeftHandSideExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>]</span><br><span class="line">    LeftHandSideExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>][no LineTerminator here]++</span><br><span class="line">    LeftHandSideExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>][no LineTerminator here]--</span><br><span class="line">    ++UnaryExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>]</span><br><span class="line">    --UnaryExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>]</span><br></pre></td></tr></table></figure><br><br><p>于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。</p><br><br><figure class="highlight clojure hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-name">function</span>(<span class="hljs-name">a</span>)&#123;</span><br><span class="line">    console.log(<span class="hljs-name">a</span>)<span class="hljs-comment">;</span></span><br><span class="line">&#125;)()</span><br><span class="line">(<span class="hljs-name">function</span>(<span class="hljs-name">a</span>)&#123;</span><br><span class="line">    console.log(<span class="hljs-name">a</span>)<span class="hljs-comment">;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br><br><p>这个例子是比较有实际价值的例子，这里两个 function 调用的写法被称作 IIFE（立即执行的函数表达式），是个常见技巧。</p><p>这段代码意图上显然是形成两个 IIFE。</p><p>我们来看第三行结束的位置，JavaScript 引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。</p><p>这是一些鼓励不写分号的编码风格会要求大家写 IIFE 时必须在行首加分号的原因。</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">        This is a return value.</span></span><br><span class="line"><span class="hljs-comment">    */</span><span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><br><br><p>在这个例子中，return 和 1 被用注释分隔开了。</p><p>根据 JavaScript 自动插入分号规则，<strong>带换行符的注释也被认为是有换行符</strong>，而恰好的是，return 也有 [no LineTerminator here] 规则的要求。所以这里会自动插入分号，f 执行的返回值是 undefined。</p><h2>no LineTerminator here 规则</h2><p>好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对 JavaScript 的语法定义做一些数据挖掘工作。</p><p>no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。</p><p>自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟 no LineTerminator here 规则强相关，那么我们就找出 JavaScript 语法定义中的这些规则。</p><p><img src="https://static001.geekbang.org/resource/image/c3/ad/c3ffbc89e049ad1901d4108c8ad88aad.jpg" alt=""></p><p>为了方便你理解，我把产生式换成了实际的代码。</p><p>下面一段代码展示了，带标签的 continue 语句，不能在 continue 后插入换行。</p><br><br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outer:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)</span><br><span class="line">        <span class="hljs-keyword">continue</span> <span class="hljs-comment">/*no LineTerminator here*/</span> outter</span><br></pre></td></tr></table></figure><br><br><p>break 跟 continue 是一样的，break 后也不能插入换行：</p><br><br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outer:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)</span><br><span class="line">        <span class="hljs-keyword">break</span> <span class="hljs-comment">/*no LineTerminator here*/</span> outter</span><br></pre></td></tr></table></figure><br><br><p>我们前面已经提到过 return 和后自增、后自减运算符。</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i<span class="hljs-comment">/*no LineTerminator here*/</span>++</span><br><span class="line">i<span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-comment">--</span></span><br></pre></td></tr></table></figure><br><br><p>以及，throw 和 Exception 之间也不能插入换行符：</p><br><br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">throw</span><span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"error"</span>)</span><br></pre></td></tr></table></figure><br><br><p>凡是 async 关键字，后面都不能插入换行符：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span><span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">async</span><span class="hljs-comment">/*no LineTerminator here*/</span>x =&gt; x*x</span><br></pre></td></tr></table></figure><br><br><p>箭头函数的箭头前，也不能插入换行：</p><br><br><figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> f = x<span class="hljs-comment">/*no LineTerminator here*/</span>=&gt; x*x</span><br></pre></td></tr></table></figure><br><br><p>yield 之后，不能插入换行：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)</span><br><span class="line">        <span class="hljs-keyword">yield</span><span class="hljs-comment">/*no LineTerminator here*/</span>i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>到这里，我已经整理了所有标准中的 no LineTerminator here 规则，实际上，no LineTerminator here 规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript 在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。</p><h2>不写分号需要注意的情况</h2><p>下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。</p><h3>以括号开头的语句</h3><p>我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;)()<span class="hljs-comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br><br><p>这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。</p><h3>以数组开头的语句</h3><p>除了括号，以数组开头的语句也十分危险：</p><br><br><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="hljs-string">[[]]</span>/* 这里没有被自动插入分号 */</span><br><span class="line">[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>].forEach(e =&gt; console.<span class="hljs-built_in">log</span>(e))</span><br></pre></td></tr></table></figure><br><br><p>这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。</p><h3>以正则表达式开头的语句</h3><p>正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>, g = &#123;<span class="hljs-attr">test</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-number">0</span>&#125;, b = <span class="hljs-number">1</span><span class="hljs-comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">/(a)/g.test(<span class="hljs-string">"abc"</span>)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure><br><br><p>这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。</p><p>注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。</p><h3>以 Template 开头的语句</h3><p>以 Template 开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> g = f<span class="hljs-comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line"><span class="hljs-string">`Template`</span>.match(<span class="hljs-regexp">/(a)/</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure><br><br><p>这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。</p><h2>总结</h2><p>这一节课，我们讨论了要不要加分号的问题。</p><p>首先我们介绍了自动插入分号机制，又对 JavaScript 语法中的 no line terminator 规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。</p><p>最后留一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;在我们介绍 JavaScript 语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。&lt;/p&gt;&lt;br&gt;  &lt;p&gt;这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript词法：为什么12.toString会报错？</title>
    <link href="https://jdsheng.cn/2019/07/25/JavaScript%E8%AF%8D%E6%B3%95%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%8812.toString%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/07/25/JavaScript词法：为什么12.toString会报错？/</id>
    <published>2019-07-25T14:16:36.789Z</published>
    <updated>2019-10-02T03:33:00.450Z</updated>
    
    <content type="html"><![CDATA[<p><div class="_1kh1ihh6_0"><br>  文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。</div></p><p>  词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。<br>  <a id="more"></a><br>  从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。</p><p>  </p><h2>概述</h2><br>  我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：<br>  <ul><br>    <li>WhiteSpace 空白字符</li><br>    <li>LineTerminator 换行符</li><br>    <li>Comment 注释</li><br>    <li>Token 词<br>      <ul><br>        <li>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</li><br>        <li>Punctuator 符号，我们使用的运算符和大括号等符号。</li><br>        <li>NumericLiteral 数字直接量，就是我们写的数字。</li><br>        <li>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</li><br>        <li>Template 字符串模板，用反引号<code>`</code> 括起来的直接量。</li><br>      </ul><br>    </li><br>  </ul><p></p><p>  这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。<br>  首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。</p><p>  但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。</p><p>  JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的：</p>  <figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Hello, $&#123;name&#125;`</span><br></pre></td></tr></table></figure><p>  理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。是否允许“ }”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：<br>  <ul><br>    <li>InputElementDiv；</li><br>    <li>InputElementRegExp；</li><br>    <li>InputElementRegExpOrTemplateTail；</li><br>    <li>InputElementTemplateTail。</li><br>  </ul><br>  为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为CommonToken。但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。</p><p>  对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。</p><p>  接下来我来给你详细介绍一下。</p><p>  </p><h3>空白符号Whitespace</h3><br>  说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。<br>  <ul><br>    <li><br>      <code>&lt;HT&gt;</code>(或称<code>&lt;TAB&gt;</code>) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \t 。<br>    </li><br>    <li><br>      <code>&lt;VT&gt;</code>是 U+000B，也就是垂直方向的 TAB 符 \v，这个字符在键盘上很难打出来，所以很少用到。<br>    </li><br>    <li><br>      <code>&lt;FF&gt;</code>是 U+000C，Form Feed，分页符，字符串直接量中写作 \f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。<br>    </li><br>    <li><br>      <code>&lt;SP&gt;</code>是 U+0020，就是最普通的空格了。<br>    </li><br>    <li><br>      <code>&lt;NBSP&gt;</code>是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript<br>      编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 <code>&amp;nbsp;</code> 最后生成的就是它了。<br>    </li><br>    <li><br>      <code>&lt;ZWNBSP&gt;</code>(旧称<code>&lt;BOM&gt;</code>) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。<br>    </li><br>  </ul><br>  此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表：<br>  <img src="https://static001.geekbang.org/resource/image/dd/60/dd26aa9599b61d26e7de807dee2c6360.png" alt="">很多公司的编码规范要求JavaScript 源代码控制在 ASCII 范围内，那么，就只有<code>&lt;TAB&gt;</code> <code>&lt;VT&gt;</code> <code>&lt;FF&gt;</code><code>&lt;SP&gt;</code> <code>&lt;NBSP&gt;</code>五种空白可用了。<h3>换行符 LineTerminator</h3>接下来我们来看看换行符，JavaScript 中只提供了 4种字符作为换行符。<br>  <ul><br>    <li><code>&lt;LF&gt;</code></li><br>    <li><code>&lt;CR&gt;</code></li><br>    <li><code>&lt;LS&gt;</code></li><br>    <li><code>&lt;PS&gt;</code></li><br>  </ul><br>  其中，<br>  <code>&lt;LF&gt;</code>是 U+000A，就是最正常换行符，在字符串中的<code>\n</code>。<p></p><p>  <code>&lt;CR&gt;</code>是U+000D，这个字符真正意义上的“回车”，在字符串中是<code>\r</code>，在一部分 Windows 风格文本编辑器中，换行是两个字符<code>\r\n</code>。</p><p>  <code>&lt;LS&gt;</code>是U+2028，是 Unicode 中的行分隔符。</p><p>  <code>&lt;PS&gt;</code>是 U+2029，是 Unicode 中的段落分隔符。</p><p>  大部分 LineTerminator在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。</p><p>  </p><h3>注释 Comment</h3><br>  JavaScript的注释分为单行注释和多行注释两种：<p></p>  <figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* MultiLineCommentChars */</span></span><br><span class="line"><span class="hljs-comment">// SingleLineCommentChars</span></span><br></pre></td></tr></table></figure><p>  多行注释中允许自由地出现<code>MultiLineNotAsteriskChar</code>，也就是除了<code><em></em></code>之外的所有字符。而每一个<code></code>之后，不能出现正斜杠符<code>/</code>。除了四种LineTerminator 之外，所有字符都可以作为单行注释。我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。</p><p>  </p><h2>标识符名称 IdentifierName</h2><br>  <code>IdentifierName</code>可以以美元符“<code>$</code>”、下划线“<code>_</code>”或者 Unicode字母开始，除了开始字符以外，<code>IdentifierName</code>中还可以使用 Unicode 中的连接标记、数字、以及连接符号。<p></p><p>  <code>IdentifierName</code>的任意字符可以使用JavaScript 的 Unicode 转义写法，使用 Unicode转义写法时，没有任何字符限制。</p><p>  <code>IdentifierName</code>可以是<code>Identifier</code>、<code>NullLiteral</code><code>BooleanLiteral</code>或者<code>keyword</code>，在<code>ObjectLiteral</code>中，<code>IdentifierName</code>还可以被直接当做属性名称使用。</p><p>  仅当不是保留字的时候，<code>IdentifierName</code>会被解析为<code>Identifier</code>。</p><p>  注意<code>&lt;ZWNJ&gt;</code>和<code>&lt;ZWJ&gt;</code>是ES5 新加入的两个格式控制字符，它们都是 0 宽的。</p><p>  我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有:</p>  <figure class="highlight d hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await <span class="hljs-keyword">break</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">catch</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">continue</span> debugger <span class="hljs-keyword">default</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">export</span> extends <span class="hljs-keyword">finally</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">function</span> <span class="hljs-keyword">if</span></span><br><span class="line"><span class="hljs-keyword">import</span> ininstance of <span class="hljs-keyword">new</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span> <span class="hljs-keyword">switch</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">typeof</span> var <span class="hljs-keyword">void</span> <span class="hljs-keyword">while</span> <span class="hljs-keyword">with</span> yield</span><br></pre></td></tr></table></figure><p>  除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:</p>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><br></pre></td></tr></table></figure><p>  在严格模式下, 有一些额外的为未来使用而保留的关键字:</p>  <figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implements package protected<span class="hljs-built_in"> interface </span>private public</span><br></pre></td></tr></table></figure><p>  除了这些之外，<code>NullLiteral</code>（<code>null</code>）和<code>BooleanLiteral</code>（<code>true false</code>）也是保留字，不能用于<code>Identifier</code>。</p><h3>符号 Punctuator</h3>因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为DivPunctuator，因为前面提到的字符串模板问题，<code>}</code>也被独立拆分。加在一起，所有符号为：<p></p>  <figure class="highlight gherkin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; ( ) [ ] . ... ; , <span class="hljs-variable">&lt;&gt;</span></span><br><span class="line"><span class="hljs-variable">&lt;=&gt;</span>= == != === !== + - <span class="hljs-symbol">*</span> % <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> ++ -- <span class="hljs-variable">&lt;&lt;&gt;</span>&gt; &gt;&gt;&gt; &amp; |<span class="hljs-string"> ^ ! ~ &amp;&amp; </span>||<span class="hljs-string"> ? : = += -= *= %= **= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= &amp;= </span>|<span class="hljs-string">= ^= =&gt; / /= &#125;</span></span><br></pre></td></tr></table></figure><p>  </p><h3>数字直接量 NumericLiteral</h3><br>  我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。十进制的 Number可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：<p></p>  <figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">.01</span></span><br><span class="line"><span class="hljs-number">12.</span></span><br><span class="line"><span class="hljs-number">12.01</span></span><br></pre></td></tr></table></figure><p>  这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：</p>  <figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12<span class="hljs-selector-class">.toString</span>()</span><br></pre></td></tr></table></figure><p>  这时候<code>12.</code> 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：</p>  <figure class="highlight basic hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">12 </span>.toString()</span><br></pre></td></tr></table></figure><p>  数字直接量还支持科学计数法，例如：</p>  <figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0xFA</span></span><br><span class="line"><span class="hljs-number">0o73</span></span><br><span class="line"><span class="hljs-number">0b10000</span></span><br></pre></td></tr></table></figure><p>  这里 e 后面的部分，只允许使用整数。当以<code>0x</code> <code>0b</code> 或者<code>0o</code> 开头时，表示特定进制的整数：</p>  <figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0xFA</span></span><br><span class="line"><span class="hljs-number">0o73</span></span><br><span class="line"><span class="hljs-number">0b10000</span></span><br></pre></td></tr></table></figure><p>  上面这几种进制都不支持小数，也不支持科学计数法。</p><h3>字符串直接量 StringLiteral</h3>JavaScript 中的 StringLiteral 支持单引号和双引号两种写法。<p></p>  <figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">" DoubleStringCharacters "</span></span><br><span class="line">' SingleStringCharacters '</span><br></pre></td></tr></table></figure><p>  单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是<code>\</code>和所有换行符。JavaScript中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。第一种是单字符转义。</p><p>  即一个反斜杠<code>\</code>后面跟一个字符这种形式。有特别意义的字符包括有<code>SingleEscapeCharacter</code>所定义的 9 种，见下表：<img src="https://static001.geekbang.org/resource/image/02/75/022c2c77d0a3c846ad0d61b48c4e0e75.png" alt="">除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过<code>\</code>转义后都是自身。</p><p>  </p><h3>正则表达式直接量 RegularExpressionLiteral</h3><br>  正则表达式由 Body 和Flags 两部分组成，例如：<p></p>  <figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-regexp">/RegularExpressionBody/g</span></span><br></pre></td></tr></table></figure><p>  其中 Body 部分至少有一个字符，第一个字符不能是 <em>（因为 /</em>跟多行注释有词法冲突）。正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。正则表达式并非机械地见到<code>/</code>就停止，在正则表达式<code>[]</code>中的<code>/</code>就会被认为是普通字符。我们可以看一个例子：</p>  <figure class="highlight abnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[/]/.test(<span class="hljs-string">"/"</span>)<span class="hljs-comment">;</span></span><br></pre></td></tr></table></figure><p>  除了<code>\</code>、<code>/</code> 和<code>[</code> 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。用\和一个非换行符可以组成一个转义，<code>[]</code>中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。</p><p>  </p><h3>字符串模板 Template</h3><br>  从语法结构上，Template 是个整体，其中的 <code>${ }</code> 是并列关系。但是实际上，在JavaScript 词法中，包含 <code>${ }</code> 的 Template，是被拆开分析的，如：<p></p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">`a<span class="hljs-subst">$&#123;b&#125;</span>c<span class="hljs-subst">$&#123;d&#125;</span>e`</span></span><br></pre></td></tr></table></figure><p>  它在 JavaScript 中被认为是：</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">`a<span class="hljs-subst">$&#123;</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">b</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">&#125;</span>c<span class="hljs-subst">$&#123;</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">d</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">&#125;</span>e`</span></span><br></pre></td></tr></table></figure><p>  它被拆成了五个部分：<br>  <ul><br>    <li><code><code>a${&lt;/code&gt; 这个被称为模板头&lt;/li&gt;    &lt;li&gt;&lt;code&gt;}c${&lt;/code&gt; 被称为模板中段&lt;/li&gt;    &lt;li&gt;&lt;code&gt;}e</code></code> 被称为模板尾</li><br>    <li><code>b</code> 和 <code>d</code> 都是普通标识符</li><br>  </ul><br>  实际上，这里的词法分析过程已经跟语法分析深度耦合了。不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"world"</span></span><br><span class="line">f<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;a&#125;</span>!`</span>; <span class="hljs-comment">// [["Hello", "!"], world]</span></span><br></pre></td></tr></table></figure><p>  模板字符串不需要关心大多数字符的转义，但是至少 <code>${</code> 和 <code>`</code> 还是需要处理的。模板中的转义跟字符串几乎完全一样，都是使用 <code>\</code>。</p><p>  </p><h2>总结</h2><br>  今天我们一起学习 JavaScript的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。最后，留一个问题：用零宽空格和零宽连接符、零宽非连接符，写一段好玩的代码。<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;  词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue常见问题及解决方法（一）</title>
    <link href="https://jdsheng.cn/2019/07/10/vue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/07/10/vue常见问题及解决方法（一）/</id>
    <published>2019-07-10T15:40:30.935Z</published>
    <updated>2019-10-02T03:13:44.333Z</updated>
    
    <content type="html"><![CDATA[<ul><li>列表进入详情页的传参问题</li><li>路由懒加载（也叫延迟加载）<a id="more"></a></li></ul><h2 id="列表进入详情页的传参问题"><a href="#列表进入详情页的传参问题" class="headerlink" title="列表进入详情页的传参问题"></a>列表进入详情页的传参问题</h2><p><em>关联知识点</em>  ——<strong>路由跳转的方式</strong><br>声明式的跳转：</p><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml">// query通过path切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;path: 'Detail', query: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">// params通过name切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;name: 'Detail', params: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>编程式的跳转：</p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//跳转到上一次浏览的页面</span></span><br><span class="line"> <span class="hljs-keyword">this</span>.$router.go(<span class="hljs-number">-1</span>)</span><br><span class="line">           </span><br><span class="line"><span class="hljs-comment">//指定跳转的地址，我们自己设置的路由地址</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$router.replace(<span class="hljs-string">'/pathname'</span>)</span><br><span class="line">           </span><br><span class="line"><span class="hljs-comment">//指定跳转路由的名字下，pathname是我们自身为路由设置的名字</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$router.replace(&#123;name:<span class="hljs-string">"pathname"</span>&#125;)</span><br><span class="line">          </span><br><span class="line"><span class="hljs-comment">//通过push进行跳转，我们自己设置的路由地址或者我们自己设置的名字</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">'/pathname'</span>)</span><br><span class="line"><span class="hljs-keyword">this</span>.$router.push(&#123;name:<span class="hljs-string">'pathname'</span>&#125;)</span><br><span class="line"><span class="hljs-keyword">this</span>.$router.push(&#123; path: <span class="hljs-string">'/pathname/$&#123;id&#125;'</span>&#125;) <span class="hljs-comment">//id为参数</span></span><br></pre></td></tr></table></figure><p><strong>传参的方式</strong>：query、params+动态路由传参</p><p><strong>两者的区别：</strong></p><ol><li><p>query通过<code>path</code>切换路由，params通过<code>name</code>切换路由</p><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml">// query通过path切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;path: 'Detail', query: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">// params通过name切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;name: 'Detail', params: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>query通过<code>this.$route.query</code>来接收参数，params通过<code>this.$route.params</code>来接收参数。</p><figure class="highlight objectivec hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// query通过this.$route.query接收参数</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">id</span> = <span class="hljs-keyword">this</span>.$route.query.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// params通过this.$route.params来接收参数</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">id</span> = <span class="hljs-keyword">this</span>.$route.params.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>query传参的url展现方式：<code>/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数</code><br>  params＋动态路由的url方式：<code>/detail/123</code></p></li><li><p>params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面，而query传参则不用：</p><p><em>对应的路由配置：</em></p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;      </span><br><span class="line">    <span class="hljs-attribute">path</span>: <span class="hljs-string">'/detail/:id'</span>,      </span><br><span class="line">    name: <span class="hljs-string">'Detail'</span>,      </span><br><span class="line">    component: Detail    </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><pre><code>  注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：<figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 定义的路由中，只定义一个id参数</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="hljs-string">'detail/:id'</span>,</span><br><span class="line">    name: <span class="hljs-string">'Detail'</span>,</span><br><span class="line">    components: Detail</span><br><span class="line">&#125;      </span><br><span class="line"><span class="hljs-comment">// template中的路由传参，</span></span><br><span class="line"><span class="hljs-comment">// 传了一个id参数和一个token参数</span></span><br><span class="line"><span class="hljs-comment">// id是在路由中已经定义的参数，而token没有定义</span></span><br><span class="line">&lt;router-link :to=<span class="hljs-string">"&#123;name: 'Detail', params: &#123; id: 1, token: '123456' &#125;&#125;"</span>&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class="line"><span class="hljs-comment">// 在详情页接收</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="hljs-comment">// 以下都可以正常获取到</span></span><br><span class="line">    <span class="hljs-comment">// 但是页面刷新后，id依然可以获取，而token此时就不存在了</span></span><br><span class="line">    <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">this</span>.$route.<span class="hljs-keyword">params</span>.id;</span><br><span class="line">    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">this</span>.$route.<span class="hljs-keyword">params</span>.token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>参考：</p><ol><li><a href="https://segmentfault.com/a/1190000012393587" target="_blank" rel="noopener">vue路由传参的三种基本方式</a></li><li><a href="https://blog.csdn.net/gqzydh/article/details/81453990" target="_blank" rel="noopener">vue 关于路由跳转方法</a></li></ol><h2 id="路由懒加载（也叫延迟加载）"><a href="#路由懒加载（也叫延迟加载）" class="headerlink" title="路由懒加载（也叫延迟加载）"></a>路由懒加载（也叫延迟加载）</h2><p>路由懒加载可以帮我们在进入首屏时不用加载过度的资源，从而减少首屏加载速度。在路由文件中，</p><p>非懒加载写法：</p><figure class="highlight coffeescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Index <span class="hljs-keyword">from</span> <span class="hljs-string">'@/page/index/index'</span>;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  </span><br><span class="line">    routes: [    </span><br><span class="line">        &#123; </span><br><span class="line">            path: <span class="hljs-string">'/'</span>, </span><br><span class="line">            name: <span class="hljs-string">'Index'</span>,     </span><br><span class="line">            component: Index </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由懒加载写法：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Router</span>(&#123;</span><br><span class="line">  <span class="hljs-attribute">routes</span>: [    </span><br><span class="line">        &#123; </span><br><span class="line">            path: <span class="hljs-string">'/'</span>, </span><br><span class="line">            name: <span class="hljs-string">'Index'</span>, </span><br><span class="line">            component: resolve =&gt; <span class="hljs-built_in">require</span>([<span class="hljs-string">'@/view/index/index'</span>], resolve) </span><br><span class="line">        &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;列表进入详情页的传参问题&lt;/li&gt;
&lt;li&gt;路由懒加载（也叫延迟加载）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="VUE" scheme="https://jdsheng.cn/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象：你知道全部的对象分类吗？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%85%A8%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E5%90%97%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript对象：你知道全部的对象分类吗？/</id>
    <published>2019-03-25T13:23:21.397Z</published>
    <updated>2019-09-30T16:28:42.926Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><p>前面讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。</p><p>比如说，<a id="more"></a>我们不论怎样编写代码，都没法绕开 Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的 length 属性。</p><p>并且，在浏览器环境中，我们也无法单纯依靠 JavaScript 代码实现 div 对象，只能靠 document.createElement 来创建。这也说明了 JavaScript 的对象机制并非简单的属性集合 + 原型。</p><p>我们日常工作中，接触到的主要 API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的 API 的一些特性。</p><br><br><h2>JavaScript 中的对象分类</h2><p>我们可以把对象分成几类。</p><ul><br><li><br><p>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</p><br></li><br><li><br><p>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。</p><br><ul><br><li>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</li><br><li>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li><br><li>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li><br></ul><br></li><br></ul><!-- [[[read_end]]] --><p>下面我会为你一一讲解普通对象之外的对象类型。</p><h3>宿主对象</h3><p>首先我们来看看宿主对象。</p><p>JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。</p><p>在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。</p><p>实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。</p><p>JavaScript 标准中规定了全局对象属性，w3c 的各种标准中规定了 Window 对象的其它属性。</p><p>宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 dom 对象。</p><p>宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素，这些我们会在浏览器的 API 部分详细讲解。</p><h2>内置对象·固有对象</h2><p>我们在前面说过，固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p><p>固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。</p><p>ECMA 标准为我们提供了一份固有对象表，里面含有 150+ 个固有对象。你可以通过<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects" target="_blank" rel="noopener">这个链接</a>查看。</p><p>但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部 JavaScript 固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。</p><h2>内置对象·原生对象</h2><p>我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。</p><p><img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" alt=""></p><p>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。<br><br>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。</p><p>这些构造器创建的对象多数使用了私有字段, 例如：</p><ul><br><li>Error: [[ErrorData]]</li><br><li>Boolean: [[BooleanData]]</li><br><li>Number: [[NumberData]]</li><br><li>Date: [[DateValue]]</li><br><li>RegExp: [[RegExpMatcher]]</li><br><li>Symbol: [[SymbolData]]</li><br><li>Map: [[MapData]]</li><br></ul><p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。</p><h2>用对象来模拟函数与构造器：函数对象与构造器对象</h2><p>我在前面介绍了对象的一般分类，在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。</p><p>事实上，JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。</p><p>函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。</p><p>JavaScript 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有 [[call]] 私有字段的对象”，就可以被 JavaScript 函数调用语法支持。</p><blockquote><br><p><span class="reference">[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。</span></p><br></blockquote><p>我们可以这样说，任何对象只需要实现 [[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 [[construct]]，它就是一个构造器对象，可以作为构造器被调用。</p><p>对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如 Symbol 函数）可以模拟函数和构造器。</p><p>当然了，用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。</p><p>对于宿主和内置对象来说，它们实现 [[call]]（作为函数被调用）和 [[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：</p><br><br><figure class="highlight gauss hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>); <span class="hljs-comment">// 1</span></span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Date</span>())</span><br></pre></td></tr></table></figure><br><br><p>而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。</p><br><br><figure class="highlight sqf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="hljs-built_in">log</span>(new <span class="hljs-built_in">Image</span>); </span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Image</span>());<span class="hljs-comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><br><br><p>再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。</p><p>值得一提的是，在 ES6 之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-number">0</span>) <span class="hljs-comment">// error</span></span><br></pre></td></tr></table></figure><br><br><p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]] 和 [[construct]] 行为总是相似的，它们执行同一段代码。</p><p>我们看一下示例。</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> v = f(); <span class="hljs-comment">// 把 f 作为函数调用</span></span><br><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> f(); <span class="hljs-comment">// 把 f 作为构造器调用</span></span><br></pre></td></tr></table></figure><br><br><p>我们大致可以认为，它们 [[construct]] 的执行过程如下：</p><ul><br><li>以 Object.protoype 为原型创建一个新对象；</li><br><li>以新对象为 this，执行函数的 [[call]]；</li><br><li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li><br></ul><p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cls</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">100</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        getValue:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> cls;</span><br><span class="line">o.getValue(); <span class="hljs-comment">//100</span></span><br><span class="line"><span class="hljs-comment">//a 在外面永远无法访问到</span></span><br></pre></td></tr></table></figure><br><br><h2>特殊行为的对象</h2><p>除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。</p><ul><br><li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li><br><li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li><br><li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li><br><li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li><br><li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><br><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><br><li>bind 后的 function：跟原来的函数相关联。</li><br></ul><h2>总结</h2><p>在这篇文章中，我们介绍了一些不那么常规的对象，并且我还介绍了 JavaScript 中用对象来模拟函数和构造器的机制。</p><p>这是一些不那么有规律、不那么优雅的知识，而 JavaScript 正是通过这些对象，提供了很多基础的能力。</p><p>我们这次课程留给大家一个挑战任务：不使用 new 运算符，尽可能找到获得对象的方法。</p><p>例子：</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><br><br><p>请大家把自己的答案留言给我，我们来比比看谁找到的多。</p><h2>小实验：获取全部 JavaScript 固有对象</h2><p>我们从 JavaScript 标准中可以找到全部的 JS 对象定义。JS 语言规定了全局对象的属性。</p><p>三个值：<br><br>Infinity、NaN、undefined。</p><p>九个函数：</p><ul><br><li>eval</li><br><li>isFinite</li><br><li>isNaN</li><br><li>parseFloat</li><br><li>parseInt</li><br><li>decodeURI</li><br><li>decodeURIComponent</li><br><li>encodeURI</li><br><li>encodeURIComponent</li><br></ul><p>一些构造器：<br><br>Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeapSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError<br><br>URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。</p><p>四个用于当作命名空间的对象：</p><ul><br><li>Atomics</li><br><li>JSON</li><br><li>Math</li><br><li>Reflect</li><br></ul><p>我们使用广度优先搜索，查找这些对象所有的属性和 Getter/Setter，就可以获得 JavaScript 中所有的固有对象。</p><p>请你试着先不看我的代码，在自己的浏览器中计算出来 JavaScript 有多少固有对象。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line"><span class="hljs-keyword">var</span> objects = [</span><br><span class="line">    <span class="hljs-built_in">eval</span>,</span><br><span class="line">    <span class="hljs-built_in">isFinite</span>,</span><br><span class="line">    <span class="hljs-built_in">isNaN</span>,</span><br><span class="line">    <span class="hljs-built_in">parseFloat</span>,</span><br><span class="line">    <span class="hljs-built_in">parseInt</span>,</span><br><span class="line">    <span class="hljs-built_in">decodeURI</span>,</span><br><span class="line">    <span class="hljs-built_in">decodeURIComponent</span>,</span><br><span class="line">    <span class="hljs-built_in">encodeURI</span>,</span><br><span class="line">    <span class="hljs-built_in">encodeURIComponent</span>,</span><br><span class="line">    <span class="hljs-built_in">Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Date</span>,</span><br><span class="line">    <span class="hljs-built_in">RegExp</span>,</span><br><span class="line">    <span class="hljs-built_in">Promise</span>,</span><br><span class="line">    <span class="hljs-built_in">Proxy</span>,</span><br><span class="line">    <span class="hljs-built_in">Map</span>,</span><br><span class="line">    <span class="hljs-built_in">WeakMap</span>,</span><br><span class="line">    <span class="hljs-built_in">Set</span>,</span><br><span class="line">    <span class="hljs-built_in">WeakSet</span>,</span><br><span class="line">    <span class="hljs-built_in">Function</span>,</span><br><span class="line">    <span class="hljs-built_in">Boolean</span>,</span><br><span class="line">    <span class="hljs-built_in">String</span>,</span><br><span class="line">    <span class="hljs-built_in">Number</span>,</span><br><span class="line">    <span class="hljs-built_in">Symbol</span>,</span><br><span class="line">    <span class="hljs-built_in">Object</span>,</span><br><span class="line">    <span class="hljs-built_in">Error</span>,</span><br><span class="line">    <span class="hljs-built_in">EvalError</span>,</span><br><span class="line">    <span class="hljs-built_in">RangeError</span>,</span><br><span class="line">    <span class="hljs-built_in">ReferenceError</span>,</span><br><span class="line">    <span class="hljs-built_in">SyntaxError</span>,</span><br><span class="line">    <span class="hljs-built_in">TypeError</span>,</span><br><span class="line">    <span class="hljs-built_in">URIError</span>,</span><br><span class="line">    <span class="hljs-built_in">ArrayBuffer</span>,</span><br><span class="line">    SharedArrayBuffer,</span><br><span class="line">    <span class="hljs-built_in">DataView</span>,</span><br><span class="line">    <span class="hljs-built_in">Float32Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Float64Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Int8Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Int16Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Int32Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint8Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint16Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint32Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint8ClampedArray</span>,</span><br><span class="line">    Atomics,</span><br><span class="line">    <span class="hljs-built_in">JSON</span>,</span><br><span class="line">    <span class="hljs-built_in">Math</span>,</span><br><span class="line">    <span class="hljs-built_in">Reflect</span>];</span><br><span class="line">objects.forEach(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> set.add(o));</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> o = objects[i]</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(o)) &#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(o, p)</span><br><span class="line">        <span class="hljs-keyword">if</span>( (d.value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> d.value === <span class="hljs-string">"object"</span>) || (<span class="hljs-keyword">typeof</span> d.value === <span class="hljs-string">"function"</span>))</span><br><span class="line">            <span class="hljs-keyword">if</span>(!set.has(d.value))</span><br><span class="line">                set.add(d.value), objects.push(d.value);</span><br><span class="line">        <span class="hljs-keyword">if</span>( d.get )</span><br><span class="line">            <span class="hljs-keyword">if</span>(!set.has(d.get))</span><br><span class="line">                set.add(d.get), objects.push(d.get);</span><br><span class="line">        <span class="hljs-keyword">if</span>( d.set )</span><br><span class="line">            <span class="hljs-keyword">if</span>(!set.has(d.set))</span><br><span class="line">                set.add(d.set), objects.push(d.set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;p&gt;前面讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。&lt;/p&gt;&lt;p&gt;比如说，&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象：我们真的需要模拟类吗？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%A8%A1%E6%8B%9F%E7%B1%BB%E5%90%97%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript对象：我们真的需要模拟类吗？/</id>
    <published>2019-03-25T13:04:29.033Z</published>
    <updated>2019-10-02T03:33:23.500Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。</p><br>  <p>在上一篇文章我们已经讲到，JavaScript <a id="more"></a>本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。</p><br><br>  <p>那么，随着我们理解的思路继续深入，这些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。</p><br>  <p>尽管我认为，“类”并非面向对象的全部，但我们不应该责备社区出现这样的方案，事实上，因为一些公司的政治原因，JavaScript 推出之时，管理层就要求它去模仿 Java。</p><br><br>  <p>所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来语法更像 Java”，而 Java 正是基于类的面向对象的代表语言之一。</p><br>  <p>但是 JavaScript 这样的半吊子模拟，缺少了继承等关键特性，导致大家试图对它进行修补，进而产生了种种互不相容的解决方案。</p><br>  <p>庆幸的是，从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。</p><br><br>  <p>实际上，我认为“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。</p><br>  <p>我们从头讲起。</p><br>  <h2>什么是原型？</h2><br>  <p>原型是顺应人类自然思维的产物。中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。</p><br>  <p>我们在上一节讲解面向对象的时候提到了：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。</p><br>  <p>最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。</p><br>  <p>还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。</p><br>  <p>“基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。</p><br>  <p>与此相对，“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p><br>  <p>基于原型的面向对象系统通过“复制”的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。</p><br>  <p>基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。</p><br>  <p><br>    这就像专业人士可能喜欢在看到老虎的时候，喜欢用猫科豹属豹亚种来描述它，但是对一些不那么正式的场合，“大猫”可能更为接近直观的感受一些（插播一个冷知识：比起老虎来，美洲狮在历史上相当长时间都被划分为猫科猫属，所以性格也跟猫更相似，比较亲人）。<br>  </p><br>  <p>我们的 JavaScript 并非第一个使用原型的语言，在它之前，self、kevo 等语言已经开始使用原型来描述对象了。</p><br>  <p>事实上，Brendan 更是曾透露过，他最初的构想是一个拥有基于原型的面向对象能力的 scheme 语言（但是函数式的部分是另外的故事，这篇文章里，我暂时不做详细讲述）。</p><br>  <p>在 JavaScript 之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，我想，这应该是 Brendan 选择原型系统很重要的理由。</p><br>  <p>原型系统的“复制操作”有两种实现思路：</p><br>  <ul><br>    <li><br>      <p>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；</p><br>    </li><br>    <li><br>      <p>另一个是切实地复制对象，从此两个对象再无关联。</p><br>    </li><br>  </ul><br>  <p>历史上的基于原型语言因此产生了两个流派，显然，JavaScript 显然选择了前一种方式。</p><br>  <h2>JavaScript 的原型</h2><br>  <p>如果我们抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，我可以用两条概括：</p><br>  <ul><br>    <li>如果所有对象都有私有字段 [[prototype]]，就是对象的原型；</li><br>    <li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li><br>  </ul><br>  <p>这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为：</p><br>  <ul><br>    <li>Object.create 根据指定的原型创建新对象，原型可以是 null；</li><br>    <li>Object.getPrototypeOf 获得一个对象的原型；</li><br>    <li>Object.setPrototypeOf 设置一个对象的原型。</li><br>  </ul><br>  <p>利用这三个方法，我们可以完全抛开类的思维，利用原型来实现抽象和复用。我用下面的代码展示了用原型来抽象猫和虎的例子。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> cat = &#123;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"meow~"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    jump()&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"jump"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> tiger = <span class="hljs-built_in">Object</span>.create(cat,  &#123;</span><br><span class="line">    say:&#123;</span><br><span class="line">        writable:<span class="hljs-literal">true</span>,</span><br><span class="line">        configurable:<span class="hljs-literal">true</span>,</span><br><span class="line">        enumerable:<span class="hljs-literal">true</span>,</span><br><span class="line">        value:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"roar!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> anotherCat = <span class="hljs-built_in">Object</span>.create(cat);</span><br><span class="line"></span><br><span class="line">anotherCat.say();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> anotherTiger = <span class="hljs-built_in">Object</span>.create(tiger);</span><br><span class="line"></span><br><span class="line">anotherTiger.say();</span><br></pre></td></tr></table></figure><br><br><p>这段代码创建了一个“猫”对象，又根据猫做了一些修改创建了虎，之后我们完全可以用 Object.create 来创建另外的猫和虎对象，我们可以通过“原始猫对象”和“原始虎对象”来控制所有猫和虎的行为。</p><p>但是，在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，可以说非常别扭。</p><p>考虑到 new 和 prototype 属性等基础设施今天仍然有效，而且被很多代码使用，学习这些知识也有助于我们理解运行时的原型工作原理，下面我们试着回到过去，追溯一下早年的 JavaScript 中的原型和类。</p><h2>早期版本中的类与原型</h2><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。</p><p>以下代码展示了所有具有内置 class 属性的对象：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> arg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span> &#125;();</span><br><span class="line"><span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log([o, n, s, b, d, arg, r, f, arr, e].map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(v)));</span><br></pre></td></tr></table></figure><br><br><p>因此，在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。</p><p>在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123; [<span class="hljs-built_in">Symbol</span>.toStringTag]: <span class="hljs-string">"MyObject"</span> &#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(o + <span class="hljs-string">""</span>);</span><br></pre></td></tr></table></figure><br><br><p>这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响。</p><p>但是，考虑到 JavaScript 语法中跟 Java 相似的部分，我们对类的讨论不能用“new 运算是针对构造器对象，而不是类”来试图回避。</p><p>所以，我们仍然要把 new 理解成 JavaScript 面向对象的一部分，下面我就来讲一下 new 操作具体做了哪些事情。</p><p>new 运算接受一个构造器和一组调用参数，实际上做了几件事：</p><ul><br><li>以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；</li><br><li>将 this 和调用参数传给构造器，执行；</li><br><li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li><br></ul><p>new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。</p><p>下面代码展示了用构造器模拟类的两种方法:</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c1</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.p1 = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">this</span>.p2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.p1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> c1;</span><br><span class="line">o1.p2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c2</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">c2.prototype.p1 = <span class="hljs-number">1</span>;</span><br><span class="line">c2.prototype.p2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> c2;</span><br><span class="line">o2.p2();</span><br></pre></td></tr></table></figure><br><br><p>第一种方法是直接在构造器中修改 this，给 this 添加属性。</p><p>第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。</p><p>没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法（当时的 mozilla 提供了私有属性 <strong>proto</strong>，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 pollyfill，见以下代码：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prototype</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> cls = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;</span><br><span class="line">    cls.prototype = prototype;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>这段代码创建了一个空函数作为类，并把传入的原型挂在了它的 prototype，最后创建了一个它的实例，根据 new 的行为，这将产生一个以传入的第一个参数为原型的对象。</p><p>这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型，所以放到今天意义已经不大了。</p><h2>ES6 中的类</h2><p>好在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。下面我们就来看一下 ES6 中的类。</p><p>ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。</p><p>我们先看下类的基本写法：</p><br><br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.height = height;</span><br><span class="line">    <span class="hljs-keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// Getter</span></span><br><span class="line">  <span class="hljs-keyword">get</span> area() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calcArea();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// Method</span></span><br><span class="line">  calcArea() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>在现有的类语法中，getter/setter 和 method 是兼容性最好的。</p><p>我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。</p><p>类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。</p><p>此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123; </span><br><span class="line">  <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">' makes a noise.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">' barks.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">'Mitzie'</span>);</span><br><span class="line">d.speak(); <span class="hljs-comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure><br><br><p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。</p><p>比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。</p><p>所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p><p>一些激进的观点认为，class 关键字和箭头运算符可以完全替代旧的 function 关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。</p><h2>总结</h2><p>在新的 ES 版本中，我们不再需要模拟类了：我们有了光明正大的新语法。而原型体系同时作为一种编程范式和运行时机制存在。</p><p>我们可以自由选择原型或者类作为代码的抽象风格，但是无论我们选择哪种，理解运行时的原型系统都是很有必要的一件事。</p><p>在你的工作中，是使用 class 还是仍然在用 function 来定义“类”？为什么这么做？如何把使用 function 定义类的代码改造到 class 的新语法？</p><p>欢迎给我留言，我们一起讨论。</p><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。&lt;/p&gt;&lt;br&gt;  &lt;p&gt;在上一篇文章我们已经讲到，JavaScript&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象：面向对象还是基于对象？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript对象：面向对象还是基于对象？/</id>
    <published>2019-03-25T12:57:08.716Z</published>
    <updated>2019-10-02T03:33:33.473Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。<a id="more"></a><br>  一些新人在学习 JavaScript 面向对象时，往往也会有疑惑：<br>  <ul><br>    <li>为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢；</li><br>    <li>为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢？</li><br>  </ul><br><br>  甚至，在一些争论中，有人强调：JavaScript 并非“面向对象的语言”，而是“基于对象的语言”。这个说法一度流传甚广，而事实上，我至今遇到的持有这一说法的人中，无一能够回答“如何定义面向对象和基于对象”这个问题。<br><br>  实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。<br><br>  我们可以先看看 JavaScript 标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”。<br><br>  这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。<br><br>  那么，在本篇文章中，我会尝试让你去理解面向对象和 JavaScript 中的面向对象究竟是什么。<br><br>  <h2>什么是面向对象？</h2><br>  我们先来说说什么是对象，因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。<br><br>  中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。<br><br>  但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。<br><br>  那么，我们先来看看在人类思维模式下，对象究竟是什么。<br><br>  <blockquote><br>    <span class="reference">对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。</span><br>    <span class="reference">在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。</span><br>  </blockquote><br><br>  在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：<br>  <ol><br>    <li>一个可以触摸或者可以看见的东西；</li><br>    <li>人的智力可以理解的东西；</li><br>    <li>可以指导思考或行动（进行想象或施加动作）的东西。</li><br>  </ol><br>  有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。<br><br>  而 JavaScript 早年却选择了一个更为冷门的方式：原型（关于原型，我在下一篇文章会重点介绍，这里你留个印象就可以了）。这是我在前面说它不合群的原因之一。<br><br>  然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this等语言特性，使之“看起来更像 Java”。<br><br>  在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把 JavaScript 变得更像是基于类的编程，进而产生了很多所谓的“框架”，比如 PrototypeJS、Dojo。<br><br>  事实上，它们成为了某种 JavaScript 的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。<br>  如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。<br><br>  不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。<br><br>  首先我们来了解一下 JavaScript 是如何设计对象模型的。<br><br>  <h2>JavaScript 对象的特征</h2><br>  在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。<br>  <ul><br>    <li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><br>    <li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li><br>    <li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li><br>  </ul><br>  我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。<br><br>  所以，JavaScript 程序员都知道，任何不同的 JavaScript 对象其实是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一模一样的对象，但是打印出来的结果却是 false。<br><br><figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o1 = <span class="hljs-comment">&#123; a: 1 &#125;</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> o2 = <span class="hljs-comment">&#123; a: 1 &#125;</span>;</span><br><span class="line">console.log(o1 == o2); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><br><br>关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“成员变量”和“成员函数”，Java 中则称它们为“属性”和“方法”。在 JavaScript 中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。<br><br><figure class="highlight roboconf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; </span><br><span class="line">    <span class="hljs-attribute">d</span>: 1,</span><br><span class="line">    f() &#123;</span><br><span class="line">        console<span class="hljs-variable">.log</span>(this<span class="hljs-variable">.d</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性。如果你用过 Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。<strong>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong>我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。<br><br><figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-comment">&#123; a: 1 &#125;</span>;</span><br><span class="line">o.b = <span class="hljs-number">2</span>;</span><br><span class="line">console.log(o.a, o.b); <span class="hljs-comment">//1 2</span></span><br></pre></td></tr></table></figure><br><br>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。<h2>JavaScript 对象的两类属性</h2>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。<br><ul><br>  <li>value：就是属性的值。</li><br>  <li>writable：决定属性能否被赋值。</li><br>  <li>enumerable：决定 for in 能否枚举该属性。</li><br>  <li>configurable：决定该属性能否被删除或者改变特征值。</li><br></ul>在大多数情况下，我们只关心数据属性的值即可。<br>第二类属性是访问器（getter/setter）属性，它也有四个特征。<ul><br>  <li>getter：函数或 undefined，在取属性值时被调用。</li><br>  <li>setter：函数或 undefined，在设置属性值时被调用。</li><br>  <li>enumerable：决定 for in 能否枚举该属性。</li><br>  <li>configurable：决定该属性能否被删除或者改变特征值。</li><br></ul><br>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：<br><br><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">var</span> <span class="hljs-string">o</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;;</span></span><br><span class="line"><span class="hljs-string">o.b</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span></span><br><span class="line"><span class="hljs-string">//a</span> <span class="hljs-string">和</span> <span class="hljs-string">b</span> <span class="hljs-string">皆为数据属性</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"a")</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"b")</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br></pre></td></tr></table></figure><br><br>我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：<br><br><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">var</span> <span class="hljs-string">o</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;;</span></span><br><span class="line"><span class="hljs-string">Object.defineProperty(o,</span> <span class="hljs-string">"b"</span><span class="hljs-string">,</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;);</span></span><br><span class="line"><span class="hljs-string">//a</span> <span class="hljs-string">和</span> <span class="hljs-string">b</span> <span class="hljs-string">都是数据属性，但特征值变化了</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"a");</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"b");</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">o.b</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span></span><br><span class="line"><span class="hljs-string">console.log(o.b);</span> <span class="hljs-string">//</span> <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><br><br>这里我们使用了 Object.defineProperty 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示：<br><br><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.a); <span class="hljs-comment">// 1</span></span><br></pre></td></tr></table></figure><br><br>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。<br><br>这样，我们就理解了，实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。<br><br>对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下“a”是 key。<br><br><code class="ps">{writable:true,value:1,configurable:true,enumerable:true}<div class="ps__rail-x" style="left: 0px; bottom: 0px;"><br>      <div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div><br>    </div><br>    <div class="ps__rail-y" style="top: 0px; right: 0px;"><br>      <div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div><br>    </div><br></code>是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。<br><br>讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。<br><br>你甚至可以理解为什么会有“JavaScript 不是面向对象”这样的说法了。这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。<br><br>可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍 JavaScript中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。<br><br>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。<br><br>所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。<br><br><h2>结语</h2><br>要想理解 JavaScript 对象，必须清空我们脑子里“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解 JavaScript 面向对象设计的思路。<br><br>在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了 JavaScript 对象的设计思路。接下来又从运行时的角度，介绍了 JavaScript 对象的具体设计：具有高度动态性的属性集合。<br><br>很多人在思考 JavaScript 对象时，会带着已有的“对象”观来看问题，最后的结果当然就是“剪不断理还乱”了。<br><br>在后面的文章中，我会继续带你探索 JavaScript 对象的一些机制，看 JavaScript 如何基于这样的动态对象模型设计自己的原型系统，以及你熟悉的函数、类等基础设施。<br><br>转自—《重学前端》<br></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类型：关于类型，有哪些你不知道的细节？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%BB%86%E8%8A%82%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript类型：关于类型，有哪些你不知道的细节？/</id>
    <published>2019-03-25T12:48:32.377Z</published>
    <updated>2019-10-02T03:33:49.706Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>这次我们来讲讲 JavaScript 的内容，在这个部分，我首先想跟你聊一聊类型。</p><a id="more"></a><br>  <p>JavaScript 类型对每个前端程序员来说，几乎都是最为熟悉的概念了。但是你真的很了解它们吗？我们不妨来看看下面的几个问题。</p><br><br>  <ul><br>    <li>为什么有的编程规范要求用 void 0 代替 undefined？</li><br>    <li>字符串有最大长度吗？</li><br>    <li>0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？</li><br>    <li>ES6 新加入的 Symbol 是个什么东西？</li><br>    <li>为什么给对象添加的方法能用在基本类型上？</li><br>  </ul><br><br>  <p>如果你答起来还有些犹豫的地方，这就说明你对这部分知识点，还是有些遗漏之处的。没关系，今天我来帮你一一补上。</p><br>  <p>我在前面提到过，我们的 JavaScript 模块会从运行时、文法和执行过程三个角度去剖析 JS 的知识体系，本篇我们就从运行时的角度去看 JavaScript 的类型系统。</p><br>  <blockquote><br>    <p><span class="reference">运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript<br>        代码运行过程中产生的数据，都具有运行时类型</span>。</p><br>  </blockquote><br>  <h2>类型</h2><br>  <p>JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：</p><br>  <ol><br>    <li>Undefined；</li><br>    <li>Null；</li><br>    <li>Boolean；</li><br>    <li>String；</li><br>    <li>Number；</li><br>    <li>Symbol；</li><br>    <li>Object。</li><br>  </ol><br>  <p>除了 ES6 中新加入的 Symbol 类型，剩下 6 种类型都是我们日常开发中的老朋友了，但是，要想回答文章一开始的问题，我们需要重新认识一下这些老朋友，下面我们就来从简单到复杂，重新学习一下这些类型。</p><br>  <h2>Undefined、Null</h2><br>  <p>我们的第一个问题，为什么有的编程规范要求用 void 0 代替 undefined？现在我们就分别来看一下。</p><br>  <p>Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined<br>    的这个变量）来表达这个值，或者 void 运算来把任一一个表达式变成 undefined 值。</p><br>  <p>但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取<br>    undefined 值。</p><br>  <p>Undefined 跟 null 有一定的表意差别，null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined<br>    的变量，都是从未赋值的自然状态。</p><br>  <p>Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</p><br>  <h2>Boolean</h2><br>  <p>Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。这个类型很简单，我就不做过多介绍了。</p><br>  <h2>String</h2><br>  <p>我们来看看字符串是否有最大长度。</p><br>  <p>String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。</p><br>  <p>因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16<br>    编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p><br>  <blockquote><br>    <p><span class="reference">Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是<br>        Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 -<br>        U+FFFF）的码点被称为基本字符区域（BMP）。</span></p><br>  </blockquote><br>  <p>JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。</p><br>  <p>JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。</p><br>  <p>JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。</p><br>  <h2>Number</h2><br>  <p>下面，我们来说说 Number 类型。Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。</p><br>  <p>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。</p><br>  <p>JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0<br>    出错，而引入了无穷大的概念），规定了几个例外情况：</p><br>  <ul><br>    <li>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；</li><br>    <li>Infinity，无穷大；</li><br>    <li>-Infinity，负无穷大。</li><br>  </ul><br>  <p>另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测<br>    1/x 是 Infinity 还是 -Infinity。</p><br>  <p>根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。</p><br>  <p>同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：</p><br><br><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>);</span><br></pre></td></tr></table></figure><br><br><p>这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。</p><p>所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：</p><br><br><figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="hljs-built_in">log</span>( Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> - <span class="hljs-number">0.3</span>) &lt;= <span class="hljs-keyword">Number</span>.<span class="hljs-built_in">EPSILON</span>);</span><br></pre></td></tr></table></figure><br><br><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。</p><h2>Symbol</h2><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。</p><p>在后面的文章中，我会详细叙述 Symbol 跟对象系统。这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。</p><p>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。</p><p>我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：</p><br><br><figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> mySymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"my symbol"</span>);</span><br></pre></td></tr></table></figure><br><br><p>一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span></span><br><span class="line"></span><br><span class="line">o[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> v = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        next: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: v++, <span class="hljs-attr">done</span>: v &gt; <span class="hljs-number">10</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> o) </span><br><span class="line">    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 0 1 2 3 ... 9</span></span><br></pre></td></tr></table></figure><br><br><p>代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。</p><p>这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。</p><p>这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。</p><h2>Object</h2><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。</p><p>下面我们来看一看，为什么给对象添加的方法能用在基本类型上？</p><p>在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><p>关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。</p><p>提到对象，我们必须要提到一个概念：类。</p><p>因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。</p><p>事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。</p><p>JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p><ul><br><li>Number；</li><br><li>String；</li><br><li>Boolean；</li><br><li>Symbol。</li><br></ul><p>所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。</p><p>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。</p><p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p><p>JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：</p><br><br><figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-string">"abc"</span>.charAt(<span class="hljs-number">0</span>)); <span class="hljs-comment">//a</span></span><br></pre></td></tr></table></figure><br><br><p>甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Symbol</span>.prototype.hello = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//symbol，a 并非对象</span></span><br><span class="line">a.hello(); <span class="hljs-comment">//hello，有效</span></span><br></pre></td></tr></table></figure><br><br><p>所以我们文章开头的问题，答案就是 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</p><h2>类型转换</h2><p>讲完了基本类型，我们来介绍一个现象：类型转换。</p><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。</p><p>其中最为臭名昭著的是 JS 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。</p><p>这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。</p><p>其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：</p><p><img src="https://static001.geekbang.org/resource/image/71/20/71bafbd2404dc3ffa5ccf5d0ba077720.jpg" alt=""></p><p>在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。</p><h3>StringToNumber</h3><p>字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：</p><ul><br><li>30；</li><br><li>0b111；</li><br><li>0o13；</li><br><li>0xFF。</li><br></ul><p>此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：</p><ul><br><li>1e3；</li><br><li>-1e-2。</li><br></ul><p>需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。</p><p>在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。</p><p>在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。</p><p>多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。</p><h3>NumberToString</h3><p>在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。</p><p>具体的算法，你可以去参考 JavaScript 的语言标准。由于这个部分内容，我觉得在日常开发中很少用到，所以这里我就不去详细地讲解了。</p><h3>装箱转换</h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。</p><p>前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。</p><p>我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。</p><p>我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> symbolObject = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;).call(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> symbolObject); <span class="hljs-comment">//object</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject.constructor == <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure><br><br><p>装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。</p><p>使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> symbolObject = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> symbolObject); <span class="hljs-comment">//object</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject.constructor == <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure><br><br><p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> symbolObject = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(symbolObject)); <span class="hljs-comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure><br><br><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p><p>但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p><h3>拆箱转换</h3><p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。</p><p>对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><p>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"valueOf"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toString"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o * <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-comment">// valueOf</span></span><br><span class="line"><span class="hljs-comment">// toString</span></span><br><span class="line"><span class="hljs-comment">// TypeError</span></span><br></pre></td></tr></table></figure><br><br><p>我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o<em>2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。</em></p><p>到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o2 换成 String(o)，那么你会看到调用顺序就变了。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">     valueOf : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"valueOf"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">     toString : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toString"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">String</span>(o)</span><br><span class="line"> <span class="hljs-comment">// toString</span></span><br><span class="line"> <span class="hljs-comment">// valueOf</span></span><br><span class="line"> <span class="hljs-comment">// TypeError</span></span><br></pre></td></tr></table></figure><br><br><p>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"valueOf"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toString"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[<span class="hljs-built_in">Symbol</span>.toPrimitive] = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toPrimitive"</span>); <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(o + <span class="hljs-string">""</span>)</span><br><span class="line"><span class="hljs-comment">// toPrimitive</span></span><br><span class="line"><span class="hljs-comment">// hello</span></span><br></pre></td></tr></table></figure><br><br><h2>结语</h2><p>在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。这里回顾一下今天讲解的知识点。</p><p>除了这七种语言类型，还有一些语言的实现者更关心的规范类型。</p><ul><br><li>List 和 Record： 用于描述函数传参过程。</li><br><li>Set：主要用于解释字符集等。</li><br><li>Completion Record：用于描述异常、跳出等语句执行过程。</li><br><li>Reference：用于描述对象属性访问、delete 等。</li><br><li>Property Descriptor：用于描述对象的属性。</li><br><li>Lexical Environment 和 Environment Record：用于描述变量和作用域。</li><br><li>Data Block：用于描述二进制数据。</li><br></ul><p>有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。</p><p>最后我们留一个实践问题，如果我们不用原生的 Number 和 parseInt，用 JS 代码实现 String 到 Number 的转换，该怎么做呢？请你把自己的代码留言给我吧！</p><hr><h2>补充阅读</h2><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。</p><p><img src="https://static001.geekbang.org/resource/image/ec/6b/ec4299a73fb84c732efcd360fed6e16b.png" alt=""></p><p>在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。</p><p>从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JS 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。</p><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;这次我们来讲讲 JavaScript 的内容，在这个部分，我首先想跟你聊一聊类型。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript执行（四）：try里面放return，finally还会执行吗？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Atry%E9%87%8C%E9%9D%A2%E6%94%BEreturn%EF%BC%8Cfinally%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript执行（四）：try里面放return，finally还会执行吗？/</id>
    <published>2019-03-25T12:16:18.395Z</published>
    <updated>2019-10-02T03:34:18.816Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>在前面几篇文章中，我们已经了解了关于执行上下文、作用域、闭包之间的关系。</p><br>  <p>今天，我们则要说一说更为细节的部分：语句。</p><br>  <a id="more"></a><br>  <p>语句是任何编程语言的基础结构，与 JavaScript 对象一样，JavaScript 语句同样具有“看起来很像其它语言，但是其实一点都不一样”的特点。</p><br>  <p>我们比较常见的语句包括变量声明、表达式、条件、循环等，这些都是大家非常熟悉的东西，对于它们的行为，我在这里就不赘述了。</p><br><br>  <p>为了了解 JavaScript 语句有哪些特别之处，首先我们要看一个不太常见的例子，我会通过这个例子，来向你介绍 JavaScript 语句执行机制涉及的一种基础类型：Completion 类型。</p><br>  <h2>Completion 类型</h2><br>  <p>我们来看一个例子。在函数 foo 中，使用了一组 try 语句。我们可以先来做一个小实验，在 try 中有 return 语句，finally 中的内容还会执行吗？我们来看一段代码。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span>(err) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo());</span><br></pre></td></tr></table></figure><br><br><p>通过实际试验，我们可以看到，finally 确实执行了，而且 return 语句也生效了，foo() 返回了结果 0。</p><p>虽然 return 执行了，但是函数并没有立即返回，又执行了 finally 里面的内容，这样的行为违背了很多人的直觉。</p><p>如果在这个例子中，我们在 finally 中加入 return 语句，会发生什么呢？</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125; <span class="hljs-keyword">catch</span>(err) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(foo());</span><br></pre></td></tr></table></figure><br><br><p>通过实际执行，我们看到，finally 中的 return “覆盖”了 try 中的 return。在一个函数中执行了两次 return，这已经超出了很多人的常识，也是其它语言中不会出现的一种行为。</p><br><p>面对如此怪异的行为，我们当然可以把它作为一个孤立的知识去记忆，但是实际上，这背后有一套机制在运作。</p><br><p>这一机制的基础正是 JavaScript 语句执行的完成状态，我们用一个标准类型来表示：Completion Record（我在类型一节提到过，Completion Record 用于描述异常、跳出等语句执行过程）。</p><br><p>Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p><br><ul><br>  <li>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</li><br>  <li>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</li><br>  <li>[[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。</li><br></ul><br><p>JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。接下来我们要来了解一下 JavaScript 使用 Completion Record<br>  类型，控制语句执行的过程。</p><br><p>首先我们来看看语句有几种分类。</p><br><p><img src="https://static001.geekbang.org/resource/image/98/d5/98ce53be306344c018cddd6c083392d5.jpg" alt=""></p><br><h2>普通的语句</h2><br><p>在 JavaScript 中，我们把不带控制能力的语句称为普通语句。普通语句有下面几种。</p><br><ul><br>  <li>声明类语句<br>    <ul><br>      <li>var 声明</li><br>      <li>const 声明</li><br>      <li>let 声明</li><br>      <li>函数声明</li><br>      <li>类声明</li><br>    </ul><br>  </li><br>  <li>表达式语句</li><br>  <li>空语句</li><br>  <li>debugger 语句</li><br></ul><br><p>这些语句在执行时，从前到后顺次执行（我们这里先忽略 var 和函数声明的预处理机制），没有任何分支或者重复执行逻辑。</p><br><p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。</p><br><p>这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。</p><br><p>如果你经常使用 chrome 自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上 var，就变成了 undefined。</p><br><p><img src="https://static001.geekbang.org/resource/image/a3/67/a35801b1b82654d17e413e51b340d767.png" alt=""></p><br><p>Chrome 控制台显示的正是语句的 Completion Record 的 [[value]]。</p><br><h2>语句块</h2><br><p>介绍完了普通语句，我们再来介绍一个比较特殊的语句：语句块。</p><br><p>语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。</p><br><p>语句块本身并不复杂，我们需要注意的是语句块内部的语句的 Completion Record 的 [[type]] 如果不为 normal，会打断语句块后续的语句执行。</p><br><p>比如我们考虑，一个 [[type]] 为 return 的语句，出现在一个语句块中的情况。</p><br><p>从语句的这个 type 中，我们大概可以猜到它由哪些特定语句产生，我们就来说说最开始的例子中的 return。</p><br><p>return 语句可能产生 return 或者 throw 类型的 Completion Record。我们来看一个例子。</p><br><p>先给出一个内部为普通语句的语句块：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// normal, empty, empty</span></span><br><span class="line">  i ++; <span class="hljs-comment">// normal, 1, empty</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(i) <span class="hljs-comment">//normal, undefined, empty</span></span><br><span class="line">&#125; <span class="hljs-comment">// normal, undefined, empty</span></span><br></pre></td></tr></table></figure><br><br><p>在每一行的注释中，我给出了语句的 Completion Record。</p><p>我们看到，在一个 block 中，如果每一个语句都是 normal 类型，那么它会顺次执行。接下来我们加入 return 试试看。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// normal, empty, empty</span></span><br><span class="line">  <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// return, 1, empty</span></span><br><span class="line">  i ++; </span><br><span class="line">  <span class="hljs-built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="hljs-comment">// return, 1, empty</span></span><br></pre></td></tr></table></figure><br><br><p>但是假如我们在 block 中插入了一条 return 语句，产生了一个非 normal 记录，那么整个 block 会成为非 normal。这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。<br></p><br><p>接下来我们就具体讲讲控制类语句。</p><br><h2>控制型语句</h2><br><p>控制型语句带有 if、switch 关键字，它们会对不同类型的 Completion Record 产生反应。</p><br><p>控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try。另一类是对外部造成影响如<br>  break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。</p><br><p>一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟 break 、continue 、return 、throw<br>  四种类型与控制语句两两组合产生的效果。</p><br><p><img src="https://static001.geekbang.org/resource/image/77/d3/7760027d7ee09bdc8ec140efa9caf1d3.png" alt=""></p><br><p>通过这个表，我们不难发现知识的盲点，也就是我们最初的的 case 中的 try 和 return 的组合了。</p><br><p>因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。</p><br><p>而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。</p><br><h2>带标签的语句</h2><br><p>前文我重点讲了 type 在语句控制中的作用，接下来我们重点来讲一下最后一个字段：target，这涉及了 JavaScript 中的一个语法，带标签的语句。</p><br><p>实际上，任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firstStatement: <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure><br><br><p>大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环。</p><br><br><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">outer</span>: <span class="hljs-selector-tag">while</span>(<span class="hljs-selector-tag">true</span>) &#123;</span><br><span class="line">  <span class="hljs-attribute">inner</span>: <span class="hljs-built_in">while</span>(true) &#123;</span><br><span class="line">      break outer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>("<span class="hljs-selector-tag">finished</span>")</span><br></pre></td></tr></table></figure><br><br><p>break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它。</p><br><h2>结语</h2><br><p>我们以 Completion Record 类型为线索，为你讲解了 JavaScript 语句执行的原理。</p><br><p>因为 JavaScript 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行， 树形结构的每一个节点执行后产生 Completion Record，根据语句的结构和 Completion<br>  Record，JavaScript 实现了各种分支和跳出逻辑。</p><br><p>你遇到哪些语句中的执行的实际效果，是跟你想象的有所出入呢，你可以给我留言，我们一起讨论。</p><br><p>转自—《重学前端》</p><br></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;在前面几篇文章中，我们已经了解了关于执行上下文、作用域、闭包之间的关系。&lt;/p&gt;&lt;br&gt;  &lt;p&gt;今天，我们则要说一说更为细节的部分：语句。&lt;/p&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript执行（三）：你知道现在有多少种函数吗？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%8E%B0%E5%9C%A8%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript执行（三）：你知道现在有多少种函数吗？/</id>
    <published>2019-03-25T11:57:23.693Z</published>
    <updated>2019-10-02T03:34:32.369Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。</p><a id="more"></a><br>  <p>一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。</p><br>  <p>在 JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。</p><br>  <h2>函数</h2><br><br>  <p>在 ES2018 中，函数已经是一个很复杂的体系了，我在这里整理了一下。</p><br>  <p><strong>第一种，普通函数：用 function 关键字定义的函数。</strong></p><br>  <p>示例：</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><strong>第二种，箭头函数：用 =&gt; 运算符定义的函数。</strong><br><br>示例:</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><strong>第三种，方法：在 class 中定义的函数。</strong></p><p>示例：</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;</span><br><span class="line">    foo()&#123;</span><br><span class="line">        <span class="hljs-comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><strong>第四种，生成器函数：用 function * 定义的函数。</strong></p><p>示例：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>*(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><strong>第五种，类：用 class 定义的类，实际上也是函数。</strong></p><p>示例：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="hljs-comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p><strong>第六 / 七 / 八种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。</strong></p><p>示例：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>*(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>ES6 以来，大量加入的新语法极大地方便了我们编程的同时，也增加了很多我们理解的心智负担。要想认识这些函数的执行上下文切换，我们必须要对它们行为上的区别有所了解。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript执行（二）：闭包和执行上下文到底是怎么回事？</title>
    <link href="https://jdsheng.cn/2019/03/23/JavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/23/JavaScript执行（二）：闭包和执行上下文到底是怎么回事？/</id>
    <published>2019-03-23T01:38:38.957Z</published>
    <updated>2019-10-02T03:07:03.921Z</updated>
    
    <content type="html"><![CDATA[<div class=""><br>  <p>在上一课，我们了解了 JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据“由 JavaScript 引擎发起”还是“由宿主发起”，<a id="more"></a>分成了宏观任务和微观任务，接下来我们继续去看一看更细的执行粒度。<br>  </p><br>  <p>一段 JavaScript 代码可能会包含函数调用的相关内容，从今天开始，我们就用两节课的时间来了解一下函数的执行。</p><br><br>  <p>我们今天要讲的知识在网上有不同的名字，比较常见的可能有：</p><br>  <ul><br>    <li>闭包；</li><br>    <li>作用域链；</li><br><br>    <li>执行上下文；</li><br>    <li>this 值。</li><br>  </ul><br>  <p>实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。我们可以简单看一下图。</p><br>  <p><img src="https://static001.geekbang.org/resource/image/68/52/68f50c00d475a7d6d8c7eef6a91b2152.png" alt=""></p><br>  <p>看着也许会有点晕，别着急，我会和你共同理一下它们之间的关系。</p><br><br>  <p>当然，除了让你理解函数执行过程的知识，理清这些概念也非常重要。所以我们先来讲讲这个有点复杂的概念：闭包。</p><br>  <h2>闭包</h2><br>  <p>闭包翻译自英文单词<br>    closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。</p><br>  <p>闭包这个概念第一次出现在 1964 年的《The Computer Journal》上，由 P. J. Landin 在《The mechanical evaluation of expressions》一文中提出了<br>    applicative expression 和 closure 的概念。</p><br>  <p><img src="https://static001.geekbang.org/resource/image/9b/0c/9b6c6693afe654b4cfdbf16852b82a0c.png" alt=""></p><br>  <p>在上世纪 60 年代，主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。</p><br>  <p>我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。<br>  </p><br>  <p>这个古典的闭包定义中，闭包包含两个部分。</p><br>  <ul><br>    <li>环境部分<br>      <ul><br>        <li>环境</li><br>        <li>标识符列表</li><br>      </ul><br>    </li><br>    <li>表达式部分</li><br>  </ul><br>  <p>当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。</p><br>  <ul><br>    <li>环境部分<br>      <ul><br>        <li>环境：函数的词法环境（执行上下文的一部分）</li><br>        <li>标识符列表：函数中用到的未声明的变量</li><br>      </ul><br>    </li><br>    <li>表达式部分：函数体</li><br>  </ul><br>  <p>至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。</p><br>  <p>这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。</p><br>  <p>实际上 JavaScript<br>    中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧（其实我早年也是这么理解闭包，直到后来被朋友纠正，查了资料才改正过来）。</p><br>  <h3>执行上下文：执行的基础设施</h3><br>  <p>相比普通函数，JavaScript 函数的主要复杂性来自于它携带的“环境部分”。当然，发展到今天的 JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。</p><br>  <p>JavaScript 中与闭包“环境部分”相对应的术语是“词法环境”，但是 JavaScript 函数比λ函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ函数中可没有这些东西，所以，在<br>    JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。</p><br>  <p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。</p><br>  <p>因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。</p><br>  <p><strong>执行上下文在 ES3 中</strong>，包含三个部分。</p><br>  <ul><br>    <li>scope：作用域，也常常被叫做作用域链。</li><br>    <li>variable object：变量对象，用于存储变量的对象。</li><br>    <li>this value：this 值。</li><br>  </ul><br>  <p><strong>在 ES5 中</strong>，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。</p><br>  <ul><br>    <li>lexical environment：词法环境，当获取变量时使用。</li><br>    <li>variable environment：变量环境，当声明变量时使用。</li><br>    <li>this value：this 值。</li><br>  </ul><br>  <p><strong>在 ES2018 中</strong>，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。</p><br>  <ul><br>    <li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li><br>    <li>variable environment：变量环境，当声明变量时使用</li><br>    <li>code evaluation state：用于恢复代码执行位置。</li><br>    <li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li><br>    <li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li><br>    <li>Realm：使用的基础库和内置对象实例。</li><br>    <li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li><br>  </ul><br>  <p>我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的 ES2018 中规定的术语定义。</p><br>  <p>尽管我们介绍了这些定义，但我并不打算按照 JavaScript 标准的思路，从实现的角度去介绍函数的执行过程，这是不容易被理解的。</p><br>  <p>我想试着从代码实例出发，跟你一起推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分。</p><br>  <p>比如，我们看以下的这段 JavaScript 代码：</p><br><br><figure class="highlight nix hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="hljs-attr">b</span> = &#123;&#125;</span><br><span class="line"><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span> = <span class="hljs-number">1</span></span><br><span class="line">this.<span class="hljs-attr">a</span> = <span class="hljs-number">2</span>;</span><br></pre></td></tr></table></figure><br><br><p>要想正确执行它，我们需要知道以下信息：</p><ol><br><li>var 把 b 声明到哪里；</li><br><li>b 表示哪个变量；</li><br><li>b 的原型是哪个对象；</li><br><li>let 把 c 声明到哪里；</li><br><li>this 指向哪个对象。</li><br></ol><p>这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。</p><p>在这两篇文章中，我会基本覆盖执行上下文的组成部分，本篇我们先讲 var 声明与赋值，let，realm 三个特性来分析上下文提供的信息，分析执行上下文中提供的信息。</p><h3>var 声明与赋值</h3><p>我们来分析一段代码：</p><br><br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><br><br><p>通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用域函数执行的作用域。也就是说，var 会穿透 for 、if 等语句。</p><p>在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。</p><p>由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a;</span><br><span class="line">    <span class="hljs-comment">//code</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a;</span><br><span class="line">    <span class="hljs-comment">//code</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><br><br><p>但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a;</span><br><span class="line">    <span class="hljs-comment">//code</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a;</span><br><span class="line">    <span class="hljs-comment">//code</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br><br><p>我比较推荐的写法是使用 void 关键字。也就是下面的这种形式。</p><br><br><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> a;</span><br><span class="line">    <span class="hljs-comment">//code</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><br><br><p>这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。</p><p>值得特别注意的是，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，JavaScript 中有特例，那就是使用 with 的时候：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> b;</span><br><span class="line"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> env = &#123;<span class="hljs-attr">b</span>:<span class="hljs-number">1</span>&#125;;</span><br><span class="line">    b = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"In function b:"</span>, b);</span><br><span class="line">    <span class="hljs-keyword">with</span>(env) &#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> b = <span class="hljs-number">3</span>;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"In with b:"</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Global b:"</span>, b);</span><br></pre></td></tr></table></figure><br><br><p>在这个例子中，我们利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境，并且在里面使用了我们一开头的代码。</p><p>可以看到，在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。</p><p>var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。</p><h3>let</h3><p>let 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。</p><p>为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。</p><p>我简单统计了下，以下语句会产生 let 使用的作用域：</p><ul><br><li>for；</li><br><li>if；</li><br><li>switch；</li><br><li>try/catch/finally。</li><br></ul><h3>Realm</h3><p>在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。这个英文的用法就有点比喻的意思，几个翻译都不太适合 JavaScript 语境，所以这里就不翻译啦。</p><p>我们继续来看这段代码：</p><br><br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = &#123;&#125;</span><br></pre></td></tr></table></figure><br><br><p>在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。</p><p>Realm 中包含一组完整的内置对象，而且是复制关系。</p><p>对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。</p><p>以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>)</span><br><span class="line"><span class="hljs-built_in">document</span>.documentElement.appendChild(iframe)</span><br><span class="line">iframe.src=<span class="hljs-string">"javascript:var b = &#123;&#125;;"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> b1 = iframe.contentWindow.b;</span><br><span class="line"><span class="hljs-keyword">var</span> b2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> b1, <span class="hljs-keyword">typeof</span> b2); <span class="hljs-comment">//object object</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(b1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>, b2 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">//false true</span></span><br></pre></td></tr></table></figure><br><br><p>可以看到，由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。</p><h2>结语</h2><p>在今天的课程中，我帮你梳理了一些概念：有编程语言的概念闭包，也有各个版本中的 JavaScript 标准中的概念：执行上下文、作用域、this 值等等。</p><p>之后我们又从代码的角度，分析了一些执行上下文中所需要的信息，并从<code class="ps">var<div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>、<code class="ps">let<div class="ps__rail-x" style="left: 0px; bottom: 0px;"><div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div></div><div class="ps__rail-y" style="top: 0px; right: 0px;"><div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div></div></code>、对象字面量等语法中，推导出了词法作用域、变量作用域、Realm的设计。</p><p>最后留给你一个问题：你喜欢使用 let 还是 var？</p><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;&quot;&gt;&lt;br&gt;  &lt;p&gt;在上一课，我们了解了 JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据“由 JavaScript 引擎发起”还是“由宿主发起”，&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器：一个浏览器是如何工作的？（阶段五）</title>
    <link href="https://jdsheng.cn/2019/03/23/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E4%BA%94%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/03/23/浏览器：一个浏览器是如何工作的？（阶段五）/</id>
    <published>2019-03-23T01:09:46.219Z</published>
    <updated>2019-09-30T16:32:09.240Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  我们的浏览器系列已经进行到最后一篇。<a id="more"></a><br>  在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM树，并且根据样式信息，计算了每个元素的位置和大小。<br><br>  那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。<br><br>  <h2>渲染</h2><br>  首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，也有“粉刷墙壁”的意思。<br><br>  在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。<br><br>  所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。<br><br>  我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。<br><br><br>  不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。<br><br>  这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。<br><br>  浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。<br><br>  这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。<br><br>  盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，我们需要一个底层库来支持。<br><br>  一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。<br><br>  这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。<br><br>  盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。<br><br>  字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++编写的开源的字体库。<br>  在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。<br><br>  但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。<br><br>  注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。<br><br>  <h2>合成</h2><br>  合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。<br><br>  我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。<br><br>  看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？<br><br>  这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。<br><br>  我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 html 创建一个合成后的位图，把所有子元素都进行合成，那么会发生什么呢？<br><br>  那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制所有的元素。<br><br>  那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。<br><br>  那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。<br><br>  我们来举个例子：<br><br><figure class="highlight applescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"a"</span>&gt;</span><br><span class="line">    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"b"</span>&gt;...&lt;/<span class="hljs-keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"c"</span> style=<span class="hljs-string">"transform:translate(0,0)"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="hljs-keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><br><br>假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：<br><br><figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(<span class="hljs-string">"c"</span>).<span class="hljs-built_in">style</span>.<span class="hljs-built_in">transform</span> = <span class="hljs-string">"translate(100px, 0)"</span>;</span><br></pre></td></tr></table></figure><br><br>我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。<br><br>目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。<br><br>但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。<br><br><h2>绘制</h2><br>绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。<br><br>一般最终显式的位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者显式驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。<br><br>这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。<br><br>然而如果在实际中这样做, 会带来极其糟糕的性能。<br><br>有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免”重排”和”重绘”，前者讲的是我们上一课的排版行为，后者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。<br><br>因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。<br><br>这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的目标，当然，简单想想就知道，这种事情不可能总是发生的。<br><br>计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。<br><br>当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。<br><br>设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。<br><br>我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。<br><br><h2>总结</h2><br>在这一章中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。<br><br>当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。<br><br>尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。<br><br>实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。<br><br>转自—《重学前端》<br></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  我们的浏览器系列已经进行到最后一篇。&lt;/div&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://jdsheng.cn/categories/WEB/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器：一个浏览器是如何工作的？（阶段四）</title>
    <link href="https://jdsheng.cn/2019/03/23/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E5%9B%9B%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/03/23/浏览器：一个浏览器是如何工作的？（阶段四）/</id>
    <published>2019-03-23T01:06:26.862Z</published>
    <updated>2019-08-19T15:31:52.408Z</updated>
    
    <content type="html"><![CDATA[<div class=""><br>  我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。<p></p><br>  <a id="more"></a><br>  在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到这样了。<br><br>  尤其是表格相关排版、flex 排版和 grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。<br><br>  <h2>基本概念</h2><br><br>  首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。<br><br>  <strong>“排版”</strong>这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的位置。<br><br>  在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。<br><br>  浏览器最基本的排版方案是<strong>正常流排版</strong>，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。<br><br>  浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型）<br><br><br>  此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。<br><br>  浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的<strong>盒模型</strong>。<br><br>  在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。<br>  <ul><br>    <li><br>      绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由 position 属性控制。<br>    </li><br>    <li><br>      浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。<br>    </li><br>  </ul><br><br>  除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 flex 排版，这些排版方式由外部元素的 display 属性来控制（注意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。<br><br>  <h2>正常流文字排版</h2><br>  我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，我们先从文字来讲起。<br><br>  要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。<br><br>  首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。<br>  我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去继续写。<br><br>  书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。<br><br>  实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。<br><br>  我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面：<br>  <img src="https://static001.geekbang.org/resource/image/06/01/0619d38f00d539f7b6773e541ce6fa01.png" alt=""><br>  纵向版本：<br>  <img src="https://static001.geekbang.org/resource/image/c3/96/c361c7ff3a11216c139ed462b9d5f196.png" alt=""><br>  这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。<br><br>  除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、word-spacing 等。<br><br>  在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。<br><br>  display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性（例如主轴为横向时的 margin-left 和margin-right）也会被计算进排版前进距离当中。<br><br>  注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。<br><br>  这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。<br><br>  <h2>正常流中的盒</h2><br>  在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。<br><br>  根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而 vertical-align属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。<br><br>  所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。<br><br>  块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。<br><br>  <h2>绝对定位元素</h2><br>  position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。<br><br>  <h2>浮动元素排版</h2><br>  float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。<br><br>  移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。<br><br>  float 元素排布完成后，float 元素所在的行需要重新确定位置。<br><br>  <h2>其它的排版</h2><br>  CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。<br><br>  <h2>总结</h2><br>  这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 flex排版。这属于进阶版的排版方式了，你可以了解一下。<br><br>  你平时喜欢使用方式排版呢，欢迎留言告诉我。<br><br>  转自—《重学前端》<br></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;&quot;&gt;&lt;br&gt;  我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。&lt;p&gt;&lt;/p&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://jdsheng.cn/categories/WEB/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>浏览器：一个浏览器是如何工作的？（阶段三）</title>
    <link href="https://jdsheng.cn/2019/03/23/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%88%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/03/23/浏览器：一个浏览器是如何工作的（阶段三）/</id>
    <published>2019-03-23T01:02:09.473Z</published>
    <updated>2019-08-19T15:38:36.223Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  前面讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。<br>  我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，<a id="more"></a>并给这棵朴素的 DOM 树添加上 CSS 属性的。<br><br>  <h2>整体过程</h2><br><br>  首先我们还是要感性地理解一下这个过程。<br><br>  首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。<br><br>  我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS属性计算出来呢？<br><br>  答案是肯定的。<br><br>  在这个过程中，我们依次拿到上一部构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。<br><br>  我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下：<br>  <ul><br>    <li>空格: 后代，选中它的子节点和所有子节点的后代节点。</li><br>    <li>&gt;: 子代，选中它的子节点。</li><br>    <li>+：直接后继选择器，选中它的下一个相邻节点。</li><br>    <li>~：后继，选中它之后所有的相邻节点。</li><br>    <li>||：列，选中表格中的一列。</li><br>  </ul><br><br>关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。<br><br>不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。<br><br>也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。<br><br>理解了 CSS 构建的大概过程，我们下面来看看具体的操作。<br><br>首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。<br>这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。<br><br>我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector通过前面讲的符号连接起来的。<br><br><h2>后代选择器 “空格”</h2><br>我们先来分析一下后代选择器，我们来一起看一个例子：<br><br><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">a</span><span class="hljs-selector-id">#b</span> <span class="hljs-selector-class">.cls</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：<br><br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">b</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">cls</span>&gt;</span>2<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">cls</span>&gt;</span>3<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>当遇到 &lt;/a&gt; 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。<br><br><h2>后继选择器“ ~ ”</h2><br>接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：<br><br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.cls~* &#123;</span><br><span class="line">    border:solid 1px green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">cls</span>&gt;</span>2<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    3</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它的后继，因此应该被选中。<br><br>按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。<br>但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。<br><br>注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。<br><br><h2>子代选择器“ &gt;”</h2><br>我们继续看，子代选择器是如何实现的。<br><br>实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。<br><br><figure class="highlight dts hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div&gt;.<span class="hljs-class">cls </span>&#123;</span><br><span class="line"><span class="hljs-symbol">    border:</span>solid <span class="hljs-number">1</span>px green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-params">&lt;div&gt;</span></span><br><span class="line"><span class="hljs-params">&lt;span&gt;</span><span class="hljs-number">1</span><span class="hljs-params">&lt;span&gt;</span></span><br><span class="line"><span class="hljs-params">&lt;span class=cls&gt;</span><span class="hljs-number">2</span><span class="hljs-params">&lt;span&gt;</span></span><br><span class="line"><span class="hljs-params">&lt;span&gt;</span></span><br><span class="line">    <span class="hljs-number">3</span></span><br><span class="line">    <span class="hljs-params">&lt;span&gt;</span><span class="hljs-number">4</span><span class="hljs-params">&lt;/span&gt;</span></span><br><span class="line"><span class="hljs-params">&lt;span&gt;</span></span><br><span class="line"><span class="hljs-params">&lt;span&gt;</span><span class="hljs-number">5</span><span class="hljs-params">&lt;/span&gt;</span></span><br><span class="line"><span class="hljs-params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><br><br>我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。<br><br><h2>直接后继选择器“ +”</h2><br>直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。<br>一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。<br>另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。<br><br><h2>列选择器“ || ”</h2><br>列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。<br><br><h2>其它</h2><br>我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。<br>比如<br><br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a<span class="hljs-selector-id">#b</span>, <span class="hljs-selector-class">.cls</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>我们当作两条规则来处理：<br><br><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">a</span><span class="hljs-selector-id">#b</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-class">.cls</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：<br><br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-id">#a</span> <span class="hljs-selector-class">.cls</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-id">#a</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#a&gt;<span class="hljs-selector-tag">span</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这里实际上可以把选择器构造成一棵树：<br><ul><br>  <li>#a<br>    <ul><br>      <li>&lt; 空格 &gt;.cls</li><br>      <li>&lt; 空格 &gt;span</li><br>      <li>&gt;span</li><br>    </ul><br>  </li><br></ul><br>需要注意的是，这里的树，必须要带上连接符。<br><br><h2>结语</h2><br>这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。<br><br>在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续继续显式打下了基础。<br><br>最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。<br><br>转自—《重学前端》<br></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  前面讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。&lt;br&gt;  我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，&lt;/div&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://jdsheng.cn/categories/WEB/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
