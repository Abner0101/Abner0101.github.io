<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Old C</title>
  
  <subtitle>老黄瓜VIP专属折腾区</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jdsheng.cn/"/>
  <updated>2019-12-09T03:10:02.163Z</updated>
  <id>https://jdsheng.cn/</id>
  
  <author>
    <name>老黄瓜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS内存管理机制？</title>
    <link href="https://jdsheng.cn/2019/12/09/JS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://jdsheng.cn/2019/12/09/JS内存管理机制/</id>
    <published>2019-12-09T03:08:50.310Z</published>
    <updated>2019-12-09T03:10:02.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。<a id="more"></a>因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>JS 环境中分配的内存有如下声明周期：</p><ol><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</li></ol><p><strong>JS 的内存分配</strong></p><p>为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> n = <span class="hljs-number">123</span>; <span class="hljs-comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"azerty"</span>; <span class="hljs-comment">// 给字符串分配内存</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="hljs-number">1</span>,</span><br><span class="line">  b: <span class="hljs-literal">null</span></span><br><span class="line">&#125;; <span class="hljs-comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"abra"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> a + <span class="hljs-number">2</span>;</span><br><span class="line">&#125; <span class="hljs-comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="hljs-string">'blue'</span>;</span><br><span class="line">&#125;, <span class="hljs-literal">false</span>);</span><br></pre></td></tr></table></figure><p>有些函数调用结果是分配对象内存：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="hljs-keyword">var</span> e = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>); <span class="hljs-comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure><p>有些方法分配新变量或者新对象：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-string">"azerty"</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> s2 = s.substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="hljs-comment">// 因为字符串是不变量，</span></span><br><span class="line"><span class="hljs-comment">// JavaScript 可能决定不分配内存，</span></span><br><span class="line"><span class="hljs-comment">// 只是存储了 [0-3] 的范围。</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">"ouais ouais"</span>, <span class="hljs-string">"nan nan"</span>];</span><br><span class="line"><span class="hljs-keyword">var</span> a2 = [<span class="hljs-string">"generation"</span>, <span class="hljs-string">"nan nan"</span>];</span><br><span class="line"><span class="hljs-keyword">var</span> a3 = a.concat(a2);</span><br><span class="line"><span class="hljs-comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure><p><strong>JS 的内存使用</strong><br>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 分配内存</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 对内存的使用</span></span><br></pre></td></tr></table></figure><p><strong>JS 的内存回收</strong></p><p>JS 有自动垃圾回收机制，那么这个自动垃圾回收机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。</p><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到不再需要使用的变量。</p><p>不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在， 当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</p><p>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。</p><p>因为自动垃圾回收机制的存在，开发人员可以不关心也不注意内存释放的有关问题，但对无用内存的释放这件事是客观存在的。不幸的是，即使不考虑垃圾回收对性能的影响，目前最新的垃圾回收算法，也无法智能回收所有的极端情况。</p><p>接下来我们来探究一下 JS 垃圾回收的机制。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote><p>垃圾回收算法主要依赖于引用的概念。</p><p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p><p>例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p></blockquote><p><strong>引用计数垃圾收集</strong></p><p>这是最初级的垃圾回收算法。</p><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="hljs-number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="hljs-comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">var</span> o2 = o; <span class="hljs-comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"> </span><br><span class="line">o = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">var</span> oa = o2.a; <span class="hljs-comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="hljs-comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"> </span><br><span class="line">o2 = <span class="hljs-string">"yo"</span>; <span class="hljs-comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line">           <span class="hljs-comment">// 他可以被垃圾回收了</span></span><br><span class="line">           <span class="hljs-comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"> </span><br><span class="line">oa = <span class="hljs-literal">null</span>; <span class="hljs-comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="hljs-comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><p>由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。</p><p>如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露。</p><p>来看一个循环引用的例子：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="hljs-keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="hljs-comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="hljs-comment">// o2 引用 o  这里</span></span><br><span class="line"> </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>上面我们申明了一个函数 f ，其中包含两个相互引用的对象。在调用函数结束后，对象 o1 和 o2 实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了。</p><p>再来看一个实际的例子：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);</span><br><span class="line">div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"click"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这种JS写法再普通不过了，创建一个DOM元素并绑定一个点击事件。此时变量 div 有事件处理函数的引用，同时事件处理函数也有div的引用！（div变量可在函数内被访问）。一个循序引用出现了，按上面所讲的算法，该部分内存无可避免的泄露了。</p><p>为了解决循环引用造成的问题，现代浏览器通过使用标记清除算法来实现垃圾回收。</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p><p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。但反之未必成立。</p><p>工作流程：</p><ol><li><p>垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。</p></li><li><p>从根部出发将能触及到的对象的标记清除。</p></li><li><p>那些还存在标记的变量被视为准备删除的变量。</p></li><li><p>最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间</p></li></ol><p>循环引用不再是问题了</p><p>再看之前循环引用的例子：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="hljs-keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="hljs-comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="hljs-comment">// o2 引用 o</span></span><br><span class="line"> </span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>函数调用返回之后，两个循环引用的对象在垃圾收集时从全局对象出发无法再获取他们的引用。因此，他们将会被垃圾回收器回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>什么是内存泄漏</strong></p><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>本质上讲,内存泄漏就是由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。</p><p><strong>内存泄漏的识别方法</strong></p><p>经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存的占用情况。</p><p>在 Chrome 浏览器中，我们可以这样查看内存占用情况</p><ol><li><p>打开开发者工具，选择 Performance 面板</p></li><li><p>在顶部勾选 Memory</p></li><li><p>点击左上角的 record 按钮</p></li><li><p>在页面上进行各种操作，模拟用户的使用情况</p></li><li><p>一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况</p></li></ol><p>我们有两种方式来判定当前是否有内存泄漏：</p><ol><li><p>多次快照后，比较每次快照中内存的占用情况，如果呈上升趋势，那么可以认为存在内存泄漏</p></li><li><p>某次快照后，看当前内存占用的趋势图，如果走势不平稳，呈上升趋势，那么可以认为存在内存泄漏</p></li></ol><p>在服务器环境中使用 Node 提供的 process.memoryUsage 方法查看内存情况</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(process.memoryUsage());</span><br><span class="line"><span class="hljs-comment">// &#123;</span></span><br><span class="line"><span class="hljs-comment">//     rss: 27709440,</span></span><br><span class="line"><span class="hljs-comment">//     heapTotal: 5685248,</span></span><br><span class="line"><span class="hljs-comment">//     heapUsed: 3449392,</span></span><br><span class="line"><span class="hljs-comment">//     external: 8772</span></span><br><span class="line"><span class="hljs-comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。</p><p>该对象包含四个字段，单位是字节，含义如下:</p><ul><li><p>rss（resident set size）：所有内存占用，包括指令区和堆栈。</p></li><li><p>heapTotal：”堆”占用的内存，包括用到的和没用到的。</p></li><li><p>heapUsed：用到的堆的部分。</p></li><li><p>external：V8 引擎内部的 C++ 对象占用的内存。</p></li></ul><p>判断内存泄漏，以heapUsed字段为准。</p><h2 id="常见的内存泄露案例"><a href="#常见的内存泄露案例" class="headerlink" title="常见的内存泄露案例"></a>常见的内存泄露案例</h2><ol><li><strong>意外的全局变量</strong></li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    bar1 = <span class="hljs-string">'some text'</span>; <span class="hljs-comment">// 没有声明变量 实际上是全局变量 =&gt; window.bar1</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.bar2 = <span class="hljs-string">'some text'</span> <span class="hljs-comment">// 全局变量 =&gt; window.bar2</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>在这个例子中，意外的创建了两个全局变量 bar1 和 bar2</p><ol start="2"><li><strong>被遗忘的定时器和回调函数</strong></li></ol><p>在很多库中, 如果使用了观察者模式, 都会提供回调方法, 来调用一些回调函数。要记得回收这些回调函数。举一个 setInterval的例子：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> serverData = loadData();</span><br><span class="line">setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> renderer = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'renderer'</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span>(renderer) &#123;</span><br><span class="line">        renderer.innerHTML = <span class="hljs-built_in">JSON</span>.stringify(serverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="hljs-number">5000</span>); <span class="hljs-comment">// 每 5 秒调用一次</span></span><br></pre></td></tr></table></figure><p>如果后续 renderer 元素被移除，整个定时器实际上没有任何作用。但如果你没有回收定时器，整个定时器依然有效, 不但定时器无法被内存回收， 定时器函数中的依赖也无法回收。在这个案例中的 serverData 也无法被回收。</p><ol start="3"><li><strong>闭包</strong></li></ol><p>在 JS 开发中，我们会经常用到闭包，一个内部函数，有权访问包含其的外部函数中的变量。下面这种情况下，闭包也会造成内存泄露:</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> theThing = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> replaceThing = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="hljs-keyword">var</span> unused = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (originalThing) <span class="hljs-comment">// 对于 'originalThing'的引用</span></span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>).join(<span class="hljs-string">'*'</span>),</span><br><span class="line">    someMethod: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, <span class="hljs-number">1000</span>);</span><br></pre></td></tr></table></figure><p>这段代码，每次调用 replaceThing 时，theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象。同时 unused 是一个引用了 originalThing 的闭包。</p><p>这个范例的关键在于，闭包之间是共享作用域的，尽管 unused 可能一直没有被调用，但是 someMethod 可能会被调用，就会导致无法对其内存进行回收。当这段代码被反复执行时，内存会持续增长。</p><ol start="4"><li><strong>DOM 引用</strong><br>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中。</li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> elements = &#123;</span><br><span class="line">    image: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'image'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doStuff</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    elements.image.src = <span class="hljs-string">'http://example.com/image_name.png'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeImage</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'image'</span>));</span><br><span class="line">    <span class="hljs-comment">// 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例中，即使我们对于 image 元素进行了移除，但是仍然有对 image 元素的引用，依然无法对齐进行内存回收。</p><p>另外需要注意的一个点是，对于一个 Dom 树的叶子节点的引用。举个例子: 如果我们引用了一个表格中的td元素，一旦在 Dom 中删除了整个表格，我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素。但是事实上，这个 td 元素是整个表格的一个子元素，并保留对于其父元素的引用。这就会导致对于整个表格，都无法进行内存回收。所以我们要小心处理对于 Dom 元素的引用。</p><h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2><p>记住一个原则：不用的东西，及时归还。</p><ul><li><p>减少不必要的全局变量，使用严格模式避免意外创建全局变量。</p></li><li><p>在你使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）。</p></li><li><p>组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JS变量的创建机制？</title>
    <link href="https://jdsheng.cn/2019/12/09/JS%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9C%BA%E5%88%B6/"/>
    <id>https://jdsheng.cn/2019/12/09/JS变量的创建机制/</id>
    <published>2019-12-09T03:03:40.068Z</published>
    <updated>2019-12-09T03:08:23.573Z</updated>
    
    <content type="html"><![CDATA[<p>JS怎么创建变量？</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>那么它们具体存储在哪里，又怎么运行？</p><p>这次，就聊聊JS的堆栈内存和变量的创建机制。</p><h2 id="1-堆栈内存"><a href="#1-堆栈内存" class="headerlink" title="1.堆栈内存"></a>1.堆栈内存</h2><p>在了解变量创建机制之前，先来了解一下变量的存储空间。</p><p>存储空间分为栈内存和堆内存。</p><p><strong>栈内存：作用域</strong></p><ul><li>提供一个供 JS 代码自上而下执行的环境（代码都是在栈内存中执行的）</li><li>存储基本类型值。由于基本类型比较简单，它们都是直接在栈内存中开辟一个位置，直接把值存储进去的</li></ul><p><strong>堆内存：引用值对应的空间</strong></p><ul><li>对象：键值对</li><li>函数：代码字符串</li></ul><p>由于引用类型的值可能过于复杂，所以需要另外开辟空间来存储，而变量中存储的只是指向这个空间的地址。</p><h2 id="2-变量的创建"><a href="#2-变量的创建" class="headerlink" title="2. 变量的创建"></a>2. 变量的创建</h2><p>（1）创建作用域<br>当浏览器（内核/引擎）渲染和解析 JS 代码的时候，会提供一个供 JS 代码运行的环境，这个环境称为“全局作用域”（global / window scope），是一个栈内存</p><p>（2）进行变量提升<br>将在作用域中使用 var / function 声明的变量进行提升。其中</p><ul><li>var 声明的变量只提升声明，不定义</li><li>function 声明的变量，既提升声明，也提升定义</li></ul><p>（3）代码自上而下执行</p><p><strong>基本数据类型</strong>的值会存储在当前作用域下，以 <code>var a = 12</code> 为例</p><ul><li>首先在当前作用域中声明一个变量 a（这一步会在变量提升阶段完成，执行时会忽略这个声明）</li><li>然后开辟一个空间存储值 12</li><li>最后让<strong>声明的变量与存储的值进行关联</strong>（就是赋值操作，也叫做定义）</li></ul><p>基本数据类型（也叫做值类型），是按照值来操作的：把原有的值赋值一份放到新的空间或者位置上，和原来的值没有关系</p><p><strong>引用数据类型</strong>的值，我们需要开辟一个新的空间（理解为仓库），把内容存储到这个空间中</p><ul><li>首先声明一个变量（同样，这一步是在变量提升阶段完成，执行时会忽略这个声明）</li><li>然后开辟一个新的内存空间，把对象中的键值对依次存储起来（此空间有个 16 进制的地址）</li><li>让变量与空间地址关联起来（把空间地址赋值给变量）</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="line">  n: <span class="hljs-number">10</span>,</span><br><span class="line">  m: obj.n * <span class="hljs-number">10</span></span><br><span class="line">  <span class="hljs-comment">//=&gt; Uncaught TypeError: Cannot read property 'n' of undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.m);</span><br></pre></td></tr></table></figure><p>原因分析</p><p>1.形成一个全局作用域（栈内存）<br>2.代码自上而下执行</p><ul><li>首先开辟一个新的堆内存，把键值对存储到对内存中 <code>n: 10, m: obj.n * 10</code></li><li>此时堆内存信息还没有存储完成，空间地址还没有与变量 obj 关联，此时的 <code>obj</code> 是 <code>undefined</code>，<code>obj.n &lt;=&gt; undefined.n</code>，所以报错</li></ul><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="line">  n: <span class="hljs-number">10</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.m = obj.n * <span class="hljs-number">10</span>; <span class="hljs-comment">// 此时的 obj 已经有值了</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(obj.m); <span class="hljs-comment">//=&gt; 100</span></span><br></pre></td></tr></table></figure><p>引用类型不是按照值来操作，它操作的是空间的地址：把原有空间地址赋值给新的变量，但是原来的空间没有被克隆，还是同一个空间，这样就会出现多个变量关联的是相同的空间，相互之间就会存在影响。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];</span><br><span class="line"><span class="hljs-keyword">var</span> arr2 = arr1;</span><br><span class="line">arr2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;</span><br><span class="line">arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br><span class="line">arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;</span><br><span class="line">arr1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(arr1, arr2); <span class="hljs-comment">//=&gt; 1, 0, 4, 2</span></span><br></pre></td></tr></table></figure><p>原因分析：</p><ol><li>数组也是对象，属于引用类型，会开辟一个新的堆内存保存 <code>[3,4]</code><ol start="2"><li>往下，<code>arr2 = arr1</code>，此时两个变量同时保存一个堆内存的地址</li><li>改变 <code>arr2</code> 会反映到 <code>arr1</code>，此时 <code>arr1: [1,4] arr2: [1,4]</code></li><li>新开辟一个堆内存，保存 <code>[4,5]</code>，然后再把地址赋值给 <code>arr2</code></li><li>此时两个变量关联的内存不再一样，对其的操作不再相互影响，此时 <code>arr1: [1,4] arr2:[4,5]</code></li><li>再次赋值后，<code>arr1: [1,0] arr2: [4,2]</code></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS怎么创建变量？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;b&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java函数式编程入门</title>
    <link href="https://jdsheng.cn/2019/11/08/Java%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://jdsheng.cn/2019/11/08/Java 函数式编程入门/</id>
    <published>2019-11-08T03:23:18.173Z</published>
    <updated>2019-11-08T08:33:07.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="Lambda-表达式介绍"><a href="#Lambda-表达式介绍" class="headerlink" title="Lambda 表达式介绍"></a>Lambda 表达式介绍</h3><blockquote><p>是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</p></blockquote><a id="more"></a><h3 id="一般使用场景"><a href="#一般使用场景" class="headerlink" title="一般使用场景"></a>一般使用场景</h3><blockquote><p>当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效。</p></blockquote><h3 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h3><blockquote><p>当方法没有形参的时候，使用 <strong>()</strong> 表示</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; log.info(<span class="hljs-string">"hehe"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>当方法只有一个形参的时候，可以直接<strong>省略括号</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p);</span><br></pre></td></tr></table></figure><blockquote><p>当方法有多个参数时，需要使用 <strong>()</strong> 括起来</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a,b) -&gt; <span class="hljs-keyword">return</span> a + b;</span><br></pre></td></tr></table></figure><blockquote><p>参数可以省略类型，也可以写上</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(a,b) -&gt; <span class="hljs-keyword">return</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//等同于</span></span><br><span class="line"></span><br><span class="line">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b) -&gt; <span class="hljs-keyword">return</span> a + b;</span><br></pre></td></tr></table></figure><hr><h3 id="通过两个例子初步体验-Lambda"><a href="#通过两个例子初步体验-Lambda" class="headerlink" title="通过两个例子初步体验 Lambda"></a>通过两个例子初步体验 Lambda</h3><blockquote><p>创建一个线程</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//        原写法</span></span><br><span class="line"><span class="hljs-comment">//        new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="hljs-comment">//            @Override</span></span><br><span class="line"><span class="hljs-comment">//            public void run() &#123;</span></span><br><span class="line"><span class="hljs-comment">//                log.info("hello lambda");</span></span><br><span class="line"><span class="hljs-comment">//            &#125;</span></span><br><span class="line"><span class="hljs-comment">//        &#125;).start();</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//使用 lambda 表达式创建一个线程</span></span><br><span class="line">        Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; log.info(<span class="hljs-string">"hello lambda"</span>));</span><br><span class="line">        thread.start();</span><br></pre></td></tr></table></figure><blockquote><p>实现 List 排序</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"y"</span>,<span class="hljs-string">"z"</span>,<span class="hljs-string">"x"</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//        原写法</span></span><br><span class="line"><span class="hljs-comment">//        Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="hljs-comment">//            @Override</span></span><br><span class="line"><span class="hljs-comment">//            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="hljs-comment">//                return o1.compareTo(o2);</span></span><br><span class="line"><span class="hljs-comment">//            &#125;</span></span><br><span class="line"><span class="hljs-comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//        使用 lambda 表达式 完成排序</span></span><br><span class="line">        Collections.sort(list,(o1,o2) -&gt; o1.compareTo(o2));</span><br></pre></td></tr></table></figure><hr><h3 id="深入解析-Lambda"><a href="#深入解析-Lambda" class="headerlink" title="深入解析 Lambda"></a>深入解析 Lambda</h3><blockquote><p>Lambda 本身是语法糖，起的作用是重写<strong>函数式接口</strong>(只包含<strong>一个抽象方法声明的接口</strong>) 的抽象方法，Java中常用到的比如<strong>Comparator</strong>或者<strong>Runnable</strong>接口，这些接口都增加了<strong>@FunctionalInterface</strong> 注解以便能用在lambda上。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// new Runnable 只有 run 一个抽象方法，这里是 Lambda 的语法糖效果，自动重写了这个抽象方法</span></span><br><span class="line">Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; log.info(<span class="hljs-string">"hello lambda"</span>));</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><hr><h3 id="通过一个自定义函数式接口来理解-Lambda"><a href="#通过一个自定义函数式接口来理解-Lambda" class="headerlink" title="通过一个自定义函数式接口来理解 Lambda"></a>通过一个自定义函数式接口来理解 Lambda</h3><blockquote><p>使用 <strong>@FunctionalInterface</strong> 来声明一个接口是函数式接口，该注解只能标记在<strong>”有且仅有一个抽象方法”</strong>的接口上，但它<strong>不是必须的</strong>，只是为了编译器更好地检测</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">//函数式接口</span></span><br><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LambdaInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 一个求和抽象方法，当然后面重写可以自定义，不一定是求和</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个调用这个函数式接口的类</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> com.zyy.consumer.bean.User;</span><br><span class="line"><span class="hljs-keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// lombok 中 @Data ，自动填充 setter 和 getter</span></span><br><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer first;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer second;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSum</span><span class="hljs-params">(LambdaInterface lambdaInterface)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> lambdaInterface.sum(first,second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开始表演</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLambdaInterface</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Integer c = <span class="hljs-number">0</span>;</span><br><span class="line">        FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line">        firstLambda.setFirst(<span class="hljs-number">22</span>);</span><br><span class="line">        firstLambda.setSecond(<span class="hljs-number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 原生态操作</span></span><br><span class="line"><span class="hljs-comment">//        c = firstLambda.getSum(new LambdaInterface() &#123;</span></span><br><span class="line"><span class="hljs-comment">//            @Override</span></span><br><span class="line"><span class="hljs-comment">//            public Integer sum(int a, int b) &#123;</span></span><br><span class="line"><span class="hljs-comment">//                return a + b;</span></span><br><span class="line"><span class="hljs-comment">//            &#125;</span></span><br><span class="line"><span class="hljs-comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 这个时候我们可以使用箭头函数去重写 sum 的实现</span></span><br><span class="line">        c = firstLambda.getSum((a,b) -&gt; &#123;<span class="hljs-keyword">return</span> a + b;&#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="java-util-function-包"><a href="#java-util-function-包" class="headerlink" title="java.util.function 包"></a>java.util.function 包</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p>由于这个包都是 <strong>函数式接口</strong>，和 Lambda 搭配使用效果更佳</p></blockquote><h3 id="拥有的方法"><a href="#拥有的方法" class="headerlink" title="拥有的方法"></a>拥有的方法</h3><h4 id="参考：https-blog-csdn-net-huo065000-article-details-78964382"><a href="#参考：https-blog-csdn-net-huo065000-article-details-78964382" class="headerlink" title="参考：https://blog.csdn.net/huo065000/article/details/78964382"></a>参考：<a href="https://blog.csdn.net/huo065000/article/details/78964382" target="_blank" rel="noopener">https://blog.csdn.net/huo065000/article/details/78964382</a></h4><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>Consumer</td><td>Consumer&lt; T &gt;</td><td>接收T对象，不返回值</td></tr><tr><td>Predicate</td><td>Predicate&lt; T &gt;</td><td>接收T对象并返回boolean</td></tr><tr><td>Function</td><td>Function&lt; T, R &gt;</td><td>接收T对象，返回R对象</td></tr><tr><td>Supplier</td><td>Supplier&lt; T &gt;</td><td>提供T对象（例如工厂），不接收值</td></tr><tr><td>UnaryOperator</td><td>UnaryOperator&lt; T &gt;</td><td>接收T对象，返回T对象</td></tr><tr><td>BiConsumer</td><td>BiConsumer&lt;T, U&gt;</td><td>接收T对象和U对象，不返回值</td></tr><tr><td>BiPredicate</td><td>BiPredicate&lt;T, U&gt;</td><td>接收T对象和U对象，返回boolean</td></tr><tr><td>BiFunction</td><td>BiFunction&lt;T, U, R&gt;</td><td>接收T对象和U对象，返回R对象</td></tr><tr><td>BinaryOperator</td><td>BinaryOperator&lt; T &gt;</td><td>接收两个T对象，返回T对象</td></tr></tbody></table><p>### </p><hr><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><blockquote><p><strong>Predicate</strong> 用于实现一个条件语句，而 <strong>Consumer</strong> 用于实现操作,不返回值，两者往往搭配使用</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> com.zyy.consumer.bean.User;</span><br><span class="line"><span class="hljs-keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer first;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer second;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSum</span><span class="hljs-params">(LambdaInterface lambdaInterface)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> lambdaInterface.sum(first,second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 写一个 筛选list 的方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkNumberBigger</span><span class="hljs-params">(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate,Consumer&lt;Integer&gt; consumer)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(Integer integer : list)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(predicate.test(integer))&#123;</span><br><span class="line">                consumer.accept(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>调用该方法</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLambdaPredicate</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 这里重写了 Predicate 的test 方法，以完成逻辑的判断，重写了 Consumer 的 accept 方法，完成处理操作</span></span><br><span class="line">        <span class="hljs-keyword">new</span> FirstLambda().checkNumberBigger(list,</span><br><span class="line">                p -&gt; p &gt; <span class="hljs-number">5</span>,</span><br><span class="line">                p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 此时 Predicate </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Integer p)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> p &gt; <span class="hljs-number">5</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 此时 Consumer</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Integer p)</span></span>&#123;</span><br><span class="line">    log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Function&lt;R,T&gt;</strong>  类似一个一元函数，通过输入一个 R 类型的参数，通过处理以后 返回 T 类型的返回值，这里的使用例子是通过输入的字符串 返回 该字符串的长度 </p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 之前 FirstLambda 中新的方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStringLength</span><span class="hljs-params">(String string,Function&lt;String,Integer&gt; function)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> function.apply(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 测试该方法</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFunction</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line">    Integer length = firstLambda.getStringLength(<span class="hljs-string">"Hello World"</span>,</span><br><span class="line">           p -&gt; &#123;<span class="hljs-keyword">return</span> p.length();&#125;);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"length : &#123;&#125;"</span>,length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Function 中 <strong>compose</strong> 可以结合两个函数，以下是它的源码</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 可以看出，它是依赖于apply类的，所以这不是一个抽象方法，不影响函数式接口的定义，本质是执行完before 方法以后，继续执行this.apply，从而实现两个函数结合使用    </span></span><br><span class="line"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>实例就采用先进行字符串处理，在计算字符串大小</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 之前 FirstLambda 中新的方法</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStringLengthSecond</span><span class="hljs-params">(String string,Function&lt;String,String&gt; before,Function&lt;String,Integer&gt; function)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> function.compose((Function&lt;? <span class="hljs-keyword">super</span> String, ? extends String&gt;) before).apply(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 测试该方法</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFunctionCompose</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line"></span><br><span class="line">        Integer length = firstLambda.getStringLengthSecond(<span class="hljs-string">"Hello"</span>,</span><br><span class="line">                p -&gt; &#123;<span class="hljs-keyword">return</span> p + <span class="hljs-string">" World"</span>;&#125;,</span><br><span class="line">                p -&gt; &#123;<span class="hljs-keyword">return</span> p.length();&#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"length : &#123;&#125;"</span>,length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Function 中 的 <strong>andThen</strong> 方法则是先执行 this 方法，再去执行 after 方法，也是结合两个Function</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试例子是先求字符串的和，再将长度加上100</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 之前 FirstLambda 中新的方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStringLengthThird</span><span class="hljs-params">(String string,Function&lt;Integer,Integer&gt; after,Function&lt;String,Integer&gt; function)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> function.andThen(after).apply(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 测试该方法</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFunctionAndThen</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line"></span><br><span class="line">    Integer length = firstLambda.getStringLengthThird(<span class="hljs-string">"Hello World"</span>,</span><br><span class="line">            p -&gt; &#123;<span class="hljs-keyword">return</span> p + <span class="hljs-number">100</span>;&#125;,</span><br><span class="line">    p -&gt; &#123;<span class="hljs-keyword">return</span> p.length();&#125;);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"length : &#123;&#125;"</span>,length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Supplier</strong> 不接受参数，表示一个工厂类，实现工厂的作用,下面是调用User的静态方法返回实例</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// User 类</span></span><br><span class="line"><span class="hljs-keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer age;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double weight;</span><br><span class="line">    <span class="hljs-keyword">private</span> String sexy;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double height;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">getSimpleUser</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="hljs-string">"simple"</span>);</span><br><span class="line">        user.setSexy(<span class="hljs-string">"male"</span>);</span><br><span class="line">        user.setAge(<span class="hljs-number">21</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 之前 FirstLambda 中新的方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(Supplier&lt;User&gt; supplier)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 测试该方法</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSupplier</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line"></span><br><span class="line">    User user = firstLambda.getUser(() -&gt; &#123;<span class="hljs-keyword">return</span> User.getSimpleUser();&#125;);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"user : &#123;&#125;"</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>UnaryOperator</strong> 和 <strong>Funtion</strong> 有些相似，不同的是它只能返回传入参数同种类型的值</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-comment">// 对字符串进行加工</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getString</span><span class="hljs-params">(String string,UnaryOperator&lt;String&gt; unaryOperator)</span></span>&#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> unaryOperator.apply(string);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 实现实例</span></span><br><span class="line">   <span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUnaryOperator</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">       FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line"></span><br><span class="line">       String string = firstLambda.getString(<span class="hljs-string">"Hello"</span>,</span><br><span class="line">               p -&gt; &#123;<span class="hljs-keyword">return</span> p + <span class="hljs-string">" World!!!"</span>;&#125;);</span><br><span class="line"></span><br><span class="line">       log.info(<span class="hljs-string">"string : &#123;&#125;"</span>,string);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>BiConsumer</strong> 比 <strong>Consumer</strong>  多接收了一个参数</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 拼接一个名字</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">(String firstName,String secondName,BiConsumer&lt;String,String&gt; biConsumer)</span></span>&#123;</span><br><span class="line">    biConsumer.accept(firstName,secondName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBiConsumer</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line"></span><br><span class="line">    firstLambda.getName(<span class="hljs-string">"Macro"</span>,<span class="hljs-string">"Reus"</span>,</span><br><span class="line">            (a,b) -&gt; log.info(<span class="hljs-string">"&#123;&#125; &#123;&#125;"</span>,a,b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>BiPredicate</strong> 比 <strong>Predicate</strong> 多接受一个参数</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 找出年龄较大的一位</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOlderUser</span><span class="hljs-params">(User first,User second,BiPredicate&lt;User,User&gt; biPredicate,Function&lt;User,String&gt; function)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(biPredicate.test(first,second))&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> function.apply(first);</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> function.apply(second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBiPredicate</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line">        User first = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        first.setName(<span class="hljs-string">"Ke"</span>);</span><br><span class="line">        first.setAge(<span class="hljs-number">22</span>);</span><br><span class="line">        User second = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        second.setAge(<span class="hljs-number">21</span>);</span><br><span class="line">        second.setName(<span class="hljs-string">"Liang"</span>);</span><br><span class="line"><span class="hljs-comment">//         找出两个User中年龄较大的User的名字</span></span><br><span class="line">        String name = firstLambda.getOlderUser(first,second,</span><br><span class="line">                (a,b) -&gt; &#123;<span class="hljs-keyword">return</span> a.getAge() &gt;= b.getAge();&#125;,</span><br><span class="line">                p -&gt; &#123;<span class="hljs-keyword">return</span> p.getName();&#125;);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"user : &#123;&#125;"</span>,name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>BiFunction</strong> 相比于 <strong>Function</strong> 多接收一个参数</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 计算矩形面积</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getArea</span><span class="hljs-params">(Double length,Double width,BiFunction&lt;Double,Double,Double&gt; biFunction)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> biFunction.apply(length,width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//测试实例</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBiFunction</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    FirstLambda firstLambda = <span class="hljs-keyword">new</span> FirstLambda();</span><br><span class="line"></span><br><span class="line">    Double length = <span class="hljs-number">2.2</span>;</span><br><span class="line"></span><br><span class="line">    Double width = <span class="hljs-number">5.1</span>;</span><br><span class="line"></span><br><span class="line">    Double area = firstLambda.getArea(length,width,</span><br><span class="line">            (a,b) -&gt; &#123;<span class="hljs-keyword">return</span> a * b;&#125;);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"area : &#123;&#125;"</span>,area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>BinaryOperator</strong> 用法同上，只不过只能操作一种类型的参数</p></blockquote><hr><h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><h3 id="实际用处"><a href="#实际用处" class="headerlink" title="实际用处"></a>实际用处</h3><blockquote><p>函数式编程中，用于处理 <strong>空指针异常</strong> (NullPointerException)</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">public static <t> Optional<t> <strong>of</strong>(T value)</t></t></td><td style="text-align:center">为非null的值创建一个Optional</td></tr><tr><td style="text-align:center">public static <t> Optional<t> <strong>ofNullable</strong>(T value)</t></t></td><td style="text-align:center">为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional</td></tr><tr><td style="text-align:center">public boolean <strong>isPresent</strong>()</td><td style="text-align:center">如果值存在返回true，否则返回false</td></tr><tr><td style="text-align:center">public T <strong>get</strong>()</td><td style="text-align:center">如果Optional有值则将其返回，否则抛出NoSuchElementException</td></tr><tr><td style="text-align:center">public void <strong>ifPresent</strong>(Consumer&lt;? super T&gt; consumer)</td><td style="text-align:center">如果Optional实例有值则为其调用consumer，否则不做处理</td></tr><tr><td style="text-align:center">public T <strong>orElse</strong>(T other)</td><td style="text-align:center">如果有值则将其返回，否则返回指定的其它值</td></tr><tr><td style="text-align:center">public T <strong>orElseGet</strong>(Supplier&lt;? extends T&gt; other)</td><td style="text-align:center">orElseGet与orElse方法类似，区别在于得到的默认值</td></tr><tr><td style="text-align:center">public <x extends="" throwable=""> T <strong>orElseThrow</strong>(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</x></td><td style="text-align:center">如果有值则将其返回，否则抛出supplier接口创建的异常</td></tr><tr><td style="text-align:center">public<u> Optional<u> <strong>map</strong>(Function&lt;? super T, ? extends U&gt; mapper)</u></u></td><td style="text-align:center">如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。</td></tr><tr><td style="text-align:center">public<u> Optional<u> <strong>flatMap</strong>(Function&lt;? super T, Optional<u>&gt; mapper)</u></u></u></td><td style="text-align:center">如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。</td></tr><tr><td style="text-align:center">public Optional<t> <strong>filter</strong>(Predicate&lt;? super T&gt; predicate)</t></td><td style="text-align:center">如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional</td></tr></tbody></table><hr><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><blockquote><p>使用 <strong>of</strong> 创建一个 <strong>Optional</strong> ，传入的值不能为 NULL，否则抛出 <strong>NullPointerException</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOf</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;String&gt; optional = Optional.of(<span class="hljs-string">"Ke"</span>);</span><br><span class="line">    log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>ofNullable</strong> 创建一个 <strong>Optional</strong> ,如果传入一个 NULL ，则返回空的Optional</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOfNullable</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;String&gt; optionalFirst = Optional.ofNullable(<span class="hljs-string">"Liang"</span>);</span><br><span class="line">    Optional&lt;String&gt; optionalSecond = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"first : &#123;&#125;"</span>,optionalFirst); <span class="hljs-comment">// first : Optional[Liang]</span></span><br><span class="line">    log.info(<span class="hljs-string">"second ; &#123;&#125;"</span>,optionalSecond); <span class="hljs-comment">// second ; Optional.empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>isPresent</strong> 判定 Optional 是否为空</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOfNullable</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;String&gt; optionalFirst = Optional.ofNullable(<span class="hljs-string">"Liang"</span>);</span><br><span class="line">    Optional&lt;String&gt; optionalSecond = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"firstIsNull : &#123;&#125;"</span>,optionalFirst.isPresent()); <span class="hljs-comment">// true</span></span><br><span class="line">    log.info(<span class="hljs-string">"secondIsNull : &#123;&#125;"</span>,optionalSecond.isPresent()); <span class="hljs-comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>get</strong> 获取值，如果值不存在，抛出 <strong>NoSuchElementException</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOfNullable</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;String&gt; optionalFirst = Optional.ofNullable(<span class="hljs-string">"Liang"</span>);</span><br><span class="line">    Optional&lt;String&gt; optionalSecond = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"first : &#123;&#125;"</span>,optionalFirst.get()); <span class="hljs-comment">// first : Liang</span></span><br><span class="line">    log.info(<span class="hljs-string">"second ; &#123;&#125;"</span>,optionalSecond.get()); <span class="hljs-comment">// java.util.NoSuchElementException: No value present</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>ifPresent</strong> 实现函数式编程，如果值存在，则执行 <strong>Consumer</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIfPresent</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;String&gt; optionalFirst = Optional.ofNullable(<span class="hljs-string">"Liang"</span>);</span><br><span class="line">    Optional&lt;String&gt; optionalSecond = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    optionalFirst.ifPresent(</span><br><span class="line">            p -&gt; log.info(<span class="hljs-string">"firstValue : &#123;&#125;"</span>,p) <span class="hljs-comment">// firstValue : Liang</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    optionalSecond.ifPresent(</span><br><span class="line">            p -&gt; log.info(<span class="hljs-string">"secondValue : &#123;&#125;"</span>,p)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>orElse</strong> 有值则返回，无值则指定其他值</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOrElse</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;String&gt; optional = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line">    log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional.orElse(<span class="hljs-string">"NULL"</span>)); <span class="hljs-comment">// optional : NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>orElseGet</strong> 可以结合函数式编程使用，无值则使用 Supplier 工厂返回</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOrElseGet</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;User&gt; optional = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional.orElseGet(</span><br><span class="line">            () -&gt; &#123;<span class="hljs-keyword">return</span> User.getSimpleUser();&#125;</span><br><span class="line">    ));</span><br><span class="line">    <span class="hljs-comment">// optional : User(name=simple, age=21, weight=null, sexy=male, height=null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>orElseThrow</strong> 结合函数式编程，无值则使用 Supplier 抛出异常</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOrElseThrow</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">       Optional&lt;User&gt; optional = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">           log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional.orElseThrow(</span><br><span class="line">                   () -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArithmeticException();&#125;</span><br><span class="line">           ));</span><br><span class="line">       &#125;<span class="hljs-keyword">catch</span> (ArithmeticException a)&#123;</span><br><span class="line">           log.info(<span class="hljs-string">"error"</span>); <span class="hljs-comment">// error</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOrElseThrow</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">       User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">       user.setName(<span class="hljs-string">"Kabin"</span>);</span><br><span class="line">       Optional&lt;User&gt; optional = Optional.ofNullable(user);</span><br><span class="line"><span class="hljs-comment">// optional : User(name=Kabin, age=null, weight=null, sexy=null, height=null)</span></span><br><span class="line">       <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">           log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional.orElseThrow(</span><br><span class="line">                   () -&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArithmeticException();&#125;</span><br><span class="line">           ));</span><br><span class="line">       &#125;<span class="hljs-keyword">catch</span> (ArithmeticException a)&#123;</span><br><span class="line">           log.info(<span class="hljs-string">"error"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>map</strong> 来结合 <strong>Function</strong> 实现 对值的处理</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-meta">@Test</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMap</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">      Optional&lt;String&gt; optional = Optional.ofNullable(<span class="hljs-string">"Hello"</span>);</span><br><span class="line"><span class="hljs-comment">// optional : Optional[Hello World!!!]</span></span><br><span class="line">      log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional.map(</span><br><span class="line">              p -&gt; &#123;<span class="hljs-keyword">return</span> p + <span class="hljs-string">" World!!!"</span>;&#125;</span><br><span class="line">      ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>flatMap</strong> 来结合 <strong>Function</strong>，不同的地方在于如果为 <strong>NULL</strong>,则返回空的 Optional</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFlatMap</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        Optional&lt;String&gt; optional = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-comment">// optional : Optional.empty</span></span><br><span class="line">        log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,optional.map(</span><br><span class="line">                p -&gt; &#123;<span class="hljs-keyword">return</span> p + <span class="hljs-string">" World!!!"</span>;&#125;</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <strong>filter</strong> 来结合 <strong>Predicate</strong> 完成过滤处理</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFilter</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Optional&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++)&#123;</span><br><span class="line">            Optional&lt;Integer&gt; optional = Optional.ofNullable(i);</span><br><span class="line">            list.add(optional);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.forEach(</span><br><span class="line">                p -&gt; log.info(<span class="hljs-string">"optional : &#123;&#125;"</span>,</span><br><span class="line">                p.filter(</span><br><span class="line">                        q -&gt; &#123;<span class="hljs-keyword">return</span> q &gt;=<span class="hljs-number">5</span>;&#125;</span><br><span class="line">                )</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.262</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional.empty</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.262</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional.empty</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.262</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional.empty</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional.empty</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional.empty</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional[<span class="hljs-number">5</span>]</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional[<span class="hljs-number">6</span>]</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional[<span class="hljs-number">7</span>]</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional[<span class="hljs-number">8</span>]</span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">16</span>:<span class="hljs-number">01</span>:<span class="hljs-number">24.263</span>  INFO <span class="hljs-number">11424</span> --- [           main] com.zyy.consumer.OptionalTest            : optional : Optional[<span class="hljs-number">9</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="最为有效的用途之一"><a href="#最为有效的用途之一" class="headerlink" title="最为有效的用途之一"></a>最为有效的用途之一</h3><blockquote><p>连环夺命 NULL 判定</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOptional</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 获取 User 类中的 name 并且转换为大写,进行 NULL 判定</span></span><br><span class="line">        Optional&lt;User&gt; optional = Optional.ofNullable(User.getSimpleUser());</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// name : SIMPLE</span></span><br><span class="line">        log.info(<span class="hljs-string">"name : &#123;&#125;"</span>,</span><br><span class="line">                optional.map(</span><br><span class="line">                        p -&gt; &#123;<span class="hljs-keyword">return</span> p.getName();&#125;</span><br><span class="line">                ).map(</span><br><span class="line">                        q -&gt; &#123;<span class="hljs-keyword">return</span> q.toUpperCase();&#125;</span><br><span class="line">                ).orElse(<span class="hljs-keyword">null</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOptional</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 获取 User 类中的 name 并且转换为大写,进行 NULL 判定</span></span><br><span class="line">        Optional&lt;User&gt; optional = Optional.ofNullable(<span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// name : null</span></span><br><span class="line">        log.info(<span class="hljs-string">"name : &#123;&#125;"</span>,</span><br><span class="line">                optional.map(</span><br><span class="line">                        p -&gt; &#123;<span class="hljs-keyword">return</span> p.getName();&#125;</span><br><span class="line">                ).map(</span><br><span class="line">                        q -&gt; &#123;<span class="hljs-keyword">return</span> q.toUpperCase();&#125;</span><br><span class="line">                ).orElse(<span class="hljs-keyword">null</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 最直观的对比，如果使用 if 来判定,如果判定 null 过程过多时，会写出一堆不雅观的代码，一堆的 if 嵌套</span></span><br><span class="line">  <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        User user = User.getSimpleUser();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(user != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(user.getName() != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> user.getName().toUpperCase();</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Stream-类"><a href="#Stream-类" class="headerlink" title="Stream 类"></a>Stream 类</h2><h3 id="详细参考"><a href="#详细参考" class="headerlink" title="详细参考"></a>详细参考</h3><blockquote><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p></blockquote><h3 id="关于-Stream"><a href="#关于-Stream" class="headerlink" title="关于 Stream"></a>关于 Stream</h3><blockquote><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p></blockquote><h3 id="与-Iterator-的不同"><a href="#与-Iterator-的不同" class="headerlink" title="与 Iterator 的不同"></a>与 Iterator 的不同</h3><blockquote><p>Stream 可以并行化操作，迭代器只能命令式地、串行化操作。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。</p></blockquote><h3 id="流管道的结构图"><a href="#流管道的结构图" class="headerlink" title="流管道的结构图"></a>流管道的结构图</h3><blockquote><p>对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）</p></blockquote><p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png" alt="å¾ 1.  æµç®¡é (Stream Pipeline) çææ"></p><hr><h3 id="生成-Stream-Source-的方法"><a href="#生成-Stream-Source-的方法" class="headerlink" title="生成 Stream Source 的方法"></a>生成 Stream Source 的方法</h3><ul><li>Collection 和 数组：<ul><li>Collection.stream()</li><li>Collection.parallelStream()</li><li>Arrays.stream(T array) or Stream.of()</li></ul></li><li>BufferedReader：<ul><li>java.io.BufferedReader.lines()</li></ul></li><li>静态工厂：<ul><li>java.util.stream.IntStream.range()</li><li>java.nio.file.Files.walk()</li></ul></li><li>自己构建：<ul><li>java.util.Spliterator</li></ul></li><li>其他：<ul><li>Random.ints()</li><li>BitSet.stream()</li><li>Pattern.splitAsStream(java.lang.CharSequence)</li><li>JarFile.stream()</li></ul></li></ul><hr><h3 id="流的操作类型"><a href="#流的操作类型" class="headerlink" title="流的操作类型"></a>流的操作类型</h3><ul><li><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li><li><strong>Terminal</strong>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li><li><strong>short-circuiting</strong>：<ul><li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li><li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li></ul></li></ul><hr><h3 id="Stream-的常见构造"><a href="#Stream-的常见构造" class="headerlink" title="Stream 的常见构造"></a>Stream 的常见构造</h3><blockquote><p>Stream 的 <strong>of</strong> 可以用于创建，默认是String 类型，如果要创建 Integer，Double，Long，请使用 <strong>IntStream</strong>, <strong>LongStream</strong> , <strong>DoubleStream</strong> ,避免使用泛型可以省去装箱操作，提高性能</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamConstruction</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Stream stream = Stream.of(<span class="hljs-string">"Ke"</span>,<span class="hljs-string">"Liang"</span>,<span class="hljs-string">"Zeng"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//        不用泛型，使用具体Stream,可以省去 装箱操作，提高性能</span></span><br><span class="line">        IntStream intStream = IntStream.of(<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">21</span>);</span><br><span class="line"></span><br><span class="line">        DoubleStream doubleStream = DoubleStream.of(<span class="hljs-number">62</span>,<span class="hljs-number">55</span>,<span class="hljs-number">63</span>);</span><br><span class="line"></span><br><span class="line">        LongStream longStream = LongStream.of(<span class="hljs-number">170</span>,<span class="hljs-number">175</span>,<span class="hljs-number">170</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过<strong>数组</strong>构造</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamConstructionByArray</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    String[] strings = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"Ke"</span>,<span class="hljs-string">"Liang"</span>,<span class="hljs-string">"Zeng"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Stream stream = Stream.of(strings);</span><br><span class="line">    </span><br><span class="line">    stream = Arrays.stream(strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过 <strong>Collection</strong> 来构造</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-meta">@Test</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamConstructionByList</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">          list.add(i);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="hljs-comment">// 待探讨，这里无法用 IntStream 接收</span></span><br><span class="line">      Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Stream-的操作"><a href="#Stream-的操作" class="headerlink" title="Stream 的操作"></a>Stream 的操作</h3><blockquote><p>现在，我们之前学的 Lambda 就起作用了，因为 Stream 的操作 几乎都是基于 java.utils.function 包来完成的</p></blockquote><hr><h3 id="Stream-的-Intermediate-操作"><a href="#Stream-的-Intermediate-操作" class="headerlink" title="Stream 的 Intermediate 操作"></a>Stream 的 Intermediate 操作</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">map</td><td style="text-align:center">执行Function操作，修改数值</td></tr><tr><td style="text-align:center">filter</td><td style="text-align:center">执行 Predicate操作，完成过滤</td></tr><tr><td style="text-align:center">distinct</td><td style="text-align:center">去重</td></tr><tr><td style="text-align:center">sorted</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">peek</td><td style="text-align:center">接收一个Consumer，做一些输出或外部处理</td></tr><tr><td style="text-align:center">limit</td><td style="text-align:center">限制Stream通过的个数</td></tr><tr><td style="text-align:center">skip</td><td style="text-align:center">跳过前几个</td></tr><tr><td style="text-align:center">parallel</td><td style="text-align:center">返回一个 parallel stream(转换为并行流)</td></tr><tr><td style="text-align:center">sequential</td><td style="text-align:center">返回一个 sequential stream(转换为串行流)</td></tr><tr><td style="text-align:center">unordered</td><td style="text-align:center">返回一个 unordered stream(转换为无序流)</td></tr></tbody></table><hr><h3 id="Stream-的-Terminal-操作"><a href="#Stream-的-Terminal-操作" class="headerlink" title="Stream 的 Terminal 操作"></a>Stream 的 Terminal 操作</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">forEach</td><td style="text-align:center">接收一个Consumer</td></tr><tr><td style="text-align:center">forEachOrdered</td><td style="text-align:center">并行时按顺序处理，区别于forEach</td></tr><tr><td style="text-align:center">toArray</td><td style="text-align:center">返回一个数组</td></tr><tr><td style="text-align:center">reduce</td><td style="text-align:center">接收一个BinaryOperator</td></tr><tr><td style="text-align:center">collect</td><td style="text-align:center">返回一个集合</td></tr><tr><td style="text-align:center">min</td><td style="text-align:center">聚合求最小值</td></tr><tr><td style="text-align:center">max</td><td style="text-align:center">聚合求最大值</td></tr><tr><td style="text-align:center">count</td><td style="text-align:center">聚合计数</td></tr><tr><td style="text-align:center">anyMatch</td><td style="text-align:center">接收一个 Predicate，有一个符合就是True</td></tr><tr><td style="text-align:center">allMatch</td><td style="text-align:center">接收一个 Predicate，所有符合是Ture</td></tr><tr><td style="text-align:center">noneMatch</td><td style="text-align:center">接收一个 Predicate，所有不符合是Ture</td></tr><tr><td style="text-align:center">findFirst</td><td style="text-align:center">获取第一个，返回 Optional，并行流中才和findAny有区别</td></tr><tr><td style="text-align:center">findAny</td><td style="text-align:center">随机返回一个，返回 Optional</td></tr><tr><td style="text-align:center">iterator</td><td style="text-align:center">转换成迭代器</td></tr></tbody></table><hr><h3 id="Stream-的-Short-circuiting-操作"><a href="#Stream-的-Short-circuiting-操作" class="headerlink" title="Stream 的 Short-circuiting 操作"></a>Stream 的 Short-circuiting 操作</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">anyMatch</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">allMatch</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">noneMatch</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">findFirst</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">findAny</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">limit</td><td style="text-align:center">同上</td></tr></tbody></table><hr><h3 id="开始表演"><a href="#开始表演" class="headerlink" title="开始表演"></a>开始表演</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote><p><strong><r> Stream<r> map(Function&lt;? super T, ? extends R&gt; mapper)</r></r></strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 将 流的value 全部转为大写，其中的 collect 是返回集合</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamMap</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        String[] strings = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"Ke"</span>,<span class="hljs-string">"Liang"</span>,<span class="hljs-string">"Zeng"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(strings);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = stream.map(</span><br><span class="line">                p -&gt; p.toUpperCase()</span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"list : &#123;&#125;"</span>,list); <span class="hljs-comment">// list : [KE, LIANG, ZENG]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><blockquote><p><strong>Stream<t> filter(Predicate&lt;? super T&gt; predicate)</t></strong> 执行过滤操作</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 将 流的value 小于等于5 的都过滤</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamFilter</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        list =  stream.filter(</span><br><span class="line">                p -&gt; p &gt;<span class="hljs-number">5</span></span><br><span class="line">        ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"list : &#123;&#125;"</span>,list); <span class="hljs-comment">// list : [6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><blockquote><p><strong>Stream<t> distinct()</t></strong> 去重</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 去重</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamDistinct</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">3</span> ; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"before ： &#123;&#125;"</span>,list); <span class="hljs-comment">// before ： [0, 1, 2, 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">    list = stream.distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="hljs-string">"after : &#123;&#125;"</span>,list); <span class="hljs-comment">// after : [0, 1, 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><blockquote><p><strong>Stream<t> sorted()</t></strong> 和 <strong>Stream<t> sorted(Comparator&lt;? super T&gt; comparator)</t></strong></p></blockquote> <figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamSorted</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">21</span>);</span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 升序排列</span></span><br><span class="line">       List&lt;Integer&gt; integerList =  stream.sorted().collect(Collectors.toList());</span><br><span class="line">       </span><br><span class="line">       log.info(<span class="hljs-string">"integerList : &#123;&#125;"</span>,integerList); <span class="hljs-comment">// integerList : [21, 21, 22]</span></span><br><span class="line"></span><br><span class="line">       List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i++)&#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Stream&lt;Integer&gt; streamSecond  =  list.stream();</span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 自定义 CompareTo 完成倒序</span></span><br><span class="line">       list = streamSecond.sorted( (a,b) -&gt; a &gt;= b ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span> ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       log.info(<span class="hljs-string">"list : &#123;&#125;"</span>,list); <span class="hljs-comment">// list : [4, 3, 2, 1, 0]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><blockquote><p><strong>Stream<t> peek(Consumer&lt;? super T&gt; action)</t></strong> </p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamPeek</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">       Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">22</span>,<span class="hljs-number">21</span>,<span class="hljs-number">21</span>);</span><br><span class="line"><span class="hljs-comment">// 一个 Stream 必须执行 Terminal 操作，否则  Intermediate 不起作用</span></span><br><span class="line">       stream.peek(</span><br><span class="line">               p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p)</span><br><span class="line">       ).count();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">   2018-12-16 17:52:25.639  INFO 7988 --- [           main] com.zyy.consumer.StreamTest              : number : 22</span></span><br><span class="line"><span class="hljs-comment">2018-12-16 17:52:25.640  INFO 7988 --- [           main] com.zyy.consumer.StreamTest              : number : 21</span></span><br><span class="line"><span class="hljs-comment">2018-12-16 17:52:25.640  INFO 7988 --- [           main] com.zyy.consumer.StreamTest              : number : 21</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><blockquote><p><strong>Stream<t> limit(long maxSize)</t></strong> </p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-comment">// 只需要 3 个元素就足够了</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamLimit</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">       list = stream.limit(<span class="hljs-number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">       log.info(<span class="hljs-string">"list : &#123;&#125;"</span>,list); <span class="hljs-comment">// list : [0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><blockquote><p><strong>Stream<t> skip(long n)</t></strong> </p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 跳过前三个</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamSkip</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        list = stream.skip(<span class="hljs-number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"list : &#123;&#125;"</span>,list); <span class="hljs-comment">// list : [3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="parallel"><a href="#parallel" class="headerlink" title="parallel"></a>parallel</h4><blockquote><p><strong>S parallel()</strong> 转换为并行流</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamParallel</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        stream.parallel().forEach(</span><br><span class="line">                p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36.558</span>  INFO <span class="hljs-number">15640</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36.558</span>  INFO <span class="hljs-number">15640</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36.560</span>  INFO <span class="hljs-number">15640</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36.561</span>  INFO <span class="hljs-number">15640</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36.558</span>  INFO <span class="hljs-number">15640</span> --- [onPool-worker-<span class="hljs-number">1</span>] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><hr><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><blockquote><p><strong>void forEach(Consumer&lt;? super T&gt; action)</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamForEach</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        stream.limit(<span class="hljs-number">3</span>).forEach(</span><br><span class="line">                p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22.170</span>  INFO <span class="hljs-number">14328</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22.172</span>  INFO <span class="hljs-number">14328</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22.172</span>  INFO <span class="hljs-number">14328</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><h4 id="forEachOrdered"><a href="#forEachOrdered" class="headerlink" title="forEachOrdered"></a>forEachOrdered</h4><blockquote><p><strong>void forEachOrdered(Consumer&lt;? super T&gt; action)</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-comment">// 并行流也会按顺序执行，不过会牺牲速度</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamForEachOrdered</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">5</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        stream.parallel().forEachOrdered(</span><br><span class="line">                p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00.344</span>  INFO <span class="hljs-number">17744</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00.344</span>  INFO <span class="hljs-number">17744</span> --- [onPool-worker-<span class="hljs-number">1</span>] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00.345</span>  INFO <span class="hljs-number">17744</span> --- [onPool-worker-<span class="hljs-number">1</span>] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00.345</span>  INFO <span class="hljs-number">17744</span> --- [onPool-worker-<span class="hljs-number">1</span>] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00.345</span>  INFO <span class="hljs-number">17744</span> --- [onPool-worker-<span class="hljs-number">1</span>] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><h4 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h4><blockquote><p><strong>Object[] toArray()</strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamToArray</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        Object[] objects = stream.limit(<span class="hljs-number">4</span>).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(Object o : objects)&#123;</span><br><span class="line">            log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">25</span>:<span class="hljs-number">40.322</span>  INFO <span class="hljs-number">5544</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">25</span>:<span class="hljs-number">40.322</span>  INFO <span class="hljs-number">5544</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">25</span>:<span class="hljs-number">40.322</span>  INFO <span class="hljs-number">5544</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">16</span> <span class="hljs-number">18</span>:<span class="hljs-number">25</span>:<span class="hljs-number">40.322</span>  INFO <span class="hljs-number">5544</span> --- [           main] com.zyy.consumer.StreamTest              : number : <span class="hljs-number">3</span></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><blockquote><p><strong>Optional<t> reduce(BinaryOperator<t> accumulator)</t></t></strong></p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 求和</span></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamReduce</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">        Optional&lt;Integer&gt; optional = stream.reduce(</span><br><span class="line">                (a,b) -&gt; a + b</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        log.info(<span class="hljs-string">"sum : &#123;&#125;"</span>,optional.get()); <span class="hljs-comment">//  sum : 45</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 测试三种 match</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStreamMatch</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">          list.add(i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Stream&lt;Integer&gt; stream  =  list.stream();</span><br><span class="line"></span><br><span class="line">      log.info(<span class="hljs-string">"AnyFirst : &#123;&#125;"</span>,stream.anyMatch(</span><br><span class="line">              p -&gt; p &gt;<span class="hljs-number">5</span></span><br><span class="line">      )); <span class="hljs-comment">// true</span></span><br><span class="line">      stream  =  list.stream();</span><br><span class="line">      log.info(<span class="hljs-string">"AnySecond : &#123;&#125;"</span>,stream.anyMatch(</span><br><span class="line">              p -&gt; p &gt;<span class="hljs-number">15</span></span><br><span class="line">      )); <span class="hljs-comment">// false</span></span><br><span class="line">      stream  =  list.stream();</span><br><span class="line">      log.info(<span class="hljs-string">"AllFirst : &#123;&#125;"</span>,stream.allMatch(</span><br><span class="line">              p -&gt; p &gt;=<span class="hljs-number">0</span></span><br><span class="line">      )); <span class="hljs-comment">// true</span></span><br><span class="line">      stream  =  list.stream();</span><br><span class="line">      log.info(<span class="hljs-string">"AllSecond : &#123;&#125;"</span>,stream.allMatch(</span><br><span class="line">              p -&gt; p &gt;<span class="hljs-number">5</span></span><br><span class="line">      )); <span class="hljs-comment">// false</span></span><br><span class="line">      stream  =  list.stream();</span><br><span class="line">      log.info(<span class="hljs-string">"NoneFirst : &#123;&#125;"</span>,stream.noneMatch(</span><br><span class="line">              p -&gt; p &gt; <span class="hljs-number">10</span></span><br><span class="line">      )); <span class="hljs-comment">// true</span></span><br><span class="line">      stream  =  list.stream();</span><br><span class="line">      log.info(<span class="hljs-string">"NoneSecond : &#123;&#125;"</span>,stream.noneMatch(</span><br><span class="line">              p -&gt; p &gt; <span class="hljs-number">5</span></span><br><span class="line">      )); <span class="hljs-comment">// false</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="JDK8-中-的使用"><a href="#JDK8-中-的使用" class="headerlink" title="JDK8 中 :: 的使用"></a>JDK8 中 :: 的使用</h2><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote><p>就是将 Stream 的参数传入一个方法中执行</p></blockquote><p>要求</p><ul><li>一个类的静态方法</li><li>参数需要一致</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// LambdaTest 类</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLambdaPredicate</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">new</span> FirstLambda().checkNumberBigger(list,</span><br><span class="line">                p -&gt; p &gt; <span class="hljs-number">5</span>,</span><br><span class="line">                LambdaTest::testDoubleQuote); <span class="hljs-comment">// 将Stream 传入 LambdaTest.testDoubleQuote</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">new</span> FirstLambda().checkNumberBigger(list,</span><br><span class="line">                p -&gt; p &gt; <span class="hljs-number">5</span>,</span><br><span class="line">                p -&gt; log.info(<span class="hljs-string">"number : &#123;&#125;"</span>,p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDoubleQuote</span><span class="hljs-params">(Integer s)</span></span>&#123;</span><br><span class="line">        log.info(<span class="hljs-string">"element : &#123;&#125;"</span>,s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;h3 id=&quot;Lambda-表达式介绍&quot;&gt;&lt;a href=&quot;#Lambda-表达式介绍&quot; class=&quot;headerlink&quot; title=&quot;Lambda 表达式介绍&quot;&gt;&lt;/a&gt;Lambda 表达式介绍&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;是没有声明的方法，也即没有访问修饰符、返回值声明和名字。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JAVA" scheme="https://jdsheng.cn/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://jdsheng.cn/tags/Java/"/>
    
      <category term="Java入门" scheme="https://jdsheng.cn/tags/Java%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue常见问题及解决方法（二）</title>
    <link href="https://jdsheng.cn/2019/10/22/vue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/10/22/vue常见问题及解决方法（二）/</id>
    <published>2019-10-22T14:00:34.978Z</published>
    <updated>2019-10-22T14:13:41.778Z</updated>
    
    <content type="html"><![CDATA[<p>这里给大家分享一下vue中遇到的一些问题和解决技巧，希望对大家有用处。（话不多说上代码）<a id="more"></a></p><h5 id="1-vue路由拦截浏览器后退实现表单保存类似需求（为了防止用户突然离开，没有保存已输入的信息。）"><a href="#1-vue路由拦截浏览器后退实现表单保存类似需求（为了防止用户突然离开，没有保存已输入的信息。）" class="headerlink" title="1.vue路由拦截浏览器后退实现表单保存类似需求（为了防止用户突然离开，没有保存已输入的信息。）"></a>1.vue路由拦截浏览器后退实现表单保存类似需求（为了防止用户突然离开，没有保存已输入的信息。）</h5><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在路由组件中：</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;</span><br><span class="line"> <span class="hljs-keyword">if</span>(用户已经输入信息)&#123;</span><br><span class="line"> <span class="hljs-comment">//出现弹窗提醒保存表单，或者自动后台为其保存</span></span><br><span class="line">  </span><br><span class="line"> &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line"> next(<span class="hljs-literal">true</span>);<span class="hljs-comment">//用户离开</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="2-路由懒加载写法"><a href="#2-路由懒加载写法" class="headerlink" title="2.路由懒加载写法:"></a>2.路由懒加载写法:</h5><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 我所采用的方法，个人感觉比较简洁一些，少了一步引入赋值。</span></span><br><span class="line"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;</span><br><span class="line"> routes: [</span><br><span class="line"> path: <span class="hljs-string">'/app'</span>,</span><br><span class="line"> component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./app'</span>), <span class="hljs-comment">// 引入组件</span></span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-comment">// Vue路由文档的写法:</span></span><br><span class="line"><span class="hljs-keyword">const</span> app = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./app.vue'</span>) <span class="hljs-comment">// 引入组件</span></span><br><span class="line"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;</span><br><span class="line"> routes: [</span><br><span class="line"> &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">'/app'</span>, <span class="hljs-attr">component</span>: app &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="3-路由的项目启动页和404页面"><a href="#3-路由的项目启动页和404页面" class="headerlink" title="3.路由的项目启动页和404页面"></a>3.路由的项目启动页和404页面</h5><p>一般项目都会设置这个，如果默认进入地址会跳到login页面，如果你输入的是一个没有用的路由或者是空路由会跳转到notFind页面（你自己设置的404页面）</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;</span><br><span class="line">routes: [</span><br><span class="line"> &#123;</span><br><span class="line">  path: <span class="hljs-string">'/'</span>, <span class="hljs-comment">// 项目启动页</span></span><br><span class="line">  redirect:<span class="hljs-string">'/login'</span> <span class="hljs-comment">// 重定向到下方声明的路由 </span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  path: <span class="hljs-string">'*'</span>, <span class="hljs-comment">// 404 页面 </span></span><br><span class="line">  component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./notFind'</span>) <span class="hljs-comment">// 或者使用component也可以的</span></span><br><span class="line"> &#125;,</span><br><span class="line"> ]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h5 id="4-setInterval路由跳转继续运行并没有销毁问题"><a href="#4-setInterval路由跳转继续运行并没有销毁问题" class="headerlink" title="4.setInterval路由跳转继续运行并没有销毁问题"></a>4.setInterval路由跳转继续运行并没有销毁问题</h5><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//方法一：</span></span><br><span class="line">beforeDestroy()&#123;</span><br><span class="line">  <span class="hljs-comment">//我通常是把setInterval()定时器赋值给this实例，然后就可以像下面这么暂停。</span></span><br><span class="line">clearInterval(<span class="hljs-keyword">this</span>.intervalid);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//方法二：</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, () =&gt; &#123;    <span class="hljs-comment">//清理定时器</span></span><br><span class="line">clearTimeout(<span class="hljs-keyword">this</span>.timeout);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="5-setTimeout-setInterval-this指向改变，无法用this访问VUe实例"><a href="#5-setTimeout-setInterval-this指向改变，无法用this访问VUe实例" class="headerlink" title="5.setTimeout/setInterval this指向改变，无法用this访问VUe实例"></a>5.setTimeout/setInterval this指向改变，无法用this访问VUe实例</h5><p>这个地方大家的默认方法肯定是:<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//使用变量访问this实例</span></span><br><span class="line"><span class="hljs-keyword">let</span> self=<span class="hljs-keyword">this</span>;</span><br><span class="line"> setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line">  <span class="hljs-built_in">console</span>.log(self);<span class="hljs-comment">//使用self变量访问this实例</span></span><br><span class="line"> &#125;,<span class="hljs-number">1000</span>);</span><br></pre></td></tr></table></figure></p><p>其实这个地方我们可以用箭头函数，因为箭头函数会改变this的指向，而指向的刚好是自己的父级this，所以我们可以这样用：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//箭头函数访问this实例 因为箭头函数本身没有绑定this</span></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;, <span class="hljs-number">500</span>);</span><br></pre></td></tr></table></figure><p>这样我们的this就是指向我们的vue实例了。</p><h5 id="6-Vue-数组-对象更新-视图不更新"><a href="#6-Vue-数组-对象更新-视图不更新" class="headerlink" title="6.Vue 数组/对象更新 视图不更新"></a>6.Vue 数组/对象更新 视图不更新</h5><p><strong>方法一：</strong><br>直接使用最简单也是最有效的方法，深拷贝对象或者数组，视图会进行更新，不过会有一个缺点，深拷贝后的数组或者对象不是原来的那个数组或者对象，是你现在改变了之后的值。</p><p>上代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Obj =&gt; 你的对象或数组</span></span><br><span class="line"><span class="hljs-keyword">this</span>.Obj=<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.Obj));</span><br></pre></td></tr></table></figure><p>先进行转字符串，再转回对象，这个就进行了一个拷贝的过程，会触发视图的改变，同时也进行了一个数组的替换，有利有弊。</p><p><strong>方法二：</strong><br>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.$set(<span class="hljs-keyword">this</span>.arr, <span class="hljs-number">0</span>, <span class="hljs-string">"OBKoro1"</span>); <span class="hljs-comment">// 改变数组</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$set(<span class="hljs-keyword">this</span>.obj, <span class="hljs-string">"c"</span>, <span class="hljs-string">"OBKoro1"</span>); <span class="hljs-comment">// 改变对象</span></span><br></pre></td></tr></table></figure></p><p>这个是vue专门为改变不了数组设定的一个方法，使用也很简单（如果还是不懂请参考vue文档）</p><h5 id="7-深度watch与watch立即触发回调"><a href="#7-深度watch与watch立即触发回调" class="headerlink" title="7.深度watch与watch立即触发回调"></a>7.深度watch与watch立即触发回调</h5><p>watch很多人都在用，但是这watch中的这两个选项deep、immediate，或许不是很多人都知道，我猜。</p><p>选项：deep</p><p>在选项参数中指定 deep: true，可以监听对象中属性的变化。</p><p>选项：immediate</p><p>在选项参数中指定 immediate: true, 代表如果在 wacth 里声明了 step之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">obj: &#123;</span><br><span class="line">  handler(val, oldVal) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'属性发生变化触发这个回调'</span>,val, oldVal);</span><br><span class="line">&#125;,</span><br><span class="line">  deep: <span class="hljs-literal">true</span> <span class="hljs-comment">// 监听这个对象中的每一个属性变化</span></span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> step: &#123; <span class="hljs-comment">// 属性</span></span><br><span class="line">  <span class="hljs-comment">//watch</span></span><br><span class="line">  handler(val, oldVal) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"默认触发一次"</span>, val, oldVal);</span><br><span class="line">  &#125;,</span><br><span class="line">  immediate: <span class="hljs-literal">true</span> <span class="hljs-comment">// 立即触发一次</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里给大家分享一下vue中遇到的一些问题和解决技巧，希望对大家有用处。（话不多说上代码）&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="https://jdsheng.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Echarts 图表填（天）坑篇</title>
    <link href="https://jdsheng.cn/2019/10/22/Echarts%20%E5%9B%BE%E8%A1%A8%E5%A1%AB%EF%BC%88%E5%A4%A9%EF%BC%89%E5%9D%91%E7%AF%87/"/>
    <id>https://jdsheng.cn/2019/10/22/Echarts 图表填（天）坑篇/</id>
    <published>2019-10-22T14:00:26.591Z</published>
    <updated>2019-10-22T14:06:47.901Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-echarts-图表大小随窗口变动而自适应变动（无需刷新浏览器调整）"><a href="#1-echarts-图表大小随窗口变动而自适应变动（无需刷新浏览器调整）" class="headerlink" title="1.echarts 图表大小随窗口变动而自适应变动（无需刷新浏览器调整）"></a>1.echarts 图表大小随窗口变动而自适应变动（无需刷新浏览器调整）</h4><p><strong>问题：</strong><a id="more"></a></p><p>这是做过echarts图表的同学大部分都会遇到的坑，在应用echarts进行统计图制作时候会遇到这样的问题，进入渲染页面统计图比例显示ok，但是当主动调整浏览器大小时候，统计图比例并没有随窗口大小改变而自动调整到最佳视觉效果，比如下图，缩小窗口就会出现溢出的情况。<img src="https://img-blog.csdn.net/20180526121631555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzgyMzgw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p><strong>原因分析：</strong></p><p>echarts的图表实例事实上并没有主动的去绑定resize()事件，就是说显示区域大小发生改变内部并不知道，当你需要去做一些自适应的效果的时候，需要使用方主动的去绑定这个事件达到自适应的效果，常见如window.onresize = myChart.resize。</p><p><strong>填坑：</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'main'</span>));</span><br><span class="line"><span class="hljs-comment">// 指定图表的配置项和数据</span></span><br><span class="line"><span class="hljs-keyword">var</span> option = &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: <span class="hljs-string">'ECharts 入门示例'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;&#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data:[<span class="hljs-string">'销量'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        data: [<span class="hljs-string">"衬衫"</span>,<span class="hljs-string">"羊毛衫"</span>,<span class="hljs-string">"雪纺衫"</span>,<span class="hljs-string">"裤子"</span>,<span class="hljs-string">"高跟鞋"</span>,<span class="hljs-string">"袜子"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;&#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name: <span class="hljs-string">'销量'</span>,</span><br><span class="line">        type: <span class="hljs-string">'bar'</span>,</span><br><span class="line">        data: [<span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 使用刚指定的配置项和数据显示图表。</span></span><br><span class="line">myChart.setOption(option);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//根据窗口的大小变动图表 --- 重点</span></span><br><span class="line"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    myChart.resize();</span><br><span class="line">    <span class="hljs-comment">//myChart1.resize();    //若有多个图表变动，可多写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-解决Vue-Echarts的内存泄漏问题"><a href="#2-解决Vue-Echarts的内存泄漏问题" class="headerlink" title="2.解决Vue+Echarts的内存泄漏问题"></a>2.解决Vue+Echarts的内存泄漏问题</h4><p><strong>问题：</strong></p><p>当页面存在echarts图表的时候，跳转路由到其他页面，然后来回切换的时候，打开浏览器调试工具，会发现页面占用内存持续增加，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLm9rY29kZS5uZXQvRkNFRTVDRUZGNTVCOTQyNzJEMjI0NjlGRjIxODhGNzEucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>前几次切换页面可以正常生成图表，但是当切换多次以后，页面会出现空白或浏览器奔溃的情况，页面也不会报错并且无明显提示。很明显是发生了内存泄漏问题。</p><p><strong>原因分析：</strong></p><p>先说一个知识点：</p><blockquote><p>js中的内存垃圾回收机制：垃圾回收器会定期扫描内存，当某个内存中的值被引用为零时就会将其回收。当前变量已经使用完毕但依然被引用，导致垃圾回收器无法回收这就造成了内存泄漏。传统页面每次跳转都会释放内存，所以并不是特别明显。<br>Web App 与 传统Web的区别，因为Web App是单页面应用页面通过路由跳转不会刷新页面，导致内存泄漏不断堆积，导致页面卡顿。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jbi52dWVqcy5vcmcvaW1hZ2VzL21lbW9yeS1sZWFrLWV4YW1wbGUucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>原因就是echarts图表初始化时引用了DOM对象，js不回对此自动回收，切换生成echarts时需要用到一部分内存，重复切换页面，之前生成的图表内存并没有进行清空，因此一直切换内存也一直叠加，最终导致内存溢出。</p><p><strong>填坑：</strong></p><p>1.在生成echarts之前进行判断，dom不存在时就不初始化echarts</p><p>2.去掉重复初始化echarts，这个主要就是在不需要使用时销毁实例。那么很自然想到官方API，查阅echarts官方API果然发现有这个方法：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLm9rY29kZS5uZXQvODc1NjY0ODIzRDIwMTkyMkY3RjQ2RDAxNzNDOERBMkIucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>代码示例：</p><p>（1）页面容器：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"chart-main"</span>&gt;</span><br><span class="line">    &lt;div ref=<span class="hljs-string">"dom"</span> :style=<span class="hljs-string">"chartStyle"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure><p>（2）初始化echarts方法：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">initChart() &#123;</span><br><span class="line">      <span class="hljs-comment">//-dom 不存在时不画</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.$refs.dom) &#123;</span><br><span class="line">          <span class="hljs-keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-comment">//去掉重复初始化</span></span><br><span class="line">      <span class="hljs-keyword">this</span>.myChart = echarts.getInstanceByDom(<span class="hljs-keyword">this</span>.$refs.dom);</span><br><span class="line">      <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.myChart)&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.myChart = echarts.init(<span class="hljs-keyword">this</span>.$refs.dom);</span><br><span class="line">        <span class="hljs-keyword">this</span>.$once(<span class="hljs-string">'hook:beforeDestroy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">          echarts.dispose(<span class="hljs-keyword">this</span>.myChart)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>没修改之前的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initChart() &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.myChart = echarts.init(<span class="hljs-keyword">this</span>.$refs.dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-echarts-图表大小随窗口变动而自适应变动（无需刷新浏览器调整）&quot;&gt;&lt;a href=&quot;#1-echarts-图表大小随窗口变动而自适应变动（无需刷新浏览器调整）&quot; class=&quot;headerlink&quot; title=&quot;1.echarts 图表大小随窗口变动而自适应变动（无需刷新浏览器调整）&quot;&gt;&lt;/a&gt;1.echarts 图表大小随窗口变动而自适应变动（无需刷新浏览器调整）&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="echarts" scheme="https://jdsheng.cn/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>Vue 组件间的通信（六种）</title>
    <link href="https://jdsheng.cn/2019/10/22/Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%88%E5%85%AD%E7%A7%8D%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/10/22/Vue 组件间的通信（六种）/</id>
    <published>2019-10-22T14:00:12.135Z</published>
    <updated>2019-10-22T14:13:29.773Z</updated>
    
    <content type="html"><![CDATA[<p>组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。<a id="more"></a>一般来说，组件可以有以下几种关系<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzE3LzE2YWMzNWJmNzA1MzAzMTU?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p><p>针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。</p><p>本文总结了vue组件间通信的几种方式，如<code>props</code>、<code>$emit/$on</code>、<code>vuex</code>、<code>$parent / $children</code>、<code>$attrs/$listeners</code>和<code>provide/inject</code>，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。</p><h4 id="方案一：props-emit"><a href="#方案一：props-emit" class="headerlink" title="方案一：props/$emit"></a>方案一：<code>props/$emit</code></h4><p>父组件A通过<code>props</code>的方式向子组件B传递，B to A 通过在 B 组件中 <code>$emit</code>, A 组件中 v-on 的方式实现。</p><p><strong>1.父组件向子组件传值</strong></p><p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 <code>users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</code></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//App.vue父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="hljs-string">"app"</span>&gt;</span><br><span class="line">    &lt;users v-bind:users=<span class="hljs-string">"users"</span>&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span></span><span class="hljs-comment">//前者自定义名称便于子组件调用，后者要传递数据名</span></span><br><span class="line">  &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="hljs-keyword">import</span> Users <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/Users"</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  name: <span class="hljs-string">'App'</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span>&#123;</span><br><span class="line">      users:[<span class="hljs-string">"Henry"</span>,<span class="hljs-string">"Bucky"</span>,<span class="hljs-string">"Emily"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    <span class="hljs-string">"users"</span>:Users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//users子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"hello"</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"user in users"</span>&gt;&#123;&#123;user&#125;&#125;&lt;<span class="hljs-regexp">/li&gt;/</span><span class="hljs-regexp">/遍历传递过来的值，然后呈现到页面</span></span><br><span class="line"><span class="hljs-regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  name: <span class="hljs-string">'HelloWorld'</span>,</span><br><span class="line">  props:&#123;</span><br><span class="line">    users:&#123;           <span class="hljs-comment">//这个就是父组件中子标签自定义名字</span></span><br><span class="line">      type:<span class="hljs-built_in">Array</span>,</span><br><span class="line">      required:<span class="hljs-literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="hljs-regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</p><p><strong>2.子组件向父组件传值（通过事件形式）</strong></p><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzE3LzE2YWMzNWJmNzBhYzJkNTE?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1 @click=<span class="hljs-string">"changeTitle"</span>&gt;&#123;&#123;title&#125;&#125;&lt;<span class="hljs-regexp">/h1&gt;/</span><span class="hljs-regexp">/绑定一个点击事件</span></span><br><span class="line"><span class="hljs-regexp">  &lt;/</span>header&gt;</span><br><span class="line">&lt;<span class="hljs-regexp">/template&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;script&gt;</span></span><br><span class="line"><span class="hljs-regexp">export default &#123;</span></span><br><span class="line"><span class="hljs-regexp">  name: 'app-header',</span></span><br><span class="line"><span class="hljs-regexp">  data() &#123;</span></span><br><span class="line"><span class="hljs-regexp">    return &#123;</span></span><br><span class="line"><span class="hljs-regexp">      title:"Vue.js Demo"</span></span><br><span class="line"><span class="hljs-regexp">    &#125;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;,</span></span><br><span class="line"><span class="hljs-regexp">  methods:&#123;</span></span><br><span class="line"><span class="hljs-regexp">    changeTitle() &#123;</span></span><br><span class="line"><span class="hljs-regexp">      this.$emit("titleChanged","子向父组件传值");/</span><span class="hljs-regexp">/自定义事件  传递值“子向父组件传值”</span></span><br><span class="line"><span class="hljs-regexp">    &#125;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="hljs-string">"app"</span>&gt;</span><br><span class="line">    &lt;app-header v-on:titleChanged=<span class="hljs-string">"updateTitle"</span> &gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">app-header</span>&gt;</span>//与子组件titleChanged自定义事件保持一致</span></span><br><span class="line"><span class="hljs-xml">   // updateTitle($event)接受传递过来的文字</span></span><br><span class="line"><span class="hljs-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="hljs-regexp">/template&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;script&gt;</span></span><br><span class="line"><span class="hljs-regexp">import Header from "./</span>components/Header<span class="hljs-string">"</span></span><br><span class="line"><span class="hljs-string">export default &#123;</span></span><br><span class="line"><span class="hljs-string">  name: 'App',</span></span><br><span class="line"><span class="hljs-string">  data()&#123;</span></span><br><span class="line"><span class="hljs-string">    return&#123;</span></span><br><span class="line"><span class="hljs-string">      title:"</span>传递的是一个值<span class="hljs-string">"</span></span><br><span class="line"><span class="hljs-string">    &#125;</span></span><br><span class="line"><span class="hljs-string">  &#125;,</span></span><br><span class="line"><span class="hljs-string">  methods:&#123;</span></span><br><span class="line"><span class="hljs-string">    updateTitle(e)&#123;   //声明这个函数</span></span><br><span class="line"><span class="hljs-string">      this.title = e;</span></span><br><span class="line"><span class="hljs-string">    &#125;</span></span><br><span class="line"><span class="hljs-string">  &#125;,</span></span><br><span class="line"><span class="hljs-string">  components:&#123;</span></span><br><span class="line"><span class="hljs-string">   "</span>app-header<span class="hljs-string">":Header,</span></span><br><span class="line"><span class="hljs-string">  &#125;</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</p><h4 id="方案二：-emit-on"><a href="#方案二：-emit-on" class="headerlink" title="方案二：$emit/$on"></a>方案二：<code>$emit/$on</code></h4><p>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p><p><strong>1.具体实现方式：</strong><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> Event=<span class="hljs-keyword">new</span> Vue();</span><br><span class="line">Event.$emit(事件名,数据);</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>2.举个例子：</strong></p><p>假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="hljs-string">"itany"</span>&gt;</span><br><span class="line">&lt;my-a&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">my-a</span>&gt;</span></span></span><br><span class="line">&lt;my-b&gt;&lt;/my-b&gt;</span><br><span class="line">&lt;my-c&gt;&lt;/my-c&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id="a"&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click="send"&gt;将数据发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id="b"&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click="send"&gt;将数组发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id="c"&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Event = new Vue();//定义一个空的Vue实例</span><br><span class="line">var A = &#123;</span><br><span class="line">template: '#a',</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: 'tom'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  send() &#123;</span><br><span class="line">    Event.$emit('data-a', this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var B = &#123;</span><br><span class="line">template: '#b',</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    age: 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  send() &#123;</span><br><span class="line">    Event.$emit('data-b', this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var C = &#123;</span><br><span class="line">template: '#c',</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: '',</span><br><span class="line">    age: ""</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;//在模板编译完成后执行</span><br><span class="line"> Event.$on('data-a',name =&gt; &#123;</span><br><span class="line">     this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event</span><br><span class="line"> &#125;)</span><br><span class="line"> Event.$on('data-b',age =&gt; &#123;</span><br><span class="line">     this.age = age;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: '#itany',</span><br><span class="line">components: &#123;</span><br><span class="line">  'my-a': A,</span><br><span class="line">  'my-b': B,</span><br><span class="line">  'my-c': C</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzE3LzE2YWMzNWJmNzBiMDA1MDc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p><code>$on</code> 监听了自定义事件 <code>data-a</code>和<code>data-b</code>，因为有时不确定何时会触发事件，一般会在 <code>mounted</code> 或 <code>created</code> 钩子中来监听。</p><h4 id="方案三：vuex"><a href="#方案三：vuex" class="headerlink" title="方案三：vuex"></a>方案三：vuex</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzE3LzE2YWMzNWJmNzBlZjhlYjE?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p><strong>1.简要介绍Vuex原理</strong></p><p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。</p><p>而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p><p><strong>2.简要介绍各模块在流程中的功能：</strong></p><ul><li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行<code>dispatch</code>方法触发对应action进行回应。<ul><li>dispatch：操作行为触发方法，是唯一能执行<code>action</code>的方法。</li><li>actions：操作行为处理模块,由组件中的<code>$store.dispatch</code>(‘action 名称’, data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他<code>action</code>以及提交<code>mutation</code>的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li>mutations：状态改变操作方法，由actions中的commit(‘mutation 名称’)来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul></li></ul><p><strong>3.Vuex与localStorage</strong></p><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。<strong>但是并不会保存起来，刷新之后就回到了初始状态</strong>，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> defaultCity = <span class="hljs-string">"上海"</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (!defaultCity)&#123;</span><br><span class="line">    defaultCity = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">'defaultCity'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="hljs-keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity(state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">'defaultCity'</span>, <span class="hljs-built_in">JSON</span>.stringify(state.city));</span><br><span class="line">      <span class="hljs-comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span></span><br><span class="line">      &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">JSON</span>.stringify(state.subscribeList);   <span class="hljs-comment">// array -&gt; string</span></span><br><span class="line"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">window</span>.localStorage.getItem(<span class="hljs-string">"subscribeList"</span>));    <span class="hljs-comment">// string -&gt; array</span></span><br></pre></td></tr></table></figure><h4 id="方案四：-attrs-listeners"><a href="#方案四：-attrs-listeners" class="headerlink" title="方案四：$attrs/$listeners"></a>方案四：<code>$attrs/$listeners</code></h4><p><strong>1.简介</strong></p><p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-<code>$attrs/$listeners</code></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li></ul><p><strong>2.例子</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// index.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;浪里行舟&lt;<span class="hljs-regexp">/h2&gt;</span></span><br><span class="line"><span class="hljs-regexp">    &lt;child-com1</span></span><br><span class="line"><span class="hljs-regexp">      :foo="foo"</span></span><br><span class="line"><span class="hljs-regexp">      :boo="boo"</span></span><br><span class="line"><span class="hljs-regexp">      :coo="coo"</span></span><br><span class="line"><span class="hljs-regexp">      :doo="doo"</span></span><br><span class="line"><span class="hljs-regexp">      title="前端工匠"</span></span><br><span class="line"><span class="hljs-regexp">    &gt;&lt;/</span>child-com1&gt;</span><br><span class="line">  &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="hljs-keyword">const</span> childCom1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./childCom1.vue"</span>);</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  components: &#123; childCom1 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="hljs-string">"Javascript"</span>,</span><br><span class="line">      boo: <span class="hljs-string">"Html"</span>,</span><br><span class="line">      coo: <span class="hljs-string">"CSS"</span>,</span><br><span class="line">      doo: <span class="hljs-string">"Vue"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="hljs-regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// childCom1.vue</span></span><br><span class="line">&lt;template <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"border"</span>&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;<span class="hljs-regexp">/p&gt;</span></span><br><span class="line"><span class="hljs-regexp">    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;child-com2 v-bind=<span class="hljs-string">"$attrs"</span>&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child-com2</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="hljs-regexp">/template&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;script&gt;</span></span><br><span class="line"><span class="hljs-regexp">const childCom2 = () =&gt; import("./</span>childCom2.vue<span class="hljs-string">");</span></span><br><span class="line"><span class="hljs-string">export default &#123;</span></span><br><span class="line"><span class="hljs-string">  components: &#123;</span></span><br><span class="line"><span class="hljs-string">    childCom2</span></span><br><span class="line"><span class="hljs-string">  &#125;,</span></span><br><span class="line"><span class="hljs-string">  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span></span><br><span class="line"><span class="hljs-string">  props: &#123;</span></span><br><span class="line"><span class="hljs-string">    foo: String // foo作为props属性绑定</span></span><br><span class="line"><span class="hljs-string">  &#125;,</span></span><br><span class="line"><span class="hljs-string">  created() &#123;</span></span><br><span class="line"><span class="hljs-string">    console.log(this.$attrs); // &#123; "</span>boo<span class="hljs-string">": "</span>Html<span class="hljs-string">", "</span>coo<span class="hljs-string">": "</span>CSS<span class="hljs-string">", "</span>doo<span class="hljs-string">": "</span>Vue<span class="hljs-string">", "</span>title<span class="hljs-string">": "</span>前端工匠<span class="hljs-string">" &#125;</span></span><br><span class="line"><span class="hljs-string">  &#125;</span></span><br><span class="line"><span class="hljs-string">&#125;;</span></span><br><span class="line"><span class="hljs-string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// childCom2.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"border"</span>&gt;</span><br><span class="line">    &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;<span class="hljs-regexp">/p&gt;</span></span><br><span class="line"><span class="hljs-regexp">    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;child-com3 v-bind=<span class="hljs-string">"$attrs"</span>&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child-com3</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="hljs-regexp">/template&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;script&gt;</span></span><br><span class="line"><span class="hljs-regexp">const childCom3 = () =&gt; import("./</span>childCom3.vue<span class="hljs-string">");</span></span><br><span class="line"><span class="hljs-string">export default &#123;</span></span><br><span class="line"><span class="hljs-string">  components: &#123;</span></span><br><span class="line"><span class="hljs-string">    childCom3</span></span><br><span class="line"><span class="hljs-string">  &#125;,</span></span><br><span class="line"><span class="hljs-string">  inheritAttrs: false,</span></span><br><span class="line"><span class="hljs-string">  props: &#123;</span></span><br><span class="line"><span class="hljs-string">    boo: String</span></span><br><span class="line"><span class="hljs-string">  &#125;,</span></span><br><span class="line"><span class="hljs-string">  created() &#123;</span></span><br><span class="line"><span class="hljs-string">    console.log(this.$attrs); // &#123; "</span>coo<span class="hljs-string">": "</span>CSS<span class="hljs-string">", "</span>doo<span class="hljs-string">": "</span>Vue<span class="hljs-string">", "</span>title<span class="hljs-string">": "</span>前端工匠<span class="hljs-string">" &#125;</span></span><br><span class="line"><span class="hljs-string">  &#125;</span></span><br><span class="line"><span class="hljs-string">&#125;;</span></span><br><span class="line"><span class="hljs-string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// childCom3.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"border"</span>&gt;</span><br><span class="line">    &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;<span class="hljs-regexp">/p&gt;</span></span><br><span class="line"><span class="hljs-regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="hljs-regexp">/template&gt;</span></span><br><span class="line"><span class="hljs-regexp">&lt;script&gt;</span></span><br><span class="line"><span class="hljs-regexp">export default &#123;</span></span><br><span class="line"><span class="hljs-regexp">  props: &#123;</span></span><br><span class="line"><span class="hljs-regexp">    coo: String,</span></span><br><span class="line"><span class="hljs-regexp">    title: String</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;;</span></span><br><span class="line"><span class="hljs-regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzE3LzE2YWMzNWJmNzdlNDQ3NDQ?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>如上图所示<code>$attrs</code>表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了<code>$attrs , $listeners</code> 来传递数据与事件，跨级组件之间的通讯变得更简单。</p><p>简单来说：<code>$attrs</code>与<code>$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。</p><h4 id="方案五：provide-inject"><a href="#方案五：provide-inject" class="headerlink" title="方案五：provide/inject"></a>方案五：<code>provide/inject</code></h4><p><strong>1.简介</strong></p><p>Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过<code>provider</code>来提供变量，然后在子孙组件中通过<code>inject</code>来注入变量。</p><p><code>provide</code> / <code>inject</code> API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p><strong>2.例子</strong><br>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// A.vue</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: <span class="hljs-string">'浪里行舟'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// B.vue</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="hljs-string">'name'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);  <span class="hljs-comment">// 浪里行舟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 A.vue 里，我们设置了一个 <code>provide: name</code>，值为 浪里行舟，它的作用就是将 <code>name</code> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <code>name</code> 变量，那么在组件 B 中，就可以直接通过 <code>this.name</code> 访问这个变量了，它的值也是 浪里行舟。这就是 <code>provide</code> / <code>inject</code> API 最核心的用法。</p><p>需要注意的是：<code>provide</code> 和 <code>inject</code> 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的—-vue官方文档<br>所以，上面 A.vue 的 <code>name</code> 如果改变了，B.vue 的 <code>this.name</code> 是不会改变的，仍然是 浪里行舟。</p><p><strong>3.provide与inject 怎么实现数据响应式</strong></p><p>一般来说，有两种办法：</p><ul><li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如<code>props</code>，<code>methods</code></li><li>使用2.6最新API <code>Vue.observable</code> 优化响应式 <code>provide</code>(推荐)</li></ul><p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzE3LzE2YWMzNWJmNzEzMWYzZGI?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// A 组件 </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;h1&gt;A 组件&lt;<span class="hljs-regexp">/h1&gt;</span></span><br><span class="line"><span class="hljs-regexp">      &lt;button @click="() =&gt; changeColor()"&gt;改变color&lt;/</span>button&gt;</span><br><span class="line">      &lt;ChildrenB /&gt;</span><br><span class="line">      &lt;ChildrenC /&gt;</span><br><span class="line">&lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">......</span></span><br><span class="line"><span class="hljs-regexp">  data() &#123;</span></span><br><span class="line"><span class="hljs-regexp">    return &#123;</span></span><br><span class="line"><span class="hljs-regexp">      color: "blue"</span></span><br><span class="line"><span class="hljs-regexp">    &#125;;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;,</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ provide() &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   return &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     theme: &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/       color: this.color /</span><span class="hljs-regexp">/这种方式绑定的数据并不是可响应的</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     &#125; /</span><span class="hljs-regexp">/ 即A组件的color变化后，组件D、E、F不会跟着变</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   &#125;;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ &#125;,</span></span><br><span class="line"><span class="hljs-regexp">  provide() &#123;</span></span><br><span class="line"><span class="hljs-regexp">    return &#123;</span></span><br><span class="line"><span class="hljs-regexp">      theme: this/</span><span class="hljs-regexp">/方法一：提供祖先组件的实例</span></span><br><span class="line"><span class="hljs-regexp">    &#125;;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;,</span></span><br><span class="line"><span class="hljs-regexp">  methods: &#123;</span></span><br><span class="line"><span class="hljs-regexp">    changeColor(color) &#123;</span></span><br><span class="line"><span class="hljs-regexp">      if (color) &#123;</span></span><br><span class="line"><span class="hljs-regexp">        this.color = color;</span></span><br><span class="line"><span class="hljs-regexp">      &#125; else &#123;</span></span><br><span class="line"><span class="hljs-regexp">        this.color = this.color === "blue" ? "red" : "blue";</span></span><br><span class="line"><span class="hljs-regexp">      &#125;</span></span><br><span class="line"><span class="hljs-regexp">    &#125;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ 方法二:使用2.6最新API Vue.observable 优化响应式 provide</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ provide() &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   this.theme = Vue.observable(&#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     color: "blue"</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   &#125;);</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   return &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     theme: this.theme</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   &#125;;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ &#125;,</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ methods: &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   changeColor(color) &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     if (color) &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/       this.theme.color = color;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     &#125; else &#123;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/       this.theme.color = this.theme.color === "blue" ? "red" : "blue";</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/     &#125;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/   &#125;</span></span><br><span class="line"><span class="hljs-regexp">  /</span><span class="hljs-regexp">/ &#125;</span></span><br></pre></td></tr></table></figure><p>虽说<code>provide</code> 和 <code>inject</code> 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p><h4 id="方案六：-parent-children与-ref"><a href="#方案六：-parent-children与-ref" class="headerlink" title="方案六：$parent / $children与 ref"></a>方案六：<code>$parent / $children</code>与 <code>ref</code></h4><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent / $children</code>：访问父 / 子实例</li></ul><p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// component-a 子组件</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">      title: <span class="hljs-string">'Vue.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">'Hello'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=<span class="hljs-string">"comA"</span>&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="hljs-keyword">const</span> comA = <span class="hljs-keyword">this</span>.$refs.comA;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(comA.title);  <span class="hljs-comment">// Vue.js</span></span><br><span class="line">      comA.sayHello();  <span class="hljs-comment">// 弹窗</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="hljs-regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>不过，这两种方法的弊端是，无法在跨级或兄弟间通信。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// parent.vue</span></span><br><span class="line">&lt;component-a&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span></span></span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br></pre></td></tr></table></figure><p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>常见使用场景可以分为三类：</p><ul><li>父子通信：父向子传递数据是通过 <code>props</code>，子向父是通过 <code>events（$emit）</code>；通过父链 / 子链也可以通信<code>（$parent / $children）</code>；<code>ref</code> 也可以访问组件实例；<code>provide / inject API</code>；<code>$attrs/$listeners</code></li><li>兄弟通信：Bus；Vuex</li><li>跨级通信：Bus；Vuex；<code>provide</code> / inject API、<code>$attrs/$listeners</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="https://jdsheng.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ES6的Set和Map数据结构</title>
    <link href="https://jdsheng.cn/2019/10/13/ES6%E7%9A%84Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://jdsheng.cn/2019/10/13/ES6的Set和Map数据结构/</id>
    <published>2019-10-13T03:57:09.490Z</published>
    <updated>2019-10-13T04:09:53.166Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写业务代码的时候经常碰到数组或者对象去重问题，常用的方法当然就是遍历，然后，<a id="more"></a>我自己搜了一下有没有更简洁的做法，发现了es6的Set和Map数据结构也可以用于去重，最主要的是省了好多代码。</p><p>那么Set和Map到底是何方神圣呢，刚开始看的时候越看越懵逼，因为我不明白实现这样的数据结构，目的是什么，意义又是什么呢？</p><p>Set和Map主要的应用场景在于数组去重和数据存储，幸运的是在读了关于数据结构和算法之类的书籍后，恍然大悟的发现</p><p>原来Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构</p><p>那么下面就跟随我一起去了解下这两种数据结构，最后来亲手实现的一个ES6中的Set和Map吧</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ol><li>集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组</li><li>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值 </li><li><p>Set 本身是一个构造函数，用来生成 Set数据结构 </p><p>这里说的Set其实就是我们所要讲到的集合，先来看下基础用法</p></li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(i);   <span class="hljs-comment">// 2 3 5 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 去除数组的重复成员</span></span><br><span class="line"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>];</span><br><span class="line">[...new <span class="hljs-built_in">Set</span>(array)]     <span class="hljs-comment">// [1, 2, 4, 5, 3]</span></span><br></pre></td></tr></table></figure><h4 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h4><p><strong>Set的属性：</strong></p><ul><li>size：返回集合所包含元素的数量</li></ul><p><strong>Set的方法：</strong><br>操作方法——</p><ul><li>add(value)：向集合添加一个新的项</li><li>delete(value)：从集合中移除一个值</li><li>has(value)：如果值在集合中存在，返回true,否则false</li><li>clear(): 移除集合里所有的项</li></ul><p>遍历方法——</p><ul><li>keys()：返回一个包含集合中所有键的数组</li><li>values()：返回一个包含集合中所有值的数组</li><li>entries：返回一个包含集合中所有键值对的数组(感觉没什么用就不实现了)</li><li>forEach()：用于对集合成员执行某种操作，没有返回值</li></ul><p><strong>Set完整实现</strong><br>在此，先给大家贴一下完整的实现代码</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set</span>(<span class="hljs-params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// has方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.has = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// add方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// 如果没有存在items里面就可以直接写入</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.has(val)) &#123;</span><br><span class="line">            items[val] = val;</span><br><span class="line">            <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    arr.forEach(<span class="hljs-function">(<span class="hljs-params">val, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.add(val);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// delete方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.delete = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.has(val)) &#123;</span><br><span class="line">            <span class="hljs-keyword">delete</span> items[val];  <span class="hljs-comment">// 将items对象上的属性删掉</span></span><br><span class="line">            <span class="hljs-keyword">this</span>.size--;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// clear方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// keys方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.keys = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(items);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// values方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.values = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(items);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// forEach方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, context = this</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> item = <span class="hljs-built_in">Object</span>.keys(items)[i];</span><br><span class="line">            fn.call(context, item, item, items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 并集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.union = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">        <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            union.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        values = other.values();    <span class="hljs-comment">// 将values重新赋值为新的集合</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            union.add(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> union;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 交集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.intersect = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">        <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (other.has(values[i])) &#123;</span><br><span class="line">                intersect.add(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> intersect;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 差集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.difference = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">        <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!other.has(values[i])) &#123;</span><br><span class="line">                difference.add(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> difference;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 子集</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.subset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">other</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.size &gt; other.size) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">this</span>.values();</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(values[i])</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(other.values())</span><br><span class="line">                <span class="hljs-keyword">if</span> (!other.has(values[i])) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Set</span>;</span><br></pre></td></tr></table></figure><p>写了辣么多一起来测试一下吧</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Set</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Set.js'</span>);</span><br><span class="line"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.keys());    <span class="hljs-comment">// [ '1', '2', '3' ]</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.values());  <span class="hljs-comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.size);      <span class="hljs-comment">// 3</span></span><br><span class="line">set.delete(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.values());  <span class="hljs-comment">// [ 2, 3 ]</span></span><br><span class="line">set.clear();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(set.size);      <span class="hljs-comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 并集</span></span><br><span class="line"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(a).union(b).values();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(union);     <span class="hljs-comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 交集</span></span><br><span class="line"><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).intersect(c).values();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(intersect); <span class="hljs-comment">// [ 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 差集</span></span><br><span class="line"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);</span><br><span class="line"><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).difference(d).values();</span><br><span class="line"><span class="hljs-comment">// [1,2,3]和[4,3,2]的差集是1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(difference);    <span class="hljs-comment">// [ 1 ]</span></span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>在数据结构还有一种结构叫做字典，它就是实现基于ES6中的Map类的结构</p><p>那么集合又和字典有什么区别呢：</p><ul><li>共同点：集合、字典可以存储不重复的值</li><li>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储</li><li>所以这一下让我们明白了，Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“值—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适</li></ul><p>下面来看一下基本使用：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();</span><br><span class="line"><span class="hljs-keyword">const</span> o = &#123;<span class="hljs-attr">p</span>: <span class="hljs-string">'Hello World'</span>&#125;;</span><br><span class="line">m.set(o, <span class="hljs-string">'content'</span>)</span><br><span class="line">m.get(o) <span class="hljs-comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="hljs-comment">// true</span></span><br><span class="line">m.delete(o) <span class="hljs-comment">// true</span></span><br><span class="line">m.has(o) <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><p>以上是Map的基本使用，还有更多有用的方法稍后会随着实现的深入分别展示</p><h4 id="Map的属性和方法"><a href="#Map的属性和方法" class="headerlink" title="Map的属性和方法"></a>Map的属性和方法</h4><p><strong>属性：</strong></p><ul><li>size：返回字典所包含的元素个数</li></ul><p><strong>操作方法：</strong></p><ul><li>set(key, val): 向字典中添加新元素</li><li>get(key):通过键值查找特定的数值并返回</li><li>has(key):如果键存在字典中返回true,否则false</li><li>delete(key): 通过键值从字典中移除对应的数据</li><li>clear():将这个字典中的所有元素删除</li></ul><p><strong>遍历方法：</strong></p><ul><li>keys():将字典中包含的所有键名以数组形式返回</li><li>values():将字典中包含的所有数值以数组形式返回</li><li>forEach()：遍历字典的所有成员</li></ul><p><strong>Map完整实现</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Map</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> items = &#123;&#125;;</span><br><span class="line">    <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 操作方法</span></span><br><span class="line">    <span class="hljs-comment">// has方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.has = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> items.hasOwnProperty(val);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// set(key, val)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.set = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, val</span>) </span>&#123;</span><br><span class="line">        items[key] = val;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// get(key)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.has(key) ? items[key] : <span class="hljs-literal">undefined</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// delete(key)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.delete = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.has(key)) &#123;</span><br><span class="line">            <span class="hljs-keyword">delete</span> items[key];</span><br><span class="line">            <span class="hljs-keyword">this</span>.size--;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// clear()方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        items = &#123;&#125;;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 遍历方法</span></span><br><span class="line">    <span class="hljs-comment">// keys()方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.keys = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(items);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// values()方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.values = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(items);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// forEach(fn, context)方法</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, context = this</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> key = <span class="hljs-built_in">Object</span>.keys(items)[i];</span><br><span class="line">            <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Object</span>.values(items)[i];</span><br><span class="line">            fn.call(context, value, key, items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Map</span>;</span><br></pre></td></tr></table></figure><p>再来看看下面的测试：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// map.js</span></span><br><span class="line">  <span class="hljs-comment">// 使用Map类</span></span><br><span class="line">  <span class="hljs-keyword">const</span> <span class="hljs-built_in">Map</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./Map.js'</span>);</span><br><span class="line">  <span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();</span><br><span class="line">  m.set(<span class="hljs-string">'Jay'</span>, <span class="hljs-string">'Jay的Chou'</span>);</span><br><span class="line">  m.set(<span class="hljs-literal">true</span>, <span class="hljs-string">'真的'</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.has(<span class="hljs-string">'Chou'</span>));  <span class="hljs-comment">// false</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.size);        <span class="hljs-comment">// 2</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.keys());      <span class="hljs-comment">// [ 'Jay', 'true' ]</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.values());    <span class="hljs-comment">// [ 'Jay的Chou', '真的' ]</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.get(<span class="hljs-string">'jay'</span>));  <span class="hljs-comment">// undefined</span></span><br><span class="line">  </span><br><span class="line">  m.delete(<span class="hljs-literal">true</span>);</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.keys());      <span class="hljs-comment">// [ 'Jay' ]</span></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(m.values());    <span class="hljs-comment">// [ 'Jay的Chou' ]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写业务代码的时候经常碰到数组或者对象去重问题，常用的方法当然就是遍历，然后，&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="es6" scheme="https://jdsheng.cn/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（四）——绑定例外和this词法</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96%E5%92%8Cthis%E8%AF%8D%E6%B3%95/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（四）——绑定例外和this词法/</id>
    <published>2019-10-13T03:57:00.968Z</published>
    <updated>2019-10-13T04:09:42.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1绑定例外"><a href="#1-1绑定例外" class="headerlink" title="1.1绑定例外"></a>1.1绑定例外</h2><p>在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。<a id="more"></a></p><h4 id="1-1-1-被忽略的this"><a href="#1-1-1-被忽略的this" class="headerlink" title="1.1.1 被忽略的this"></a>1.1.1 被忽略的this</h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">foo.call( <span class="hljs-literal">null</span> ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>那么什么情况下你会传入 null 呢？</p><p>一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。 类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a:"</span> + a + <span class="hljs-string">", b:"</span> + b ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 把数组“展开”成参数 </span></span><br><span class="line">foo.apply( <span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span></span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ); </span><br><span class="line">bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure><p>这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你 仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</p><p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。 </p><p>显而易见，这种方式可能会导致许多难以分析和追踪的 bug。</p><h5 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h5><p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized zone，非军事区）对象——它就是一个空的非委托的对象（下面会讲到）。</p><p> 如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何 对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。 </p><p>由于这个对象完全是一个空对象，我自己喜欢用变量名 ø（这是数学中表示空集合符号的 小写形式）来表示它。在大多数键盘（比如说 Mac 的 US 布局键盘）上都可以使用⌥ +o （Option-o）来打出这个符号。有些系统允许你为特殊符号设定快捷键。如果你不喜欢 ø 符 号或者你的键盘不太容易打出这个符号，那你可以换一个喜欢的名字来称呼它。 </p><p>无论你叫它什么，在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null) 。Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object. prototype 这个委托，所以它比 {}“更空”：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a,b</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"a:"</span> + a + <span class="hljs-string">", b:"</span> + b ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 我们的 DMZ 空对象 </span></span><br><span class="line"><span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>.create( <span class="hljs-literal">null</span> ); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 把数组展开成参数 </span></span><br><span class="line">foo.apply( ø, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>] ); <span class="hljs-comment">// a:2, b:3 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用 bind(..) 进行柯里化</span></span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( ø, <span class="hljs-number">2</span> ); </span><br><span class="line">bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// a:2, b:3</span></span><br></pre></td></tr></table></figure><p>使用变量名 ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为 ø 表示 “我希望 this 是空”，这比 null 的含义更清楚。不过再说一遍，你可以用任何喜欢的名字 来命名 DMZ 对象。</p><h4 id="1-1-2-间接引用"><a href="#1-1-2-间接引用" class="headerlink" title="1.1.2 间接引用"></a>1.1.2 间接引用</h4><p>另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。 </p><p>间接引用最容易在赋值时发生：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> p = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">4</span> &#125;; </span><br><span class="line">o.foo(); <span class="hljs-comment">// 3 </span></span><br><span class="line">(p.foo = o.foo)(); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p><blockquote><p> 注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。</p></blockquote><h4 id="1-1-3-软绑定"><a href="#1-1-3-软绑定" class="headerlink" title="1.1.3 软绑定"></a>1.1.3 软绑定</h4><p>之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 </p><p>如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><p> 可以通过一种被称为软绑定的方法来实现我们想要的效果：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Function</span>.prototype.softBind) &#123; </span><br><span class="line"><span class="hljs-built_in">Function</span>.prototype.softBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123; </span><br><span class="line"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 捕获所有 curried 参数</span></span><br><span class="line"><span class="hljs-keyword">var</span> curried = [].slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span> );</span><br><span class="line"><span class="hljs-keyword">var</span> bound = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> fn.apply( </span><br><span class="line">(!<span class="hljs-keyword">this</span> || <span class="hljs-keyword">this</span> === (<span class="hljs-built_in">window</span> || global)) ? </span><br><span class="line">obj : <span class="hljs-keyword">this</span></span><br><span class="line">curried.concat.apply( curried, <span class="hljs-built_in">arguments</span> ) </span><br><span class="line">); </span><br><span class="line">&#125;;</span><br><span class="line">bound.prototype = <span class="hljs-built_in">Object</span>.create( fn.prototype );</span><br><span class="line"><span class="hljs-keyword">return</span> bound; </span><br><span class="line">&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里 化（详情请查看之前和 bind(..) 相关的介绍）。</p><p>下面我们看看 softBind 是否实现了软绑定功能：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"name: "</span> + <span class="hljs-keyword">this</span>.name); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"obj"</span> &#125;, </span><br><span class="line">  obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"obj2"</span> &#125;,</span><br><span class="line">   obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"obj3"</span> &#125;;</span><br><span class="line">   </span><br><span class="line"><span class="hljs-keyword">var</span> fooOBJ = foo.softBind( obj ); </span><br><span class="line"></span><br><span class="line">fooOBJ(); <span class="hljs-comment">// name: obj </span></span><br><span class="line"></span><br><span class="line">obj2.foo = foo.softBind(obj); </span><br><span class="line">obj2.foo(); <span class="hljs-comment">// name: obj2 &lt;---- 看！！！ </span></span><br><span class="line"></span><br><span class="line">fooOBJ.call( obj3 ); <span class="hljs-comment">// name: obj3 &lt;---- 看！ </span></span><br><span class="line"></span><br><span class="line">setTimeout( obj2.foo, <span class="hljs-number">10</span> ); </span><br><span class="line"><span class="hljs-comment">// name: obj &lt;---- 应用了软绑定</span></span><br></pre></td></tr></table></figure><p>可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默 认绑定，则会将 this 绑定到 obj。</p><h2 id="1-2-this词法"><a href="#1-2-this词法" class="headerlink" title="1.2 this词法"></a>1.2 this词法</h2><p>我们之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用 这些规则的特殊函数类型：箭头函数。</p><p> 箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。 </p><p>我们来看看箭头函数的词法作用域：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-comment">// 返回一个箭头函数</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="hljs-comment">//this 继承自 foo() </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123; </span><br><span class="line">a:<span class="hljs-number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.call( obj1 ); </span><br><span class="line">bar.call( obj2 ); <span class="hljs-comment">// 2, 不是 3 ！</span></span><br></pre></td></tr></table></figure><p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不 行！）</p><p>箭头函数最常用于回调函数中，例如事件处理器或者定时器：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; </span><br><span class="line"><span class="hljs-comment">// 这里的 this 在此法上继承自 foo() </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;,<span class="hljs-number">100</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体 现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// lexical capture of this </span></span><br><span class="line">setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( self.a ); </span><br><span class="line">&#125;, <span class="hljs-number">100</span> ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替 代的是 this 机制。 </p><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数 来否定 this 机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码； </li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li></ol><p>当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混 合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。</p><h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。 </p><ol><li>由 new 调用？绑定到新创建的对象。 </li><li>由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 </li><li>由上下文对象调用？绑定到那个上下文对象。 </li><li><p>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</p><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。</p></li></ol><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1绑定例外&quot;&gt;&lt;a href=&quot;#1-1绑定例外&quot; class=&quot;headerlink&quot; title=&quot;1.1绑定例外&quot;&gt;&lt;/a&gt;1.1绑定例外&lt;/h2&gt;&lt;p&gt;在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（二）——调用位置和绑定规则</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（三）——绑定规则的优先级/</id>
    <published>2019-10-13T03:56:51.711Z</published>
    <updated>2019-10-13T04:09:23.865Z</updated>
    
    <content type="html"><![CDATA[<p>现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。<a id="more"></a>但是，如果某个调用位置可以应用多条规则该怎么办？为了 解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。 </p><p>毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。 </p><p>隐式绑定和显式绑定哪个优先级更高？我们来测试一下：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123; </span><br><span class="line">a: <span class="hljs-number">3</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo(); <span class="hljs-comment">// 2 </span></span><br><span class="line">obj2.foo(); <span class="hljs-comment">// 3 </span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2 ); <span class="hljs-comment">// 3 </span></span><br><span class="line">obj2.foo.call( obj1 ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看到，<strong>显式绑定优先级更高</strong>，也就是说在判断时应当先考虑是否可以应用显式绑定。</p><p>现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.a = something; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">obj1.foo( <span class="hljs-number">2</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2 </span></span><br><span class="line"></span><br><span class="line">obj1.foo.call( obj2, <span class="hljs-number">3</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj2.a ); <span class="hljs-comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.foo( <span class="hljs-number">4</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( bar.a ); <span class="hljs-comment">// 4</span></span><br></pre></td></tr></table></figure><p>可以看到 <strong>new 绑定比隐式绑定优先级高</strong>。但是 new 绑定和显式绑定谁的优先级更高呢？</p><blockquote><p>new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。</p></blockquote><p>在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们 提供的对象绑定到 this 上。 </p><p>这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。</p><p>我们看看是不是这样：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.a = something; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( obj1 ); </span><br><span class="line">bar( <span class="hljs-number">2</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar(<span class="hljs-number">3</span>); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( obj1.a ); <span class="hljs-comment">// 2 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( baz.a ); <span class="hljs-comment">// 3</span></span><br></pre></td></tr></table></figure><p>出乎意料！ bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。</p><h5 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h5><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断：</p><ol><li><p>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo()</span><br></pre></td></tr></table></figure></li><li><p>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = foo.call(obj2)</span><br></pre></td></tr></table></figure></li><li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = obj1.foo()</span><br></pre></td></tr></table></figure></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 </p></li></ol><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> bar = foo()</span><br></pre></td></tr></table></figure><p>就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（三）——绑定规则的优先级</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE%E5%92%8C%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（二）——调用位置和绑定规则/</id>
    <published>2019-10-13T03:56:40.270Z</published>
    <updated>2019-10-13T04:09:36.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-调用位置"><a href="#1-1-调用位置" class="headerlink" title="1.1 调用位置"></a>1.1 调用位置</h2><p>在理解 this 的绑定过程之前首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）<a id="more"></a>。只有仔细分析调用位置才能回答这个问题：这个 this 到底引 用的是什么？ </p><p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。 </p><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的 调用位置就在当前正在<strong>执行的函数的前一个调用中</strong>。 </p><p>下面我们来看看到底什么是调用栈和调用位置：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"> <span class="hljs-comment">// 当前调用栈是：baz </span></span><br><span class="line"> <span class="hljs-comment">// 因此，当前调用位置是全局作用域 </span></span><br><span class="line"> <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"baz"</span> ); </span><br><span class="line"> bar(); <span class="hljs-comment">// &lt;-- bar 的调用位置 </span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 当前调用栈是 baz -&gt; bar </span></span><br><span class="line"><span class="hljs-comment">// 因此，当前调用位置在 baz 中 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"bar"</span> ); </span><br><span class="line">foo(); <span class="hljs-comment">// &lt;-- foo 的调用位置 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class="line"><span class="hljs-comment">// 因此，当前调用位置在 bar 中 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo"</span> ); </span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure><p>注意我们是如何（从调用栈中）分析出真正的调用位置的，因为它决定了 this 的绑定。</p><blockquote><p>你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所 写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法 是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的 第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger;语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数 调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。</p></blockquote><h2 id="1-2-绑定规则"><a href="#1-2-绑定规则" class="headerlink" title="1.2 绑定规则"></a>1.2 绑定规则</h2><h4 id="1-2-1-默认绑定"><a href="#1-2-1-默认绑定" class="headerlink" title="1.2.1 默认绑定"></a>1.2.1 默认绑定</h4><p>最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用 其他规则时的默认规则。<br>思考一下下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">foo(); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。 </p><p>接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了this 的默认绑定，因此<strong>this指向全局对象</strong>。 </p><p>那么我们怎么知道这里应用了默认绑定呢？<strong>可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</strong></p><p>如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-meta"> "use strict"</span>; </span><br><span class="line"> <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">foo(); <span class="hljs-comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure><p>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只 有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；<strong>严格模式下与 foo() 的调用位置无关</strong>：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; </span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; </span><br><span class="line"><span class="hljs-meta">"use strict"</span>;</span><br><span class="line"> foo(); <span class="hljs-comment">// 2 </span></span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><h4 id="1-2-2隐性绑定"><a href="#1-2-2隐性绑定" class="headerlink" title="1.2.2隐性绑定"></a>1.2.2隐性绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包 含，不过这种说法可能会造成一些误导。<br>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。</p><p>然而，<strong>调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥 有”或者“包含”它</strong>。 </p><p>无论你如何称呼这个模式，<strong>当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</strong></p><p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj2 = &#123; </span><br><span class="line">a: <span class="hljs-number">42</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> obj1 = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>,</span><br><span class="line">obj2: obj2 </span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo(); <span class="hljs-comment">// 42</span></span><br></pre></td></tr></table></figure></p><h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题就是<strong>被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</strong></p><p>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = obj.foo; <span class="hljs-comment">// 函数别名！</span></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a 是全局对象的属性 </span></span><br><span class="line">bar(); <span class="hljs-comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFoo</span>(<span class="hljs-params">fn</span>) </span>&#123; </span><br><span class="line"><span class="hljs-comment">// fn 其实引用的是 foo </span></span><br><span class="line">fn(); <span class="hljs-comment">// &lt;-- 调用位置！ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a 是全局对象的属性 </span></span><br><span class="line">doFoo( obj.foo ); <span class="hljs-comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一 个例子一样。</p><p> 如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一 样的，没有区别：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a: <span class="hljs-number">2</span>, </span><br><span class="line">foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"oops, global"</span>; <span class="hljs-comment">// a 是全局对象的属性 </span></span><br><span class="line">setTimeout( obj.foo, <span class="hljs-number">100</span> ); <span class="hljs-comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-显性绑定"><a href="#1-2-3-显性绑定" class="headerlink" title="1.2.3 显性绑定"></a>1.2.3 显性绑定</h4><p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函 数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 </p><p>那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么 做呢？ </p><p>JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。 </p><p>这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。</p><p>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。</p><blockquote><p>从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现 在其他的参数上，但是现在我们不用考虑这些。</p></blockquote><p>可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p><p><strong>1.硬绑定</strong><br>但是显式绑定的一个变种可以解决这个问题。 思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line">foo.call( obj ); </span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="hljs-comment">// 2 </span></span><br><span class="line">setTimeout( bar, <span class="hljs-number">100</span> ); <span class="hljs-comment">// 2 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this </span></span><br><span class="line">bar.call( <span class="hljs-built_in">window</span> ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们来看看这个变种到底是怎样工作的。我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。</p><p>由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 <code>Function.prototype. bind</code>，它的用法如下：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">something</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a, something );</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a + something; </span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">a:<span class="hljs-number">2</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = foo.bind( obj );</span><br><span class="line"><span class="hljs-keyword">var</span> b = bar( <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2 3 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( b ); <span class="hljs-comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>2.API调用的“上下文”</strong><br>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。</p><p>举例来说：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">el</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( el, <span class="hljs-keyword">this</span>.id ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> obj = &#123; </span><br><span class="line">id: <span class="hljs-string">"awesome"</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">// 调用 foo(..) 时把 this 绑定到 obj </span></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach( foo, obj ); </span><br><span class="line"><span class="hljs-comment">// 1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。</p><h4 id="1-2-4-new绑定"><a href="#1-2-4-new绑定" class="headerlink" title="1.2.4 new绑定"></a>1.2.4 new绑定</h4><p>这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见 的关于 JavaScript 中函数和对象的误解。 </p><p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会 调用类中的构造函数。通常的形式是这样的：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">something = <span class="hljs-keyword">new</span> MyClass(..);</span><br></pre></td></tr></table></figure></p><p>JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。</p><p>首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p><p>举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它：</p><blockquote><p>当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的 对象。</p></blockquote><p>所以，包括内置对象函数（比如 Number(..)，详情请查看第 3 章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p><ol><li>创建（或者说构造）一个全新的对象。 </li><li>这个新对象会被执行 [[ 原型 ]] 连接。</li><li>这个新对象会绑定到函数调用的 this。 </li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li></ol><p>思考下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.a = a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo(<span class="hljs-number">2</span>); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( bar.a ); <span class="hljs-comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-调用位置&quot;&gt;&lt;a href=&quot;#1-1-调用位置&quot; class=&quot;headerlink&quot; title=&quot;1.1 调用位置&quot;&gt;&lt;/a&gt;1.1 调用位置&lt;/h2&gt;&lt;p&gt;在理解 this 的绑定过程之前首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于this的解析（一）</title>
    <link href="https://jdsheng.cn/2019/10/13/%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/10/13/关于this的解析（一）/</id>
    <published>2019-10-13T03:56:18.487Z</published>
    <updated>2019-10-13T04:09:03.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-为什么要用this"><a href="#1-1-为什么要用this" class="headerlink" title="1.1 为什么要用this"></a>1.1 为什么要用this</h2><p>如果对于有经验的JavaScript开发者来说this都是一种非常复杂的机制，那它到底有用在哪里呢？<a id="more"></a>真的值得我们付出这么大的代价学习吗？的确，在介绍怎么做之前我们需要先明白为什么。</p><p>下面我们来解释一下为什么要使用 this：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identify</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.toUpperCase(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">"Hello, I'm "</span> + identify.call( <span class="hljs-keyword">this</span> ); </span><br><span class="line"><span class="hljs-built_in">console</span>.log( greeting ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> me = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Kyle"</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> you = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"Reader"</span> &#125;;</span><br><span class="line">identify.call( me ); <span class="hljs-comment">// KYLE </span></span><br><span class="line">identify.call( you ); <span class="hljs-comment">// READER </span></span><br><span class="line">speak.call( me ); <span class="hljs-comment">// Hello, 我是 KYLE </span></span><br><span class="line">speak.call( you ); <span class="hljs-comment">// Hello, 我是 READER</span></span><br></pre></td></tr></table></figure><p>看不懂这段代码？不用担心！我们很快就会讲解。现在请暂时抛开这些问题，专注于为 什么。 这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。 如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identify</span>(<span class="hljs-params">context</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> context.name.toUpperCase(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">speak</span>(<span class="hljs-params">context</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">"Hello, I'm "</span> + identify( context );</span><br><span class="line"> <span class="hljs-built_in">console</span>.log( greeting ); </span><br><span class="line">&#125;</span><br><span class="line">identify( you ); <span class="hljs-comment">// READER </span></span><br><span class="line">speak( me ); <span class="hljs-comment">//hello, 我是 KYLE</span></span><br></pre></td></tr></table></figure><p>然而，this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计 得更加简洁并且易于复用。 随着你的使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。当我们介绍对象和原型时，你就会明白函数可以自动引用合适的上下文对象 有多重要。</p><h2 id="1-2-误解"><a href="#1-2-误解" class="headerlink" title="1.2 误解"></a>1.2 误解</h2><h4 id="1-2-1-指向自身"><a href="#1-2-1-指向自身" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h4><p>人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说得通的。 </p><p>那么为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函 数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。 </p><p>JavaScript 的新手开发者通常会认为，既然函数看作一个对象（JavaScript 中的所有函数都 是对象），那就可以在调用函数时存储状态（属性的值）。这是可行的，有些时候也确实有 用，但是在本书即将介绍的许多模式中你会发现，除了函数对象还有许多更合适存储状态 的地方。 </p><p>不过现在我们先来分析一下这个模式，让大家看到 this 并不像我们所想的那样指向函数 本身。</p><p>我们想要记录一下函数 foo 被调用的次数，思考一下下面的代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo: "</span> + num );</span><br><span class="line"> <span class="hljs-comment">// 记录 foo 被调用的次数</span></span><br><span class="line"><span class="hljs-keyword">this</span>.count++; </span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; </span><br><span class="line">foo( i ); </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="hljs-comment">// foo: 6 </span></span><br><span class="line"> <span class="hljs-comment">// foo: 7 </span></span><br><span class="line"> <span class="hljs-comment">// foo: 8 </span></span><br><span class="line"> <span class="hljs-comment">// foo: 9 </span></span><br><span class="line"> <span class="hljs-comment">// foo 被调用了多少次？ </span></span><br><span class="line"> <span class="hljs-built_in">console</span>.log( foo.count ); <span class="hljs-comment">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure><p>console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然 是 0。显然从字面意思来理解 this 是错误的。 </p><p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相 同，困惑随之产生。</p><p>遇到这样的问题时，许多开发者并不会深入思考为什么 this 的行为和预期的不一致，也不 会试图回答那些很难解决但却非常重要的问题。他们只会回避这个问题并使用其他方法来 达到目的，比如创建另一个带有 count 属性的对象。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo: "</span> + num ); </span><br><span class="line"><span class="hljs-comment">// 记录 foo 被调用的次数 </span></span><br><span class="line">data.count++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">var</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; </span><br><span class="line">foo( i ); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// foo: 6 </span></span><br><span class="line"><span class="hljs-comment">// foo: 7 </span></span><br><span class="line"><span class="hljs-comment">// foo: 8 </span></span><br><span class="line"><span class="hljs-comment">// foo: 9 </span></span><br><span class="line"><span class="hljs-comment">// foo 被调用了多少次？ </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( data.count ); <span class="hljs-comment">// 4</span></span><br></pre></td></tr></table></figure><p>从某种角度来说这个方法确实“解决”了问题，但可惜它忽略了真正的问题——无法理解 this 的含义和工作原理——而是返回舒适区，使用了一种更熟悉的技术：<strong>词法作用域</strong>。</p><p>另一种方法是强制 this 指向 foo 函数对象：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-string">"foo: "</span> + num ); </span><br><span class="line"><span class="hljs-comment">// 记录 foo 被调用的次数 </span></span><br><span class="line"><span class="hljs-comment">// 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo</span></span><br><span class="line"><span class="hljs-keyword">this</span>.count++; </span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> i;</span><br><span class="line"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">5</span>) &#123; </span><br><span class="line"><span class="hljs-comment">// 使用 call(..) 可以确保 this 指向函数对象 foo 本身 </span></span><br><span class="line">foo.call( foo, i ); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// foo: 6 </span></span><br><span class="line"><span class="hljs-comment">// foo: 7 </span></span><br><span class="line"><span class="hljs-comment">// foo: 8 </span></span><br><span class="line"><span class="hljs-comment">// foo: 9 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// foo 被调用了多少次？ </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log( foo.count ); <span class="hljs-comment">// 4</span></span><br></pre></td></tr></table></figure><p>这次我们接受了 this，没有回避它。如果你仍然感到困惑的话，不用担心，之后我们会详 细解释具体的原理。</p><h4 id="1-2-2-它的作用域"><a href="#1-2-2-它的作用域" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h4><p>第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它 是正确的，但是在其他情况下它却是错误的。 </p><p><strong>需要明确的是，this 在任何情况下都不指向函数的词法作用域</strong>。在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，<strong>它存在于 JavaScript 引擎内部</strong>。</p><p>思考一下下面的代码，它试图（但是没有成功）跨越边界，使用 this 来隐式引用函数的词 法作用域：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.bar(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123; </span><br><span class="line"><span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.a ); </span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="hljs-comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实 际上它出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感） 地展示了 this 多么容易误导人。 </p><p>首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的，我们之 后会解释原因。调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。 </p><p>此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你不能使用 this 来引用一 个词法作用域内部的东西。 </p><p><strong>每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</strong></p><h2 id="1-3-this到底是什么"><a href="#1-3-this到底是什么" class="headerlink" title="1.3 this到底是什么"></a>1.3 this到底是什么</h2><p>排除了一些错误理解之后，我们来看看 this 到底是一种什么样的机制。 </p><p>之前我们说过 <strong>this 是在运行时进行绑定的，并不是在编写时绑定</strong>，它的上下文取决于函数调 用时的各种条件。<strong>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式</strong>。 </p><p><strong>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到</strong>。 </p><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>对于那些没有投入时间学习 this 机制的 JavaScript 开发者来说，this 的绑定一直是一件非常令人困惑的事。</p><p>this 是非常重要的，但是猜测、尝试并出错和盲目地从 Stack Overflow 上复制和粘贴答案并不能让你真正理解 this 的机制。 </p><p>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被 这样的解释误导过，但其实它们都是错误的。 </p><p><strong>this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-1-为什么要用this&quot;&gt;&lt;a href=&quot;#1-1-为什么要用this&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要用this&quot;&gt;&lt;/a&gt;1.1 为什么要用this&lt;/h2&gt;&lt;p&gt;如果对于有经验的JavaScript开发者来说this都是一种非常复杂的机制，那它到底有用在哪里呢？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue中axios的封装和API接口的管理</title>
    <link href="https://jdsheng.cn/2019/10/01/vue%E4%B8%ADaxios%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8CAPI%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://jdsheng.cn/2019/10/01/vue中axios的封装和API接口的管理/</id>
    <published>2019-09-30T16:22:46.881Z</published>
    <updated>2019-10-22T14:06:24.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、axios的封装"><a href="#一、axios的封装" class="headerlink" title="一、axios的封装"></a>一、axios的封装</h1><p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，<a id="more"></a>它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步<a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios文档</a>。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC83LzIzLzE2NGM3MDg1MmY0MWIwNGM?x-oss-process=image/format,png" alt="面对一团糟代码的你"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="hljs-keyword">install </span>axios<span class="hljs-comment">; // 安装axios</span></span><br></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 在http.js中引入axios</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>; <span class="hljs-comment">// 引入axios</span></span><br><span class="line"><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>; <span class="hljs-comment">// 引入qs模块，用来序列化post类型的数据，后面会提到</span></span><br><span class="line"><span class="hljs-comment">// vant的toast提示框组件，大家可根据自己的ui组件更改。</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="环境的切换"><a href="#环境的切换" class="headerlink" title="环境的切换"></a>环境的切换</h3><p>我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。</p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 环境的切换</span></span><br><span class="line"><span class="hljs-built_in">if</span> (<span class="hljs-built_in">process</span>.env.NODE_ENV == <span class="hljs-string">'development'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'https://www.baidu.com'</span>;&#125; </span><br><span class="line"><span class="hljs-built_in">else</span> <span class="hljs-built_in">if</span> (<span class="hljs-built_in">process</span>.env.NODE_ENV == <span class="hljs-string">'debug'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'https://www.ceshi.com'</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-built_in">else</span> <span class="hljs-built_in">if</span> (<span class="hljs-built_in">process</span>.env.NODE_ENV == <span class="hljs-string">'production'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'https://www.production.com'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置请求超时"><a href="#设置请求超时" class="headerlink" title="设置请求超时"></a>设置请求超时</h3><p>通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。</p><figure class="highlight abnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.timeout = <span class="hljs-number">10000</span><span class="hljs-comment">;</span></span><br></pre></td></tr></table></figure><h3 id="post请求头的设置"><a href="#post请求头的设置" class="headerlink" title="post请求头的设置"></a>post请求头的设置</h3><p>post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为<code>application/x-www-form-urlencoded;charset=UTF-8</code></p><figure class="highlight ada hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="hljs-symbol">'Content</span>-<span class="hljs-keyword">Type</span>'] = <span class="hljs-symbol">'application</span>/x-www-form-urlencoded;charset=UTF-<span class="hljs-number">8</span>';</span><br></pre></td></tr></table></figure><h3 id="请求拦截"><a href="#请求拦截" class="headerlink" title="请求拦截"></a>请求拦截</h3><p>我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。</p><figure class="highlight stata hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 先导入vuex,因为我们要使用到里面的状态对象</span></span><br><span class="line"><span class="hljs-comment">// vuex的路径根据自己的路径去写</span></span><br><span class="line">import store from '@/store/index';</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 请求拦截器axios.interceptors.request.use(    </span></span><br><span class="line">    config =&gt; &#123;        </span><br><span class="line">        <span class="hljs-comment">// 每次发送请求之前判断vuex中是否存在token        </span></span><br><span class="line">        <span class="hljs-comment">// 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况</span></span><br><span class="line">        <span class="hljs-comment">// 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 </span></span><br><span class="line">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">token</span> = store.state.<span class="hljs-keyword">token</span>;        </span><br><span class="line">        <span class="hljs-keyword">token</span> &amp;&amp; (config.headers.Authorization = <span class="hljs-keyword">token</span>);        </span><br><span class="line">        <span class="hljs-keyword">return</span> config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="hljs-keyword">error</span> =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> Promise.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">error</span>);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。</p><p>然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊。</p><h3 id="响应的拦截"><a href="#响应的拦截" class="headerlink" title="响应的拦截"></a>响应的拦截</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(    </span><br><span class="line">    response =&gt; &#123;   </span><br><span class="line">        <span class="hljs-comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据     </span></span><br><span class="line">        <span class="hljs-comment">// 否则的话抛出错误</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response);        </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="hljs-comment">// 服务器状态码不是2开头的的情况</span></span><br><span class="line">    <span class="hljs-comment">// 这里可以跟你们的后台开发人员协商好统一的错误状态码    </span></span><br><span class="line">    <span class="hljs-comment">// 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等</span></span><br><span class="line">    <span class="hljs-comment">// 下面列举几个常见的操作，其他需求可自行扩展</span></span><br><span class="line">    error =&gt; &#123;            </span><br><span class="line">        <span class="hljs-keyword">if</span> (error.response.status) &#123;            </span><br><span class="line">            <span class="hljs-keyword">switch</span> (error.response.status) &#123;                </span><br><span class="line">                <span class="hljs-comment">// 401: 未登录</span></span><br><span class="line">                <span class="hljs-comment">// 未登录则跳转登录页面，并携带当前页面的路径</span></span><br><span class="line">                <span class="hljs-comment">// 在登录成功后返回当前页面，这一步需要在登录页操作。                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:                    </span><br><span class="line">                    router.replace(&#123;                        </span><br><span class="line">                        path: <span class="hljs-string">'/login'</span>,                        </span><br><span class="line">                        query: &#123; </span><br><span class="line">                            redirect: router.currentRoute.fullPath </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// 403 token过期</span></span><br><span class="line">                <span class="hljs-comment">// 登录过期对用户进行提示</span></span><br><span class="line">                <span class="hljs-comment">// 清除本地token和清空vuex中token对象</span></span><br><span class="line">                <span class="hljs-comment">// 跳转登录页面                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:</span><br><span class="line">                     Toast(&#123;</span><br><span class="line">                        message: <span class="hljs-string">'登录过期，请重新登录'</span>,</span><br><span class="line">                        duration: <span class="hljs-number">1000</span>,</span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-comment">// 清除token</span></span><br><span class="line">                    localStorage.removeItem(<span class="hljs-string">'token'</span>);</span><br><span class="line">                    store.commit(<span class="hljs-string">'loginSuccess'</span>, <span class="hljs-literal">null</span>);</span><br><span class="line">                    <span class="hljs-comment">// 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 </span></span><br><span class="line">                    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                        </span><br><span class="line">                        router.replace(&#123;                            </span><br><span class="line">                            path: <span class="hljs-string">'/login'</span>,                            </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;                        </span><br><span class="line">                        &#125;);                    </span><br><span class="line">                    &#125;, <span class="hljs-number">1000</span>);                    </span><br><span class="line">                    <span class="hljs-keyword">break</span>; </span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// 404请求不存在</span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:</span><br><span class="line">                    Toast(&#123;</span><br><span class="line">                        message: <span class="hljs-string">'网络请求不存在'</span>,</span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,</span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-comment">// 其他错误，直接抛出错误提示</span></span><br><span class="line">                <span class="hljs-keyword">default</span>:</span><br><span class="line">                    Toast(&#123;</span><br><span class="line">                        message: error.response.data.message,</span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,</span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span></span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。</p><blockquote><p>要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。</p></blockquote><h3 id="封装get方法和post方法"><a href="#封装get方法和post方法" class="headerlink" title="封装get方法和post方法"></a>封装get方法和post方法</h3><p>我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：<strong>get和post</strong>。</p><p><strong>get方法</strong>：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * get方法，对应get请求</span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址]</span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数]</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, params</span>)</span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;        </span><br><span class="line">        axios.get(url, &#123;            </span><br><span class="line">            params: params        </span><br><span class="line">        &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;</span><br><span class="line">            reject(err.data)        </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;);&#125;</span><br></pre></td></tr></table></figure><p>post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们<code>import QS from &#39;qs&#39;</code>;的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * post方法，对应post请求 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址] </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数] </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, params</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">         axios.post(url, QS.stringify(params))</span><br><span class="line">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(res.data);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span>&#123;</span><br><span class="line">            reject(err.data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个小细节说下，<code>axios.get()</code>方法和<code>axios.post()</code>在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！</p><h1 id="二、api的统一管理"><a href="#二、api的统一管理" class="headerlink" title="二、api的统一管理"></a>二、api的统一管理</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzcvMTY1MTM0OWUwODY0YmVlNA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。上面说了，我们会新建一个api.js,然后在这个文件中存放我们所有的api接口。</p><p>首先我们在api.js中引入我们封装的get和post方法</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**   </span></span><br><span class="line"><span class="hljs-comment"> * api接口统一管理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">get</span>, post &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./http'</span></span><br></pre></td></tr></table></figure><p>现在，例如我们有这样一个接口，是一个post请求：</p><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="hljs-regexp">//</span>www.baiodu.com<span class="hljs-regexp">/api/</span>v1<span class="hljs-regexp">/users/my</span>_address<span class="hljs-regexp">/address_edit_before</span></span><br></pre></td></tr></table></figure><p>我们可以在api.js中这样封装：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> apiAddress = <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> post(<span class="hljs-string">'api/v1/users/my_address/address_edit_before'</span>, p);</span><br></pre></td></tr></table></figure><p>我们定义了一个<code>apiAddress</code>方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的<code>post</code>方法，<code>post</code>方法的第一个参数是我们的接口地址，第二个参数是<code>apiAddress</code>的p参数，即请求接口时携带的参数对象。最后通过<code>export</code>导出<code>apiAddress</code>。</p><p>然后在我们的页面中可以这样调用我们的api接口：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123; apiAddress &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@/request/api'</span>;<span class="hljs-comment">// 导入我们的api接口</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;        </span><br><span class="line">    name: <span class="hljs-string">'Address'</span>,    </span><br><span class="line">    created () &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.onLoad();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;            </span><br><span class="line">        <span class="hljs-comment">// 获取数据            </span></span><br><span class="line">        onLoad() &#123;</span><br><span class="line">            <span class="hljs-comment">// 调用api接口，并且提供了两个参数                </span></span><br><span class="line">            apiAddress(&#123;                    </span><br><span class="line">                <span class="hljs-keyword">type</span>: <span class="hljs-number">0</span>,                    </span><br><span class="line">                sort: <span class="hljs-number">1</span>                </span><br><span class="line">            &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 获取数据成功后的其他操作</span></span><br><span class="line">                ………………                </span><br><span class="line">            &#125;)            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的api接口，就在pai.js中继续往下面扩展就可以了。</p><blockquote><p>友情提示，为每个接口写好注释哦！！！api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就规格gg了。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。</p></blockquote><p><strong>好了，最后把完成的<code>axios</code>封装代码奉上。</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**axios封装</span></span><br><span class="line"><span class="hljs-comment"> * 请求拦截、相应拦截、错误统一处理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'../store/index'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 环境的切换</span></span><br><span class="line"><span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'development'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'/api'</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'debug'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">''</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV == <span class="hljs-string">'production'</span>) &#123;    </span><br><span class="line">    axios.defaults.baseURL = <span class="hljs-string">'http://api.123dailu.com/'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 请求超时时间</span></span><br><span class="line">axios.defaults.timeout = <span class="hljs-number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// post请求头</span></span><br><span class="line">axios.defaults.headers.post[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(    </span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="hljs-comment">// 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了</span></span><br><span class="line">        <span class="hljs-comment">// 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</span></span><br><span class="line">        <span class="hljs-keyword">const</span> token = store.state.token;        </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);        </span><br><span class="line">        <span class="hljs-keyword">return</span> config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    error =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.error(error);    </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(    </span><br><span class="line">    response =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">if</span> (response.status === <span class="hljs-number">200</span>) &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(response);        </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-comment">// 服务器状态码不是200的情况    </span></span><br><span class="line">    error =&gt; &#123;        </span><br><span class="line">        <span class="hljs-keyword">if</span> (error.response.status) &#123;            </span><br><span class="line">            <span class="hljs-keyword">switch</span> (error.response.status) &#123;                </span><br><span class="line">                <span class="hljs-comment">// 401: 未登录                </span></span><br><span class="line">                <span class="hljs-comment">// 未登录则跳转登录页面，并携带当前页面的路径                </span></span><br><span class="line">                <span class="hljs-comment">// 在登录成功后返回当前页面，这一步需要在登录页操作。                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:                    </span><br><span class="line">                    router.replace(&#123;                        </span><br><span class="line">                        path: <span class="hljs-string">'/login'</span>,                        </span><br><span class="line">                        query: &#123; <span class="hljs-attr">redirect</span>: router.currentRoute.fullPath &#125; </span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-comment">// 403 token过期                </span></span><br><span class="line">                <span class="hljs-comment">// 登录过期对用户进行提示                </span></span><br><span class="line">                <span class="hljs-comment">// 清除本地token和清空vuex中token对象                </span></span><br><span class="line">                <span class="hljs-comment">// 跳转登录页面                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:                     </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: <span class="hljs-string">'登录过期，请重新登录'</span>,                        </span><br><span class="line">                        duration: <span class="hljs-number">1000</span>,                        </span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span>                    </span><br><span class="line">                    &#125;);                    </span><br><span class="line">                    <span class="hljs-comment">// 清除token                    </span></span><br><span class="line">                    localStorage.removeItem(<span class="hljs-string">'token'</span>);                    </span><br><span class="line">                    store.commit(<span class="hljs-string">'loginSuccess'</span>, <span class="hljs-literal">null</span>);                    </span><br><span class="line">                    <span class="hljs-comment">// 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面</span></span><br><span class="line">                    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                        </span><br><span class="line">                        router.replace(&#123;                            </span><br><span class="line">                            path: <span class="hljs-string">'/login'</span>,                            </span><br><span class="line">                            query: &#123; </span><br><span class="line">                                redirect: router.currentRoute.fullPath </span><br><span class="line">                            &#125;                        </span><br><span class="line">                        &#125;);                    </span><br><span class="line">                    &#125;, <span class="hljs-number">1000</span>);                    </span><br><span class="line">                    <span class="hljs-keyword">break</span>; </span><br><span class="line">                <span class="hljs-comment">// 404请求不存在                </span></span><br><span class="line">                <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:                    </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: <span class="hljs-string">'网络请求不存在'</span>,                        </span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,                        </span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span>                    </span><br><span class="line">                    &#125;);                    </span><br><span class="line">                <span class="hljs-keyword">break</span>;                </span><br><span class="line">                <span class="hljs-comment">// 其他错误，直接抛出错误提示                </span></span><br><span class="line">                <span class="hljs-keyword">default</span>:                    </span><br><span class="line">                    Toast(&#123;                        </span><br><span class="line">                        message: error.response.data.message,                        </span><br><span class="line">                        duration: <span class="hljs-number">1500</span>,                        </span><br><span class="line">                        forbidClick: <span class="hljs-literal">true</span>                    </span><br><span class="line">                    &#125;);            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error.response);        </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * get方法，对应get请求 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址] </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数] </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, params</span>)</span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;        </span><br><span class="line">        axios.get(url, &#123;            </span><br><span class="line">            params: params        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;            </span><br><span class="line">            resolve(res.data);        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;            </span><br><span class="line">            reject(err.data)        </span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * post方法，对应post请求 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;String&#125; url [请求的url地址] </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Object&#125; params [请求时携带的参数] </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>(<span class="hljs-params">url, params</span>) </span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;         </span><br><span class="line">        axios.post(url, QS.stringify(params))        </span><br><span class="line">        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;            </span><br><span class="line">            resolve(res.data);        </span><br><span class="line">        &#125;)        </span><br><span class="line">        .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;            </span><br><span class="line">            reject(err.data)        </span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>axios的封装根据需求的不同而不同。我也对此进行了思考和针对不同需求的改善。主要有以下改变：</p><ol><li>优化axios封装，去掉之前的get和post</li><li>断网情况处理</li><li>更加模块化的api管理</li><li>接口域名有多个的情况</li><li>api挂载到vue.prototype上省去引入的步骤</li></ol><p>http.js中axios封装的优化，先直接贴代码：</p><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * axios封装</span></span><br><span class="line"><span class="hljs-comment"> * 请求拦截、响应拦截、错误统一处理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'../router'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'../store/index'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> &#123; Toast &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vant'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 提示函数 </span></span><br><span class="line"><span class="hljs-comment"> * 禁止点击蒙层、显示一秒后关闭</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> tip = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> &#123;    </span><br><span class="line">    Toast(&#123;        </span><br><span class="line">        message: msg,        </span><br><span class="line">        duration: <span class="hljs-number">1000</span>,        </span><br><span class="line">        forbidClick: <span class="hljs-literal">true</span>    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 跳转登录页</span></span><br><span class="line"><span class="hljs-comment"> * 携带当前页面路由，以期在登录页面完成登录后返回当前页面</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> toLogin = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.replace(&#123;</span><br><span class="line">        path: <span class="hljs-string">'/login'</span>,        </span><br><span class="line">        query: &#123;</span><br><span class="line">            redirect: router.currentRoute.fullPath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 请求失败后的错误统一处理 </span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;Number&#125; status 请求失败的状态码</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> errorHandle = <span class="hljs-function">(<span class="hljs-params">status, other</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 状态码判断</span></span><br><span class="line">    <span class="hljs-keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="hljs-comment">// 401: 未登录状态，跳转登录页</span></span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:</span><br><span class="line">            toLogin();</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-comment">// 403 token过期</span></span><br><span class="line">        <span class="hljs-comment">// 清除token并跳转登录页</span></span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-number">403</span>:</span><br><span class="line">            tip(<span class="hljs-string">'登录过期，请重新登录'</span>);</span><br><span class="line">            localStorage.removeItem(<span class="hljs-string">'token'</span>);</span><br><span class="line">            store.commit(<span class="hljs-string">'loginSuccess'</span>, <span class="hljs-literal">null</span>);</span><br><span class="line">            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">                toLogin();</span><br><span class="line">            &#125;, <span class="hljs-number">1000</span>);</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-comment">// 404请求不存在</span></span><br><span class="line">        <span class="hljs-keyword">case</span> <span class="hljs-number">404</span>:</span><br><span class="line">            tip(<span class="hljs-string">'请求的资源不存在'</span>); </span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">default</span>:</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(other);   </span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 创建axios实例</span></span><br><span class="line"><span class="hljs-keyword">var</span> instance = axios.create(&#123;    timeout: <span class="hljs-number">1000</span> * <span class="hljs-number">12</span>&#125;);</span><br><span class="line"><span class="hljs-comment">// 设置post请求头</span></span><br><span class="line">instance.defaults.headers.post[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 请求拦截器 </span></span><br><span class="line"><span class="hljs-comment"> * 每次请求前，如果存在token则在请求头中携带token </span></span><br><span class="line"><span class="hljs-comment"> */</span> </span><br><span class="line">instance.interceptors.request.use(    </span><br><span class="line">    config =&gt; &#123;        </span><br><span class="line">        <span class="hljs-comment">// 登录流程控制中，根据本地是否存在token判断用户的登录情况        </span></span><br><span class="line">        <span class="hljs-comment">// 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token        </span></span><br><span class="line">        <span class="hljs-comment">// 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码        </span></span><br><span class="line">        <span class="hljs-comment">// 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。        </span></span><br><span class="line">        <span class="hljs-keyword">const</span> token = store.state.token;        </span><br><span class="line">        token &amp;&amp; (config.headers.Authorization = token);        </span><br><span class="line">        <span class="hljs-keyword">return</span> config;    </span><br><span class="line">    &#125;,    </span><br><span class="line">    error =&gt; <span class="hljs-built_in">Promise</span>.error(error))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 响应拦截器</span></span><br><span class="line">instance.interceptors.response.use(    </span><br><span class="line">    <span class="hljs-comment">// 请求成功</span></span><br><span class="line">    res =&gt; res.status === <span class="hljs-number">200</span> ? <span class="hljs-built_in">Promise</span>.resolve(res) : <span class="hljs-built_in">Promise</span>.reject(res),    </span><br><span class="line">    <span class="hljs-comment">// 请求失败</span></span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> &#123; response &#125; = error;</span><br><span class="line">        <span class="hljs-keyword">if</span> (response) &#123;</span><br><span class="line">            <span class="hljs-comment">// 请求已发出，但是不在2xx的范围 </span></span><br><span class="line">            errorHandle(response.status, response.data.message);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(response);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 处理断网的情况</span></span><br><span class="line">            <span class="hljs-comment">// eg:请求超时或断网时，更新state的network状态</span></span><br><span class="line">            <span class="hljs-comment">// network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏</span></span><br><span class="line">            <span class="hljs-comment">// 关于断网组件中的刷新重新获取数据，会在断网组件中说明</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.navigator.onLine) &#123;</span><br><span class="line">               store.commit(<span class="hljs-string">'changeNetwork'</span>, <span class="hljs-literal">false</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> instance;</span><br></pre></td></tr></table></figure><p>这个axios和之前的大同小异，做了如下几点改变：</p><ul><li>去掉了之前get和post方法的封装，通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。</li><li>去掉了通过环境变量控制baseUrl的值。考虑到接口会有多个不同域名的情况，所以准备通过js变量来控制接口域名。这点具体在api里会介绍。</li><li>增加了请求超时，即断网状态的处理。说下思路，当断网时，通过更新vuex中network的状态来控制断网提示组件的显示隐藏。断网提示一般会有重新加载数据的操作，这步会在后面对应的地方介绍。</li><li><p>公用函数进行抽出，简化代码，尽量保证单一职责原则。</p><p><strong>下面说下api这块，考虑到一下需求：</strong></p></li><li><p>更加模块化</p></li><li>更方便多人开发，有效减少解决命名冲突</li><li><p>处理接口域名有多个情况</p><p>这里这里呢新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。</p></li></ul><p>先放index.js代码：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * api接口的统一出口</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-comment">// 文章模块接口</span></span><br><span class="line"><span class="hljs-keyword">import</span> article <span class="hljs-keyword">from</span> <span class="hljs-string">'@/api/article'</span>;</span><br><span class="line"><span class="hljs-comment">// 其他模块的接口……</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 导出接口</span></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    </span><br><span class="line">    article,</span><br><span class="line">    <span class="hljs-comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js是一个api接口的出口，这样就可以把api接口根据功能划分为多个模块，利于多人协作开发，比如一个人只负责一个模块的开发等，还能方便每个模块中接口的命名哦。</p><p>base.js:</p><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 接口域名的管理</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">base</span> = &#123;    </span><br><span class="line">    sq: <span class="hljs-string">'https://xxxx111111.com/api/v1'</span>,    </span><br><span class="line">    bd: <span class="hljs-string">'http://xxxxx22222.com/api'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="hljs-keyword">default</span> <span class="hljs-keyword">base</span>;</span><br></pre></td></tr></table></figure><p>通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。</p><p>最后就是接口模块的说明，例如上面的article.js:</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * article模块接口列表</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> base <span class="hljs-keyword">from</span> <span class="hljs-string">'./base'</span>; <span class="hljs-comment">// 导入接口域名列表</span></span><br><span class="line"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/http'</span>; <span class="hljs-comment">// 导入http中创建的axios实例</span></span><br><span class="line"><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>; <span class="hljs-comment">// 根据需求是否导入qs模块</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> article = &#123;    </span><br><span class="line">    <span class="hljs-comment">// 新闻列表    </span></span><br><span class="line">    articleList () &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">`<span class="hljs-subst">$&#123;base.sq&#125;</span>/topics`</span>);    </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="hljs-comment">// 新闻详情,演示    </span></span><br><span class="line">    articleDetail (id, params) &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">`<span class="hljs-subst">$&#123;base.sq&#125;</span>/topic/<span class="hljs-subst">$&#123;id&#125;</span>`</span>, &#123;            </span><br><span class="line">            params: params        </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-comment">// post提交    </span></span><br><span class="line">    login (params) &#123;        </span><br><span class="line">        <span class="hljs-keyword">return</span> axios.post(<span class="hljs-string">`<span class="hljs-subst">$&#123;base.sq&#125;</span>/accesstoken`</span>, qs.stringify(params));    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 其他接口…………</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> article;</span><br></pre></td></tr></table></figure><ol><li>通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对<code>post</code>请求时提交的数据进行一个qs序列化的处理等。</li><li>请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，<code>axios</code>文档说的很清楚，这个顺序是：在 <code>lib/defaults.js</code> 找到的库的默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者将优先于前者。</li><li>restful风格的接口，也可以通过这种方式灵活的设置api接口地址。</li></ol><p>最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span></span><br><span class="line"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span></span><br><span class="line"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span> <span class="hljs-comment">// 导入路由文件</span></span><br><span class="line"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span> <span class="hljs-comment">// 导入vuex文件</span></span><br><span class="line"><span class="hljs-keyword">import</span> api <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span> <span class="hljs-comment">// 导入api接口</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$api = api; <span class="hljs-comment">// 将api挂载到vue的原型上</span></span><br></pre></td></tr></table></figure><p>然后我们可以在页面中这样调用接口，eg：</p><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;    </span><br><span class="line">    onLoad(id) &#123;      </span><br><span class="line">        this.<span class="hljs-variable">$api</span><span class="hljs-selector-class">.article</span><span class="hljs-selector-class">.articleDetail</span>(id, &#123;        </span><br><span class="line">            api: <span class="hljs-number">123</span>      </span><br><span class="line">        &#125;).then(res=&gt; &#123;</span><br><span class="line">            <span class="hljs-comment">// 执行某些操作      </span></span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再提一下断网的处理，这里只做一个简单的示例：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  </span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    </span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!network"</span>&gt;</span>      </span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我没网了<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      </span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"onRefresh"</span>&gt;</span>刷新<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      </span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    </span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span>      </span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>;</span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  </span></span><br><span class="line"><span class="hljs-actionscript">        name: <span class="hljs-string">'App'</span>,  </span></span><br><span class="line"><span class="hljs-undefined">        computed: &#123;    </span></span><br><span class="line"><span class="hljs-actionscript">            ...mapState([<span class="hljs-string">'network'</span>])  </span></span><br><span class="line"><span class="hljs-undefined">        &#125;,  </span></span><br><span class="line"><span class="hljs-undefined">        methods: &#123;    </span></span><br><span class="line"><span class="hljs-actionscript">            <span class="hljs-comment">// 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的</span></span></span><br><span class="line"><span class="hljs-undefined">            onRefresh () &#123;      </span></span><br><span class="line"><span class="hljs-actionscript">                <span class="hljs-keyword">this</span>.$router.replace(<span class="hljs-string">'/refresh'</span>)    </span></span><br><span class="line"><span class="hljs-undefined">            &#125;  </span></span><br><span class="line"><span class="hljs-undefined">        &#125;</span></span><br><span class="line"><span class="hljs-undefined">    &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其<code>beforeRouteEnter</code>钩子中再返回当前页面。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// refresh.vue</span></span><br><span class="line">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;</span><br><span class="line">    next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;            </span><br><span class="line">        vm.$router.replace(<span class="hljs-keyword">from</span>.fullPath)        </span><br><span class="line">    &#125;)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种全局通用的断网提示，当然了，也可以根据自己的项目需求操作。具体操作就仁者见仁智者见智了。</p><p>如果更多的需求，或者说是不一样的需求，可以根据自己的需求进行一个改进。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、axios的封装&quot;&gt;&lt;a href=&quot;#一、axios的封装&quot; class=&quot;headerlink&quot; title=&quot;一、axios的封装&quot;&gt;&lt;/a&gt;一、axios的封装&lt;/h1&gt;&lt;p&gt;在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://jdsheng.cn/tags/vue/"/>
    
      <category term="axios" scheme="https://jdsheng.cn/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>Git 基本知识与常用指令</title>
    <link href="https://jdsheng.cn/2019/10/01/Git%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://jdsheng.cn/2019/10/01/Git 基本知识与常用指令/</id>
    <published>2019-09-30T16:22:19.486Z</published>
    <updated>2019-10-02T03:30:11.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Git代码状态转换图"><a href="#一、Git代码状态转换图" class="headerlink" title="一、Git代码状态转换图"></a>一、Git代码状态转换图</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM3NTAzOC8yMDE4MDUvMTM3NTAzOC0yMDE4MDUyMjE2MDk0Mjc2NS0xNDg4MjU0MzkyLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>其中：</p><ul><li>未被Git跟踪的状态为unstage状态；<a id="more"></a></li><li><p>已被Git跟踪的状态为stage状态（stage：阶段），因此包括staging状态和staged状态。</p><p>untrack files：是指<strong>尚未被git所管理的文件</strong>；</p><p>changed but not updated：是指文件被git管理，并且发生了改变，但改动还没被git管理；这两种状态，都可以看成是改动还没被git管理的状态，我们这里称unstage状态。</p><p>staging是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。</p></li></ul><p>changes to be commited是指进入staged状态的文件。</p><p><code>.gitignore</code>中的文件，不会出现在以上三个状态中。</p><blockquote><p>注：</p><ul><li>这个图也解释了为啥从远端库拉代码，不需要add、commit。</li><li>代码一旦修改，就会成为未被git库跟踪的状态。需要add、commit。</li></ul></blockquote><h2 id="二、大白话Git"><a href="#二、大白话Git" class="headerlink" title="二、大白话Git"></a>二、大白话Git</h2><ol><li>Git 管理代码，保证代码版本迭代连续性，即：向A分支merge或者push代码时，A分支代码必须是当前代码的上一个版本，不然会产生冲突。（换句话说：Git确保当前的本地的代码为最新）</li><li>Git有修改就有提交，就有新的代码版本，git管理维护的是修改。</li><li>Git分支存储的是代码副本。</li><li><p>push ：实际上就是将本地分支合并到远端库分支；pull：实际就是将远端分支合并到本地分支。</p><h2 id="三、Git本地常用操作指令"><a href="#三、Git本地常用操作指令" class="headerlink" title="三、Git本地常用操作指令"></a>三、Git本地常用操作指令</h2></li></ol><p><strong>1、创建git库</strong></p><p>　<code>git init</code>   #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库）</p><p><strong>2、注册git用户</strong></p><p>—&gt;用于在团队合作开发中，表明代码作者。</p><p>　　</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git<span class="hljs-built_in"> config </span>--global user.name XXX  #用户名</span><br><span class="line"></span><br><span class="line">git<span class="hljs-built_in"> config </span>--global user.email XXX   #用户邮箱</span><br><span class="line"></span><br><span class="line">git<span class="hljs-built_in"> config </span>--list  #查看用户信息</span><br></pre></td></tr></table></figure><blockquote><p>注：加–global，全局设置。</p></blockquote><p><strong>3、向git库添加修改</strong></p><p><code>git add [path］</code> #会把对应目录或文件，添加到stage状态<br><code>git add .</code>  #会把当前所有的untrack files和changed but not updated添加到stage状态</p><p>实际上是为修改内容添加index索引。</p><p><strong>4、向版本库提交修改</strong></p><p><code>git commit –m “XXXX”</code>     #提交修改,添加注释</p><blockquote><p>注：git 提示： 未有add红色字体，未有commit绿色字体，已提交则worktree是干净的</p></blockquote><p><strong>5、查看当前代码库的状态</strong></p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git status</span></span><br></pre></td></tr></table></figure><p><strong>6、查看版本信息</strong></p><p>—&gt;实际是查看修改提交信息</p><figure class="highlight 1c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">log</span></span><br></pre></td></tr></table></figure><p><code>git log --graph</code>  #以图形化（节点）展示当前git库的提交信息。</p><p><strong>7、查看指定版本信息</strong></p><p><code>git show sdjf974654dd….</code>  #(show后面为每次提交系统自动生成的一串哈希值)</p><p><code>git show sdji97</code> #一般只使用版本号的前几个字符即可</p><p><strong>8、撤销修改</strong></p><figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">git reset</span></span><br></pre></td></tr></table></figure><p>（1）撤销整体修改</p><p><code>git reset --hard</code>  #回到原来编辑的地方,改动会丢失。（同样适用于团队对于其他人的修改恢复）<br><code>git reset --hard sdv143kvf…...</code> #可回到指定的版本#(hard后面为每次提交系统自动生成的一串哈希值)<br><code>git reset [path]</code> 会改变path指定的文件或目录的stage状态，到非stage状态。<br><code>git reset</code> 会将所有stage的文件状态，都改变成非stage状态。</p><p>（2）撤销某次修改</p><p>回退1个change的写法就是git reset HEAD^，<br>2个为HEAD^^，<br>3个为HEAD~3，以此类推。</p><p><strong>9、向远端库推送修改（提交修改）</strong></p><p><code>git push origin</code> 分支名</p><p><strong>10、暂存修改</strong></p><p>git stash可以把当前的改动（stage和unstage，但不包括untrack的文件）暂存。</p><p>然后通过git stash list查看。</p><p>并通过git stash apply重新取出来。但apply之前要保证worktree是干净的。</p><h2 id="四、Git团队开发常用操作指令"><a href="#四、Git团队开发常用操作指令" class="headerlink" title="四、Git团队开发常用操作指令"></a>四、Git团队开发常用操作指令</h2><p><strong>1、获取远端库项目</strong></p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  <span class="hljs-built_in">clone</span>/pull</span><br></pre></td></tr></table></figure><p><strong>2、团队开发的基本流程（多分支合并一个分支）</strong></p><p><code>git add .</code>   #添加改动的文件<br><code>git commit</code>  #（提交至本地）<br><code>git pull --rebase</code>  #（将服务器项目与本地项目合并）<br><code>git push</code>    #（将本地项目上传至远端库）<br>（在提交前要git pull –rebase 一下，确保当前的本地的代码为最新。）</p><h2 id="五、Git-分支管理"><a href="#五、Git-分支管理" class="headerlink" title="五、Git 分支管理"></a>五、Git 分支管理</h2><p><strong>1、建立分支</strong></p><p><code>git branch AAA</code>   #建立分支AAA</p><p><strong>2、分支切换</strong></p><p><code>git checkout AAA</code>   #从当前分支切换到AAA分支 (若AAA分支不存在，则自动新建)</p><p><strong>3、将分支与主枝master合并</strong></p><p><code>git checkout master</code>   #（首先切换回主枝）<br><code>git merge AAA</code>    #（将分支AAA与主枝合并）</p><blockquote><p>注：git merge：默认情况下，Git执行”快进式合并”（fast-farward<br>merge），会直接将Master分支指向Develop分支。</p></blockquote><p>使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰（保持提交曲线为直线），建议采用这种方法。</p><p><strong>4、当前分支查看</strong></p><p><code>git branch</code>    #默认有master（也称为主枝）<br><code>git branch -r</code>  #查看远端库分支<br><code>git branch –a</code>  #查看当前所有分支（包括本地分支和远端库分支）</p><p><strong>5、删除分支</strong></p><p><code>git branch –d  AAA</code>   #删除分支AAA</p><p><strong>6、切下远端库A分支到本地库A分支</strong></p><p><code>git checkout -b  A origin/A</code>  （若本地A分支不存在，则自动新建）</p><blockquote><p>注：上面只是一些基本的操作命令，更多的命令可通过帮助文档查询。</p></blockquote><p>帮助文档的使用：<br><code>man git-</code>&lt;需查询的指令&gt;  #（git后面有“-”）<br>如commit的查询为  <code>man git-commit</code></p><h2 id="六、本地代码上传Github"><a href="#六、本地代码上传Github" class="headerlink" title="六、本地代码上传Github"></a>六、本地代码上传Github</h2><ol><li>Gtthub上建立远端仓库，复制下载链接。</li><li>本地指定目录下，Gitbash粘贴远端仓库下载链接拉取远端仓库代码</li><li>复制本地需要提交的代码到远端仓库目录。</li><li><code>Git add、commit、push</code> 提交本地代码至Github远端仓库。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Git代码状态转换图&quot;&gt;&lt;a href=&quot;#一、Git代码状态转换图&quot; class=&quot;headerlink&quot; title=&quot;一、Git代码状态转换图&quot;&gt;&lt;/a&gt;一、Git代码状态转换图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTM3NTAzOC8yMDE4MDUvMTM3NTAzOC0yMDE4MDUyMjE2MDk0Mjc2NS0xNDg4MjU0MzkyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未被Git跟踪的状态为unstage状态；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="git" scheme="https://jdsheng.cn/categories/git/"/>
    
    
      <category term="git" scheme="https://jdsheng.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript语法（预备篇）：到底要不要写分号呢？</title>
    <link href="https://jdsheng.cn/2019/07/25/JavaScript%E8%AF%AD%E6%B3%95%EF%BC%88%E9%A2%84%E5%A4%87%E7%AF%87%EF%BC%89%EF%BC%9A%E5%88%B0%E5%BA%95%E8%A6%81%E4%B8%8D%E8%A6%81%E5%86%99%E5%88%86%E5%8F%B7%E5%91%A2%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/07/25/JavaScript语法（预备篇）：到底要不要写分号呢？/</id>
    <published>2019-07-25T14:34:54.007Z</published>
    <updated>2019-09-30T16:30:05.320Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>在我们介绍 JavaScript 语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。</p><br>  <p>这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。</p><a id="more"></a><br>  <p>实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。</p><br><br>  <p>但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。</p><br><br>  <p>这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。</p><br>  <p>我们首先来了解一下自动插入分号的规则。</p><br>  <h2>自动插入分号规则</h2><br>  <p>自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。</p><br>  <ul><br>    <li>要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</li><br>    <li>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</li><br>    <li>源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</li><br>  </ul><br>  <p>这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;(a);</span><br></pre></td></tr></table></figure><br><br><p>在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入换行符。</p><br><br><figure class="highlight asciidoc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 1, b = 1, c = 1;</span><br><span class="line">a</span><br><span class="line">++</span><br><span class="line">b</span><br><span class="line">++</span><br><span class="line">c</span><br></pre></td></tr></table></figure><br><br><p>这也是个著名的例子，我们看第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有 [no LineTerminator here] 这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容：</p><br><br><figure class="highlight hsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UpdateExpression[<span class="hljs-keyword">Yield</span>, <span class="hljs-keyword">Await</span>]:</span><br><span class="line">    LeftHandSideExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>]</span><br><span class="line">    LeftHandSideExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>][no LineTerminator here]++</span><br><span class="line">    LeftHandSideExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>][no LineTerminator here]--</span><br><span class="line">    ++UnaryExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>]</span><br><span class="line">    --UnaryExpression[?<span class="hljs-keyword">Yield</span>, ?<span class="hljs-keyword">Await</span>]</span><br></pre></td></tr></table></figure><br><br><p>于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。</p><br><br><figure class="highlight clojure hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-name">function</span>(<span class="hljs-name">a</span>)&#123;</span><br><span class="line">    console.log(<span class="hljs-name">a</span>)<span class="hljs-comment">;</span></span><br><span class="line">&#125;)()</span><br><span class="line">(<span class="hljs-name">function</span>(<span class="hljs-name">a</span>)&#123;</span><br><span class="line">    console.log(<span class="hljs-name">a</span>)<span class="hljs-comment">;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br><br><p>这个例子是比较有实际价值的例子，这里两个 function 调用的写法被称作 IIFE（立即执行的函数表达式），是个常见技巧。</p><p>这段代码意图上显然是形成两个 IIFE。</p><p>我们来看第三行结束的位置，JavaScript 引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。</p><p>这是一些鼓励不写分号的编码风格会要求大家写 IIFE 时必须在行首加分号的原因。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">        This is a return value.</span></span><br><span class="line"><span class="hljs-comment">    */</span><span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><br><br><p>在这个例子中，return 和 1 被用注释分隔开了。</p><p>根据 JavaScript 自动插入分号规则，<strong>带换行符的注释也被认为是有换行符</strong>，而恰好的是，return 也有 [no LineTerminator here] 规则的要求。所以这里会自动插入分号，f 执行的返回值是 undefined。</p><h2>no LineTerminator here 规则</h2><p>好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对 JavaScript 的语法定义做一些数据挖掘工作。</p><p>no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。</p><p>自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟 no LineTerminator here 规则强相关，那么我们就找出 JavaScript 语法定义中的这些规则。</p><p><img src="https://static001.geekbang.org/resource/image/c3/ad/c3ffbc89e049ad1901d4108c8ad88aad.jpg" alt=""></p><p>为了方便你理解，我把产生式换成了实际的代码。</p><p>下面一段代码展示了，带标签的 continue 语句，不能在 continue 后插入换行。</p><br><br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outer:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)</span><br><span class="line">        <span class="hljs-keyword">continue</span> <span class="hljs-comment">/*no LineTerminator here*/</span> outter</span><br></pre></td></tr></table></figure><br><br><p>break 跟 continue 是一样的，break 后也不能插入换行：</p><br><br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outer:<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; j; i++)</span><br><span class="line">        <span class="hljs-keyword">break</span> <span class="hljs-comment">/*no LineTerminator here*/</span> outter</span><br></pre></td></tr></table></figure><br><br><p>我们前面已经提到过 return 和后自增、后自减运算符。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight livecodeserver hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i<span class="hljs-comment">/*no LineTerminator here*/</span>++</span><br><span class="line">i<span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-comment">--</span></span><br></pre></td></tr></table></figure><br><br><p>以及，throw 和 Exception 之间也不能插入换行符：</p><br><br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">throw</span><span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-keyword">new</span> <span class="hljs-type">Exception</span>(<span class="hljs-string">"error"</span>)</span><br></pre></td></tr></table></figure><br><br><p>凡是 async 关键字，后面都不能插入换行符：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span><span class="hljs-comment">/*no LineTerminator here*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">async</span><span class="hljs-comment">/*no LineTerminator here*/</span>x =&gt; x*x</span><br></pre></td></tr></table></figure><br><br><p>箭头函数的箭头前，也不能插入换行：</p><br><br><figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> f = x<span class="hljs-comment">/*no LineTerminator here*/</span>=&gt; x*x</span><br></pre></td></tr></table></figure><br><br><p>yield 之后，不能插入换行：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)</span><br><span class="line">        <span class="hljs-keyword">yield</span><span class="hljs-comment">/*no LineTerminator here*/</span>i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>到这里，我已经整理了所有标准中的 no LineTerminator here 规则，实际上，no LineTerminator here 规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript 在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。</p><h2>不写分号需要注意的情况</h2><p>下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。</p><h3>以括号开头的语句</h3><p>我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;)()<span class="hljs-comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(a);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><br><br><p>这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。</p><h3>以数组开头的语句</h3><p>除了括号，以数组开头的语句也十分危险：</p><br><br><figure class="highlight lua hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="hljs-string">[[]]</span>/* 这里没有被自动插入分号 */</span><br><span class="line">[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>].forEach(e =&gt; console.<span class="hljs-built_in">log</span>(e))</span><br></pre></td></tr></table></figure><br><br><p>这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。</p><h3>以正则表达式开头的语句</h3><p>正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>, g = &#123;<span class="hljs-attr">test</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-number">0</span>&#125;, b = <span class="hljs-number">1</span><span class="hljs-comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">/(a)/g.test(<span class="hljs-string">"abc"</span>)</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure><br><br><p>这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。</p><p>注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。</p><h3>以 Template 开头的语句</h3><p>以 Template 开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> g = f<span class="hljs-comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line"><span class="hljs-string">`Template`</span>.match(<span class="hljs-regexp">/(a)/</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1</span>)</span><br></pre></td></tr></table></figure><br><br><p>这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。</p><h2>总结</h2><p>这一节课，我们讨论了要不要加分号的问题。</p><p>首先我们介绍了自动插入分号机制，又对 JavaScript 语法中的 no line terminator 规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。</p><p>最后留一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号。</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;在我们介绍 JavaScript 语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。&lt;/p&gt;&lt;br&gt;  &lt;p&gt;这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript词法：为什么12.toString会报错？</title>
    <link href="https://jdsheng.cn/2019/07/25/JavaScript%E8%AF%8D%E6%B3%95%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%8812.toString%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/07/25/JavaScript词法：为什么12.toString会报错？/</id>
    <published>2019-07-25T14:16:36.789Z</published>
    <updated>2019-10-02T03:33:00.450Z</updated>
    
    <content type="html"><![CDATA[<p><div class="_1kh1ihh6_0"><br>  文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。</div></p><p>  词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。<br>  <a id="more"></a><br>  从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。</p><p>  </p><h2>概述</h2><br>  我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：<br>  <ul><br>    <li>WhiteSpace 空白字符</li><br>    <li>LineTerminator 换行符</li><br>    <li>Comment 注释</li><br>    <li>Token 词<br>      <ul><br>        <li>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</li><br>        <li>Punctuator 符号，我们使用的运算符和大括号等符号。</li><br>        <li>NumericLiteral 数字直接量，就是我们写的数字。</li><br>        <li>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</li><br>        <li>Template 字符串模板，用反引号<code>`</code> 括起来的直接量。</li><br>      </ul><br>    </li><br>  </ul><p></p><p>  这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。<br>  首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。</p><p>  但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。</p><p>  JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的：</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>  理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。是否允许“ }”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：<br>  <ul><br>    <li>InputElementDiv；</li><br>    <li>InputElementRegExp；</li><br>    <li>InputElementRegExpOrTemplateTail；</li><br>    <li>InputElementTemplateTail。</li><br>  </ul><br>  为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为CommonToken。但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。</p><p>  对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。</p><p>  接下来我来给你详细介绍一下。</p><p>  </p><h3>空白符号Whitespace</h3><br>  说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。<br>  <ul><br>    <li><br>      <code>&lt;HT&gt;</code>(或称<code>&lt;TAB&gt;</code>) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \t 。<br>    </li><br>    <li><br>      <code>&lt;VT&gt;</code>是 U+000B，也就是垂直方向的 TAB 符 \v，这个字符在键盘上很难打出来，所以很少用到。<br>    </li><br>    <li><br>      <code>&lt;FF&gt;</code>是 U+000C，Form Feed，分页符，字符串直接量中写作 \f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。<br>    </li><br>    <li><br>      <code>&lt;SP&gt;</code>是 U+0020，就是最普通的空格了。<br>    </li><br>    <li><br>      <code>&lt;NBSP&gt;</code>是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript<br>      编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 <code>&amp;nbsp;</code> 最后生成的就是它了。<br>    </li><br>    <li><br>      <code>&lt;ZWNBSP&gt;</code>(旧称<code>&lt;BOM&gt;</code>) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。<br>    </li><br>  </ul><br>  此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表：<br>  <img src="https://static001.geekbang.org/resource/image/dd/60/dd26aa9599b61d26e7de807dee2c6360.png" alt="">很多公司的编码规范要求JavaScript 源代码控制在 ASCII 范围内，那么，就只有<code>&lt;TAB&gt;</code> <code>&lt;VT&gt;</code> <code>&lt;FF&gt;</code><code>&lt;SP&gt;</code> <code>&lt;NBSP&gt;</code>五种空白可用了。<h3>换行符 LineTerminator</h3>接下来我们来看看换行符，JavaScript 中只提供了 4种字符作为换行符。<br>  <ul><br>    <li><code>&lt;LF&gt;</code></li><br>    <li><code>&lt;CR&gt;</code></li><br>    <li><code>&lt;LS&gt;</code></li><br>    <li><code>&lt;PS&gt;</code></li><br>  </ul><br>  其中，<br>  <code>&lt;LF&gt;</code>是 U+000A，就是最正常换行符，在字符串中的<code>\n</code>。<p></p><p>  <code>&lt;CR&gt;</code>是U+000D，这个字符真正意义上的“回车”，在字符串中是<code>\r</code>，在一部分 Windows 风格文本编辑器中，换行是两个字符<code>\r\n</code>。</p><p>  <code>&lt;LS&gt;</code>是U+2028，是 Unicode 中的行分隔符。</p><p>  <code>&lt;PS&gt;</code>是 U+2029，是 Unicode 中的段落分隔符。</p><p>  大部分 LineTerminator在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。</p><p>  </p><h3>注释 Comment</h3><br>  JavaScript的注释分为单行注释和多行注释两种：<p></p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* MultiLineCommentChars */</span></span><br><span class="line"><span class="hljs-comment">// SingleLineCommentChars</span></span><br></pre></td></tr></table></figure><p>  多行注释中允许自由地出现<code>MultiLineNotAsteriskChar</code>，也就是除了<code><em></em></code>之外的所有字符。而每一个<code></code>之后，不能出现正斜杠符<code>/</code>。除了四种LineTerminator 之外，所有字符都可以作为单行注释。我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。</p><p>  </p><h2>标识符名称 IdentifierName</h2><br>  <code>IdentifierName</code>可以以美元符“<code>$</code>”、下划线“<code>_</code>”或者 Unicode字母开始，除了开始字符以外，<code>IdentifierName</code>中还可以使用 Unicode 中的连接标记、数字、以及连接符号。<p></p><p>  <code>IdentifierName</code>的任意字符可以使用JavaScript 的 Unicode 转义写法，使用 Unicode转义写法时，没有任何字符限制。</p><p>  <code>IdentifierName</code>可以是<code>Identifier</code>、<code>NullLiteral</code><code>BooleanLiteral</code>或者<code>keyword</code>，在<code>ObjectLiteral</code>中，<code>IdentifierName</code>还可以被直接当做属性名称使用。</p><p>  仅当不是保留字的时候，<code>IdentifierName</code>会被解析为<code>Identifier</code>。</p><p>  注意<code>&lt;ZWNJ&gt;</code>和<code>&lt;ZWJ&gt;</code>是ES5 新加入的两个格式控制字符，它们都是 0 宽的。</p><p>  我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有:</p>  <figure class="highlight d hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await <span class="hljs-keyword">break</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">catch</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">continue</span> debugger <span class="hljs-keyword">default</span> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">export</span> extends <span class="hljs-keyword">finally</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">function</span> <span class="hljs-keyword">if</span></span><br><span class="line"><span class="hljs-keyword">import</span> ininstance of <span class="hljs-keyword">new</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span> <span class="hljs-keyword">switch</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">typeof</span> var <span class="hljs-keyword">void</span> <span class="hljs-keyword">while</span> <span class="hljs-keyword">with</span> yield</span><br></pre></td></tr></table></figure><p>  除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:</p>  <figure class="highlight crystal hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><br></pre></td></tr></table></figure><p>  在严格模式下, 有一些额外的为未来使用而保留的关键字:</p>  <figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implements package protected<span class="hljs-built_in"> interface </span>private public</span><br></pre></td></tr></table></figure><p>  除了这些之外，<code>NullLiteral</code>（<code>null</code>）和<code>BooleanLiteral</code>（<code>true false</code>）也是保留字，不能用于<code>Identifier</code>。</p><h3>符号 Punctuator</h3>因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为DivPunctuator，因为前面提到的字符串模板问题，<code>}</code>也被独立拆分。加在一起，所有符号为：<p></p>  <figure class="highlight gherkin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; ( ) [ ] . ... ; , <span class="hljs-variable">&lt;&gt;</span></span><br><span class="line"><span class="hljs-variable">&lt;=&gt;</span>= == != === !== + - <span class="hljs-symbol">*</span> % <span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> ++ -- <span class="hljs-variable">&lt;&lt;&gt;</span>&gt; &gt;&gt;&gt; &amp; |<span class="hljs-string"> ^ ! ~ &amp;&amp; </span>||<span class="hljs-string"> ? : = += -= *= %= **= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= &amp;= </span>|<span class="hljs-string">= ^= =&gt; / /= &#125;</span></span><br></pre></td></tr></table></figure><p>  </p><h3>数字直接量 NumericLiteral</h3><br>  我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。十进制的 Number可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：<p></p>  <figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">.01</span></span><br><span class="line"><span class="hljs-number">12.</span></span><br><span class="line"><span class="hljs-number">12.01</span></span><br></pre></td></tr></table></figure><p>  这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：</p>  <figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12<span class="hljs-selector-class">.toString</span>()</span><br></pre></td></tr></table></figure><p>  这时候<code>12.</code> 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：</p>  <figure class="highlight basic hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">12 </span>.toString()</span><br></pre></td></tr></table></figure><p>  数字直接量还支持科学计数法，例如：</p>  <figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0xFA</span></span><br><span class="line"><span class="hljs-number">0o73</span></span><br><span class="line"><span class="hljs-number">0b10000</span></span><br></pre></td></tr></table></figure><p>  这里 e 后面的部分，只允许使用整数。当以<code>0x</code> <code>0b</code> 或者<code>0o</code> 开头时，表示特定进制的整数：</p>  <figure class="highlight maxima hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">0xFA</span></span><br><span class="line"><span class="hljs-number">0o73</span></span><br><span class="line"><span class="hljs-number">0b10000</span></span><br></pre></td></tr></table></figure><p>  上面这几种进制都不支持小数，也不支持科学计数法。</p><h3>字符串直接量 StringLiteral</h3>JavaScript 中的 StringLiteral 支持单引号和双引号两种写法。<p></p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">" DoubleStringCharacters "</span></span><br><span class="line"><span class="hljs-string">' SingleStringCharacters '</span></span><br></pre></td></tr></table></figure><p>  单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是<code>\</code>和所有换行符。JavaScript中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。第一种是单字符转义。</p><p>  即一个反斜杠<code>\</code>后面跟一个字符这种形式。有特别意义的字符包括有<code>SingleEscapeCharacter</code>所定义的 9 种，见下表：<img src="https://static001.geekbang.org/resource/image/02/75/022c2c77d0a3c846ad0d61b48c4e0e75.png" alt="">除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过<code>\</code>转义后都是自身。</p><p>  </p><h3>正则表达式直接量 RegularExpressionLiteral</h3><br>  正则表达式由 Body 和Flags 两部分组成，例如：<p></p>  <figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-regexp">/RegularExpressionBody/g</span></span><br></pre></td></tr></table></figure><p>  其中 Body 部分至少有一个字符，第一个字符不能是 <em>（因为 /</em>跟多行注释有词法冲突）。正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。正则表达式并非机械地见到<code>/</code>就停止，在正则表达式<code>[]</code>中的<code>/</code>就会被认为是普通字符。我们可以看一个例子：</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[<span class="hljs-regexp">/]/</span>.test(<span class="hljs-string">"/"</span>);</span><br></pre></td></tr></table></figure><p>  除了<code>\</code>、<code>/</code> 和<code>[</code> 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。用\和一个非换行符可以组成一个转义，<code>[]</code>中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。</p><p>  </p><h3>字符串模板 Template</h3><br>  从语法结构上，Template 是个整体，其中的 <code>${ }</code> 是并列关系。但是实际上，在JavaScript 词法中，包含 <code>${ }</code> 的 Template，是被拆开分析的，如：<p></p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">`a<span class="hljs-subst">$&#123;b&#125;</span>c<span class="hljs-subst">$&#123;d&#125;</span>e`</span></span><br></pre></td></tr></table></figure><p>  它在 JavaScript 中被认为是：</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">`a<span class="hljs-subst">$&#123;</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">b</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">&#125;</span>c<span class="hljs-subst">$&#123;</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">d</span></span></span><br><span class="line"><span class="hljs-string"><span class="hljs-subst">&#125;</span>e`</span></span><br></pre></td></tr></table></figure><p>  它被拆成了五个部分：<br>  <ul><br>    <li><code><code>a${&lt;/code&gt; 这个被称为模板头&lt;/li&gt;    &lt;li&gt;&lt;code&gt;}c${&lt;/code&gt; 被称为模板中段&lt;/li&gt;    &lt;li&gt;&lt;code&gt;}e</code></code> 被称为模板尾</li><br>    <li><code>b</code> 和 <code>d</code> 都是普通标识符</li><br>  </ul><br>  实际上，这里的词法分析过程已经跟语法分析深度耦合了。不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：</p>  <figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-string">"world"</span></span><br><span class="line">f<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;a&#125;</span>!`</span>; <span class="hljs-comment">// [["Hello", "!"], world]</span></span><br></pre></td></tr></table></figure><p>  模板字符串不需要关心大多数字符的转义，但是至少 <code>${</code> 和 <code>`</code> 还是需要处理的。模板中的转义跟字符串几乎完全一样，都是使用 <code>\</code>。</p><p>  </p><h2>总结</h2><br>  今天我们一起学习 JavaScript的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。最后，留一个问题：用零宽空格和零宽连接符、零宽非连接符，写一段好玩的代码。<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;  词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue常见问题及解决方法（一）</title>
    <link href="https://jdsheng.cn/2019/07/10/vue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jdsheng.cn/2019/07/10/vue常见问题及解决方法（一）/</id>
    <published>2019-07-10T15:40:30.935Z</published>
    <updated>2019-10-22T14:13:37.206Z</updated>
    
    <content type="html"><![CDATA[<ul><li>列表进入详情页的传参问题</li><li>路由懒加载（也叫延迟加载）<a id="more"></a></li></ul><h2 id="列表进入详情页的传参问题"><a href="#列表进入详情页的传参问题" class="headerlink" title="列表进入详情页的传参问题"></a>列表进入详情页的传参问题</h2><p><em>关联知识点</em>  ——<strong>路由跳转的方式</strong><br>声明式的跳转：</p><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml">// query通过path切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;path: 'Detail', query: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">// params通过name切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;name: 'Detail', params: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>编程式的跳转：</p><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//跳转到上一次浏览的页面</span></span><br><span class="line"> <span class="hljs-keyword">this</span>.$router.go(<span class="hljs-number">-1</span>)</span><br><span class="line">           </span><br><span class="line"><span class="hljs-comment">//指定跳转的地址，我们自己设置的路由地址</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$router.replace(<span class="hljs-string">'/pathname'</span>)</span><br><span class="line">           </span><br><span class="line"><span class="hljs-comment">//指定跳转路由的名字下，pathname是我们自身为路由设置的名字</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$router.replace(&#123;name:<span class="hljs-string">"pathname"</span>&#125;)</span><br><span class="line">          </span><br><span class="line"><span class="hljs-comment">//通过push进行跳转，我们自己设置的路由地址或者我们自己设置的名字</span></span><br><span class="line"><span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">'/pathname'</span>)</span><br><span class="line"><span class="hljs-keyword">this</span>.$router.push(&#123;name:<span class="hljs-string">'pathname'</span>&#125;)</span><br><span class="line"><span class="hljs-keyword">this</span>.$router.push(&#123; path: <span class="hljs-string">'/pathname/$&#123;id&#125;'</span>&#125;) <span class="hljs-comment">//id为参数</span></span><br></pre></td></tr></table></figure><p><strong>传参的方式</strong>：query、params+动态路由传参</p><p><strong>两者的区别：</strong></p><ol><li><p>query通过<code>path</code>切换路由，params通过<code>name</code>切换路由</p><figure class="highlight dust hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-xml">// query通过path切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;path: 'Detail', query: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">// params通过name切换路由</span></span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"</span></span></span><span class="hljs-template-variable">&#123;name: 'Detail', params: &#123; id: 1 &#125;</span><span class="hljs-xml"><span class="hljs-tag"><span class="hljs-string">&#125;"</span>&gt;</span>前往Detail页面<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>query通过<code>this.$route.query</code>来接收参数，params通过<code>this.$route.params</code>来接收参数。</p><figure class="highlight objectivec hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// query通过this.$route.query接收参数</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">id</span> = <span class="hljs-keyword">this</span>.$route.query.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// params通过this.$route.params来接收参数</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> <span class="hljs-keyword">id</span> = <span class="hljs-keyword">this</span>.$route.params.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>query传参的url展现方式：<code>/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数</code><br>  params＋动态路由的url方式：<code>/detail/123</code></p></li><li><p>params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面，而query传参则不用：</p><p><em>对应的路由配置：</em></p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;      </span><br><span class="line">    <span class="hljs-attribute">path</span>: <span class="hljs-string">'/detail/:id'</span>,      </span><br><span class="line">    name: <span class="hljs-string">'Detail'</span>,      </span><br><span class="line">    component: Detail    </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><pre><code>  注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如：<figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 定义的路由中，只定义一个id参数</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="hljs-string">'detail/:id'</span>,</span><br><span class="line">    name: <span class="hljs-string">'Detail'</span>,</span><br><span class="line">    components: Detail</span><br><span class="line">&#125;      </span><br><span class="line"><span class="hljs-comment">// template中的路由传参，</span></span><br><span class="line"><span class="hljs-comment">// 传了一个id参数和一个token参数</span></span><br><span class="line"><span class="hljs-comment">// id是在路由中已经定义的参数，而token没有定义</span></span><br><span class="line">&lt;router-link :to=<span class="hljs-string">"&#123;name: 'Detail', params: &#123; id: 1, token: '123456' &#125;&#125;"</span>&gt;前往Detail页面&lt;/router-link&gt;</span><br><span class="line"><span class="hljs-comment">// 在详情页接收</span></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="hljs-comment">// 以下都可以正常获取到</span></span><br><span class="line">    <span class="hljs-comment">// 但是页面刷新后，id依然可以获取，而token此时就不存在了</span></span><br><span class="line">    <span class="hljs-keyword">const</span> id = <span class="hljs-keyword">this</span>.$route.<span class="hljs-keyword">params</span>.id;</span><br><span class="line">    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">this</span>.$route.<span class="hljs-keyword">params</span>.token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>参考：</p><ol><li><a href="https://segmentfault.com/a/1190000012393587" target="_blank" rel="noopener">vue路由传参的三种基本方式</a></li><li><a href="https://blog.csdn.net/gqzydh/article/details/81453990" target="_blank" rel="noopener">vue 关于路由跳转方法</a></li></ol><h2 id="路由懒加载（也叫延迟加载）"><a href="#路由懒加载（也叫延迟加载）" class="headerlink" title="路由懒加载（也叫延迟加载）"></a>路由懒加载（也叫延迟加载）</h2><p>路由懒加载可以帮我们在进入首屏时不用加载过度的资源，从而减少首屏加载速度。在路由文件中，</p><p>非懒加载写法：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Index <span class="hljs-keyword">from</span> <span class="hljs-string">'@/page/index/index'</span>;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  </span><br><span class="line">    routes: [    </span><br><span class="line">        &#123; </span><br><span class="line">            path: <span class="hljs-string">'/'</span>, </span><br><span class="line">            name: <span class="hljs-string">'Index'</span>,     </span><br><span class="line">            component: Index </span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由懒加载写法：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Router</span>(&#123;</span><br><span class="line">  <span class="hljs-attribute">routes</span>: [    </span><br><span class="line">        &#123; </span><br><span class="line">            path: <span class="hljs-string">'/'</span>, </span><br><span class="line">            name: <span class="hljs-string">'Index'</span>, </span><br><span class="line">            component: resolve =&gt; <span class="hljs-built_in">require</span>([<span class="hljs-string">'@/view/index/index'</span>], resolve) </span><br><span class="line">        &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;列表进入详情页的传参问题&lt;/li&gt;
&lt;li&gt;路由懒加载（也叫延迟加载）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="https://jdsheng.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象：你知道全部的对象分类吗？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%BD%A0%E7%9F%A5%E9%81%93%E5%85%A8%E9%83%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E5%90%97%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript对象：你知道全部的对象分类吗？/</id>
    <published>2019-03-25T13:23:21.397Z</published>
    <updated>2019-09-30T16:28:42.926Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><p>前面讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。</p><p>比如说，<a id="more"></a>我们不论怎样编写代码，都没法绕开 Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的 length 属性。</p><p>并且，在浏览器环境中，我们也无法单纯依靠 JavaScript 代码实现 div 对象，只能靠 document.createElement 来创建。这也说明了 JavaScript 的对象机制并非简单的属性集合 + 原型。</p><p>我们日常工作中，接触到的主要 API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的 API 的一些特性。</p><br><br><h2>JavaScript 中的对象分类</h2><p>我们可以把对象分成几类。</p><ul><br><li><br><p>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</p><br></li><br><li><br><p>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。</p><br><ul><br><li>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</li><br><li>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li><br><li>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li><br></ul><br></li><br></ul><!-- [[[read_end]]] --><p>下面我会为你一一讲解普通对象之外的对象类型。</p><h3>宿主对象</h3><p>首先我们来看看宿主对象。</p><p>JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。</p><p>在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。</p><p>实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。</p><p>JavaScript 标准中规定了全局对象属性，w3c 的各种标准中规定了 Window 对象的其它属性。</p><p>宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 dom 对象。</p><p>宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素，这些我们会在浏览器的 API 部分详细讲解。</p><h2>内置对象·固有对象</h2><p>我们在前面说过，固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p><p>固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。</p><p>ECMA 标准为我们提供了一份固有对象表，里面含有 150+ 个固有对象。你可以通过<a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects" target="_blank" rel="noopener">这个链接</a>查看。</p><p>但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部 JavaScript 固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。</p><h2>内置对象·原生对象</h2><p>我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。</p><p><img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" alt=""></p><p>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。<br><br>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。</p><p>这些构造器创建的对象多数使用了私有字段, 例如：</p><ul><br><li>Error: [[ErrorData]]</li><br><li>Boolean: [[BooleanData]]</li><br><li>Number: [[NumberData]]</li><br><li>Date: [[DateValue]]</li><br><li>RegExp: [[RegExpMatcher]]</li><br><li>Symbol: [[SymbolData]]</li><br><li>Map: [[MapData]]</li><br></ul><p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。</p><h2>用对象来模拟函数与构造器：函数对象与构造器对象</h2><p>我在前面介绍了对象的一般分类，在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。</p><p>事实上，JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。</p><p>函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。</p><p>JavaScript 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有 [[call]] 私有字段的对象”，就可以被 JavaScript 函数调用语法支持。</p><blockquote><br><p><span class="reference">[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。</span></p><br></blockquote><p>我们可以这样说，任何对象只需要实现 [[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 [[construct]]，它就是一个构造器对象，可以作为构造器被调用。</p><p>对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如 Symbol 函数）可以模拟函数和构造器。</p><p>当然了，用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。</p><p>对于宿主和内置对象来说，它们实现 [[call]]（作为函数被调用）和 [[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>())</span><br></pre></td></tr></table></figure><br><br><p>而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。</p><br><br><figure class="highlight sqf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="hljs-built_in">log</span>(new <span class="hljs-built_in">Image</span>); </span><br><span class="line">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Image</span>());<span class="hljs-comment">// 抛出错误</span></span><br></pre></td></tr></table></figure><br><br><p>再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。</p><p>值得一提的是，在 ES6 之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> (<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-number">0</span>) <span class="hljs-comment">// error</span></span><br></pre></td></tr></table></figure><br><br><p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]] 和 [[construct]] 行为总是相似的，它们执行同一段代码。</p><p>我们看一下示例。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> v = f(); <span class="hljs-comment">// 把 f 作为函数调用</span></span><br><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> f(); <span class="hljs-comment">// 把 f 作为构造器调用</span></span><br></pre></td></tr></table></figure><br><br><p>我们大致可以认为，它们 [[construct]] 的执行过程如下：</p><ul><br><li>以 Object.protoype 为原型创建一个新对象；</li><br><li>以新对象为 this，执行函数的 [[call]]；</li><br><li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li><br></ul><p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cls</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">100</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        getValue:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> cls;</span><br><span class="line">o.getValue(); <span class="hljs-comment">//100</span></span><br><span class="line"><span class="hljs-comment">//a 在外面永远无法访问到</span></span><br></pre></td></tr></table></figure><br><br><h2>特殊行为的对象</h2><p>除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。</p><ul><br><li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li><br><li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li><br><li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li><br><li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li><br><li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><br><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><br><li>bind 后的 function：跟原来的函数相关联。</li><br></ul><h2>总结</h2><p>在这篇文章中，我们介绍了一些不那么常规的对象，并且我还介绍了 JavaScript 中用对象来模拟函数和构造器的机制。</p><p>这是一些不那么有规律、不那么优雅的知识，而 JavaScript 正是通过这些对象，提供了很多基础的能力。</p><p>我们这次课程留给大家一个挑战任务：不使用 new 运算符，尽可能找到获得对象的方法。</p><p>例子：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;&#125;</span><br><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><br><br><p>请大家把自己的答案留言给我，我们来比比看谁找到的多。</p><h2>小实验：获取全部 JavaScript 固有对象</h2><p>我们从 JavaScript 标准中可以找到全部的 JS 对象定义。JS 语言规定了全局对象的属性。</p><p>三个值：<br><br>Infinity、NaN、undefined。</p><p>九个函数：</p><ul><br><li>eval</li><br><li>isFinite</li><br><li>isNaN</li><br><li>parseFloat</li><br><li>parseInt</li><br><li>decodeURI</li><br><li>decodeURIComponent</li><br><li>encodeURI</li><br><li>encodeURIComponent</li><br></ul><p>一些构造器：<br><br>Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeapSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError<br><br>URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。</p><p>四个用于当作命名空间的对象：</p><ul><br><li>Atomics</li><br><li>JSON</li><br><li>Math</li><br><li>Reflect</li><br></ul><p>我们使用广度优先搜索，查找这些对象所有的属性和 Getter/Setter，就可以获得 JavaScript 中所有的固有对象。</p><p>请你试着先不看我的代码，在自己的浏览器中计算出来 JavaScript 有多少固有对象。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line"><span class="hljs-keyword">var</span> objects = [</span><br><span class="line">    <span class="hljs-built_in">eval</span>,</span><br><span class="line">    <span class="hljs-built_in">isFinite</span>,</span><br><span class="line">    <span class="hljs-built_in">isNaN</span>,</span><br><span class="line">    <span class="hljs-built_in">parseFloat</span>,</span><br><span class="line">    <span class="hljs-built_in">parseInt</span>,</span><br><span class="line">    <span class="hljs-built_in">decodeURI</span>,</span><br><span class="line">    <span class="hljs-built_in">decodeURIComponent</span>,</span><br><span class="line">    <span class="hljs-built_in">encodeURI</span>,</span><br><span class="line">    <span class="hljs-built_in">encodeURIComponent</span>,</span><br><span class="line">    <span class="hljs-built_in">Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Date</span>,</span><br><span class="line">    <span class="hljs-built_in">RegExp</span>,</span><br><span class="line">    <span class="hljs-built_in">Promise</span>,</span><br><span class="line">    <span class="hljs-built_in">Proxy</span>,</span><br><span class="line">    <span class="hljs-built_in">Map</span>,</span><br><span class="line">    <span class="hljs-built_in">WeakMap</span>,</span><br><span class="line">    <span class="hljs-built_in">Set</span>,</span><br><span class="line">    <span class="hljs-built_in">WeakSet</span>,</span><br><span class="line">    <span class="hljs-built_in">Function</span>,</span><br><span class="line">    <span class="hljs-built_in">Boolean</span>,</span><br><span class="line">    <span class="hljs-built_in">String</span>,</span><br><span class="line">    <span class="hljs-built_in">Number</span>,</span><br><span class="line">    <span class="hljs-built_in">Symbol</span>,</span><br><span class="line">    <span class="hljs-built_in">Object</span>,</span><br><span class="line">    <span class="hljs-built_in">Error</span>,</span><br><span class="line">    <span class="hljs-built_in">EvalError</span>,</span><br><span class="line">    <span class="hljs-built_in">RangeError</span>,</span><br><span class="line">    <span class="hljs-built_in">ReferenceError</span>,</span><br><span class="line">    <span class="hljs-built_in">SyntaxError</span>,</span><br><span class="line">    <span class="hljs-built_in">TypeError</span>,</span><br><span class="line">    <span class="hljs-built_in">URIError</span>,</span><br><span class="line">    <span class="hljs-built_in">ArrayBuffer</span>,</span><br><span class="line">    SharedArrayBuffer,</span><br><span class="line">    <span class="hljs-built_in">DataView</span>,</span><br><span class="line">    <span class="hljs-built_in">Float32Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Float64Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Int8Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Int16Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Int32Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint8Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint16Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint32Array</span>,</span><br><span class="line">    <span class="hljs-built_in">Uint8ClampedArray</span>,</span><br><span class="line">    Atomics,</span><br><span class="line">    <span class="hljs-built_in">JSON</span>,</span><br><span class="line">    <span class="hljs-built_in">Math</span>,</span><br><span class="line">    <span class="hljs-built_in">Reflect</span>];</span><br><span class="line">objects.forEach(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> set.add(o));</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> o = objects[i]</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(o)) &#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(o, p)</span><br><span class="line">        <span class="hljs-keyword">if</span>( (d.value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> d.value === <span class="hljs-string">"object"</span>) || (<span class="hljs-keyword">typeof</span> d.value === <span class="hljs-string">"function"</span>))</span><br><span class="line">            <span class="hljs-keyword">if</span>(!set.has(d.value))</span><br><span class="line">                set.add(d.value), objects.push(d.value);</span><br><span class="line">        <span class="hljs-keyword">if</span>( d.get )</span><br><span class="line">            <span class="hljs-keyword">if</span>(!set.has(d.get))</span><br><span class="line">                set.add(d.get), objects.push(d.get);</span><br><span class="line">        <span class="hljs-keyword">if</span>( d.set )</span><br><span class="line">            <span class="hljs-keyword">if</span>(!set.has(d.set))</span><br><span class="line">                set.add(d.set), objects.push(d.set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;p&gt;前面讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。&lt;/p&gt;&lt;p&gt;比如说，&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象：我们真的需要模拟类吗？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%A8%A1%E6%8B%9F%E7%B1%BB%E5%90%97%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript对象：我们真的需要模拟类吗？/</id>
    <published>2019-03-25T13:04:29.033Z</published>
    <updated>2019-10-02T03:33:23.500Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。</p><br>  <p>在上一篇文章我们已经讲到，JavaScript <a id="more"></a>本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。</p><br><br>  <p>那么，随着我们理解的思路继续深入，这些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。</p><br>  <p>尽管我认为，“类”并非面向对象的全部，但我们不应该责备社区出现这样的方案，事实上，因为一些公司的政治原因，JavaScript 推出之时，管理层就要求它去模仿 Java。</p><br><br>  <p>所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来语法更像 Java”，而 Java 正是基于类的面向对象的代表语言之一。</p><br>  <p>但是 JavaScript 这样的半吊子模拟，缺少了继承等关键特性，导致大家试图对它进行修补，进而产生了种种互不相容的解决方案。</p><br>  <p>庆幸的是，从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。</p><br><br>  <p>实际上，我认为“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。</p><br>  <p>我们从头讲起。</p><br>  <h2>什么是原型？</h2><br>  <p>原型是顺应人类自然思维的产物。中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。</p><br>  <p>我们在上一节讲解面向对象的时候提到了：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。</p><br>  <p>最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。</p><br>  <p>还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。</p><br>  <p>“基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。</p><br>  <p>与此相对，“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p><br>  <p>基于原型的面向对象系统通过“复制”的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。</p><br>  <p>基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。</p><br>  <p><br>    这就像专业人士可能喜欢在看到老虎的时候，喜欢用猫科豹属豹亚种来描述它，但是对一些不那么正式的场合，“大猫”可能更为接近直观的感受一些（插播一个冷知识：比起老虎来，美洲狮在历史上相当长时间都被划分为猫科猫属，所以性格也跟猫更相似，比较亲人）。<br>  </p><br>  <p>我们的 JavaScript 并非第一个使用原型的语言，在它之前，self、kevo 等语言已经开始使用原型来描述对象了。</p><br>  <p>事实上，Brendan 更是曾透露过，他最初的构想是一个拥有基于原型的面向对象能力的 scheme 语言（但是函数式的部分是另外的故事，这篇文章里，我暂时不做详细讲述）。</p><br>  <p>在 JavaScript 之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，我想，这应该是 Brendan 选择原型系统很重要的理由。</p><br>  <p>原型系统的“复制操作”有两种实现思路：</p><br>  <ul><br>    <li><br>      <p>一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；</p><br>    </li><br>    <li><br>      <p>另一个是切实地复制对象，从此两个对象再无关联。</p><br>    </li><br>  </ul><br>  <p>历史上的基于原型语言因此产生了两个流派，显然，JavaScript 显然选择了前一种方式。</p><br>  <h2>JavaScript 的原型</h2><br>  <p>如果我们抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，我可以用两条概括：</p><br>  <ul><br>    <li>如果所有对象都有私有字段 [[prototype]]，就是对象的原型；</li><br>    <li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li><br>  </ul><br>  <p>这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为：</p><br>  <ul><br>    <li>Object.create 根据指定的原型创建新对象，原型可以是 null；</li><br>    <li>Object.getPrototypeOf 获得一个对象的原型；</li><br>    <li>Object.setPrototypeOf 设置一个对象的原型。</li><br>  </ul><br>  <p>利用这三个方法，我们可以完全抛开类的思维，利用原型来实现抽象和复用。我用下面的代码展示了用原型来抽象猫和虎的例子。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> cat = &#123;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"meow~"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    jump()&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"jump"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> tiger = <span class="hljs-built_in">Object</span>.create(cat,  &#123;</span><br><span class="line">    say:&#123;</span><br><span class="line">        writable:<span class="hljs-literal">true</span>,</span><br><span class="line">        configurable:<span class="hljs-literal">true</span>,</span><br><span class="line">        enumerable:<span class="hljs-literal">true</span>,</span><br><span class="line">        value:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"roar!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> anotherCat = <span class="hljs-built_in">Object</span>.create(cat);</span><br><span class="line"></span><br><span class="line">anotherCat.say();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> anotherTiger = <span class="hljs-built_in">Object</span>.create(tiger);</span><br><span class="line"></span><br><span class="line">anotherTiger.say();</span><br></pre></td></tr></table></figure><br><br><p>这段代码创建了一个“猫”对象，又根据猫做了一些修改创建了虎，之后我们完全可以用 Object.create 来创建另外的猫和虎对象，我们可以通过“原始猫对象”和“原始虎对象”来控制所有猫和虎的行为。</p><p>但是，在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，可以说非常别扭。</p><p>考虑到 new 和 prototype 属性等基础设施今天仍然有效，而且被很多代码使用，学习这些知识也有助于我们理解运行时的原型工作原理，下面我们试着回到过去，追溯一下早年的 JavaScript 中的原型和类。</p><h2>早期版本中的类与原型</h2><p>在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。</p><p>以下代码展示了所有具有内置 class 属性的对象：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> arg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span> &#125;();</span><br><span class="line"><span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log([o, n, s, b, d, arg, r, f, arr, e].map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(v)));</span><br></pre></td></tr></table></figure><br><br><p>因此，在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。</p><p>在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123; [<span class="hljs-built_in">Symbol</span>.toStringTag]: <span class="hljs-string">"MyObject"</span> &#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(o + <span class="hljs-string">""</span>);</span><br></pre></td></tr></table></figure><br><br><p>这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响。</p><p>但是，考虑到 JavaScript 语法中跟 Java 相似的部分，我们对类的讨论不能用“new 运算是针对构造器对象，而不是类”来试图回避。</p><p>所以，我们仍然要把 new 理解成 JavaScript 面向对象的一部分，下面我就来讲一下 new 操作具体做了哪些事情。</p><p>new 运算接受一个构造器和一组调用参数，实际上做了几件事：</p><ul><br><li>以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；</li><br><li>将 this 和调用参数传给构造器，执行；</li><br><li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li><br></ul><p>new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。</p><p>下面代码展示了用构造器模拟类的两种方法:</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c1</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.p1 = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">this</span>.p2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.p1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> c1;</span><br><span class="line">o1.p2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c2</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">c2.prototype.p1 = <span class="hljs-number">1</span>;</span><br><span class="line">c2.prototype.p2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> c2;</span><br><span class="line">o2.p2();</span><br></pre></td></tr></table></figure><br><br><p>第一种方法是直接在构造器中修改 this，给 this 添加属性。</p><p>第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。</p><p>没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法（当时的 mozilla 提供了私有属性 <strong>proto</strong>，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 pollyfill，见以下代码：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prototype</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> cls = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;</span><br><span class="line">    cls.prototype = prototype;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>这段代码创建了一个空函数作为类，并把传入的原型挂在了它的 prototype，最后创建了一个它的实例，根据 new 的行为，这将产生一个以传入的第一个参数为原型的对象。</p><p>这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型，所以放到今天意义已经不大了。</p><h2>ES6 中的类</h2><p>好在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。下面我们就来看一下 ES6 中的类。</p><p>ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。</p><p>我们先看下类的基本写法：</p><br><br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.height = height;</span><br><span class="line">    <span class="hljs-keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// Getter</span></span><br><span class="line">  <span class="hljs-keyword">get</span> area() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calcArea();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">// Method</span></span><br><span class="line">  calcArea() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.height * <span class="hljs-keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><p>在现有的类语法中，getter/setter 和 method 是兼容性最好的。</p><p>我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。</p><p>类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。</p><p>此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123; </span><br><span class="line">  <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">' makes a noise.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(name); <span class="hljs-comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">' barks.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">'Mitzie'</span>);</span><br><span class="line">d.speak(); <span class="hljs-comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure><br><br><p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。</p><p>比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。</p><p>所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p><p>一些激进的观点认为，class 关键字和箭头运算符可以完全替代旧的 function 关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。</p><h2>总结</h2><p>在新的 ES 版本中，我们不再需要模拟类了：我们有了光明正大的新语法。而原型体系同时作为一种编程范式和运行时机制存在。</p><p>我们可以自由选择原型或者类作为代码的抽象风格，但是无论我们选择哪种，理解运行时的原型系统都是很有必要的一件事。</p><p>在你的工作中，是使用 class 还是仍然在用 function 来定义“类”？为什么这么做？如何把使用 function 定义类的代码改造到 class 的新语法？</p><p>欢迎给我留言，我们一起讨论。</p><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。&lt;/p&gt;&lt;br&gt;  &lt;p&gt;在上一篇文章我们已经讲到，JavaScript&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象：面向对象还是基于对象？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E5%AF%B9%E8%B1%A1%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript对象：面向对象还是基于对象？/</id>
    <published>2019-03-25T12:57:08.716Z</published>
    <updated>2019-10-02T03:33:33.473Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。<a id="more"></a><br>  一些新人在学习 JavaScript 面向对象时，往往也会有疑惑：<br>  <ul><br>    <li>为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢；</li><br>    <li>为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢？</li><br>  </ul><br><br>  甚至，在一些争论中，有人强调：JavaScript 并非“面向对象的语言”，而是“基于对象的语言”。这个说法一度流传甚广，而事实上，我至今遇到的持有这一说法的人中，无一能够回答“如何定义面向对象和基于对象”这个问题。<br><br>  实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。<br><br>  我们可以先看看 JavaScript 标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”。<br><br>  这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。<br><br>  那么，在本篇文章中，我会尝试让你去理解面向对象和 JavaScript 中的面向对象究竟是什么。<br><br>  <h2>什么是面向对象？</h2><br>  我们先来说说什么是对象，因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。<br><br>  中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。<br><br>  但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。<br><br>  那么，我们先来看看在人类思维模式下，对象究竟是什么。<br><br>  <blockquote><br>    <span class="reference">对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。</span><br>    <span class="reference">在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。</span><br>  </blockquote><br><br>  在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一：<br>  <ol><br>    <li>一个可以触摸或者可以看见的东西；</li><br>    <li>人的智力可以理解的东西；</li><br>    <li>可以指导思考或行动（进行想象或施加动作）的东西。</li><br>  </ol><br>  有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。<br><br>  而 JavaScript 早年却选择了一个更为冷门的方式：原型（关于原型，我在下一篇文章会重点介绍，这里你留个印象就可以了）。这是我在前面说它不合群的原因之一。<br><br>  然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this等语言特性，使之“看起来更像 Java”。<br><br>  在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把 JavaScript 变得更像是基于类的编程，进而产生了很多所谓的“框架”，比如 PrototypeJS、Dojo。<br><br>  事实上，它们成为了某种 JavaScript 的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。<br>  如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。<br><br>  不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。<br><br>  首先我们来了解一下 JavaScript 是如何设计对象模型的。<br><br>  <h2>JavaScript 对象的特征</h2><br>  在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。<br>  <ul><br>    <li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><br>    <li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li><br>    <li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li><br>  </ul><br>  我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。<br><br>  所以，JavaScript 程序员都知道，任何不同的 JavaScript 对象其实是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一模一样的对象，但是打印出来的结果却是 false。<br><br><figure class="highlight delphi hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o1 = <span class="hljs-comment">&#123; a: 1 &#125;</span>;</span><br><span class="line"><span class="hljs-keyword">var</span> o2 = <span class="hljs-comment">&#123; a: 1 &#125;</span>;</span><br><span class="line">console.log(o1 == o2); <span class="hljs-comment">// false</span></span><br></pre></td></tr></table></figure><br><br>关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“成员变量”和“成员函数”，Java 中则称它们为“属性”和“方法”。在 JavaScript 中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。<br><br><figure class="highlight roboconf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123; </span><br><span class="line">    <span class="hljs-attribute">d</span>: 1,</span><br><span class="line">    f() &#123;</span><br><span class="line">        console<span class="hljs-variable">.log</span>(this<span class="hljs-variable">.d</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性。如果你用过 Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。<strong>在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong>我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。<br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;</span><br><span class="line">o.b = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(o.a, o.b); <span class="hljs-comment">//1 2</span></span><br></pre></td></tr></table></figure><br><br>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。<h2>JavaScript 对象的两类属性</h2>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。<br><ul><br>  <li>value：就是属性的值。</li><br>  <li>writable：决定属性能否被赋值。</li><br>  <li>enumerable：决定 for in 能否枚举该属性。</li><br>  <li>configurable：决定该属性能否被删除或者改变特征值。</li><br></ul>在大多数情况下，我们只关心数据属性的值即可。<br>第二类属性是访问器（getter/setter）属性，它也有四个特征。<ul><br>  <li>getter：函数或 undefined，在取属性值时被调用。</li><br>  <li>setter：函数或 undefined，在设置属性值时被调用。</li><br>  <li>enumerable：决定 for in 能否枚举该属性。</li><br>  <li>configurable：决定该属性能否被删除或者改变特征值。</li><br></ul><br>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：<br><br><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">var</span> <span class="hljs-string">o</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;;</span></span><br><span class="line"><span class="hljs-string">o.b</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">;</span></span><br><span class="line"><span class="hljs-string">//a</span> <span class="hljs-string">和</span> <span class="hljs-string">b</span> <span class="hljs-string">皆为数据属性</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"a")</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"b")</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br></pre></td></tr></table></figure><br><br>我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：<br><br><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">var</span> <span class="hljs-string">o</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">a:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;;</span></span><br><span class="line"><span class="hljs-string">Object.defineProperty(o,</span> <span class="hljs-string">"b"</span><span class="hljs-string">,</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;);</span></span><br><span class="line"><span class="hljs-string">//a</span> <span class="hljs-string">和</span> <span class="hljs-string">b</span> <span class="hljs-string">都是数据属性，但特征值变化了</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"a");</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">Object.getOwnPropertyDescriptor(o,"b");</span> <span class="hljs-string">//</span> <span class="hljs-string">&#123;value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">writable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span> <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">o.b</span> <span class="hljs-string">=</span> <span class="hljs-number">3</span><span class="hljs-string">;</span></span><br><span class="line"><span class="hljs-string">console.log(o.b);</span> <span class="hljs-string">//</span> <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><br><br>这里我们使用了 Object.defineProperty 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示：<br><br><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">console.log(o.a); <span class="hljs-comment">// 1</span></span><br></pre></td></tr></table></figure><br><br>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。<br><br>这样，我们就理解了，实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。<br><br>对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下“a”是 key。<br><br><code class="ps">{writable:true,value:1,configurable:true,enumerable:true}<div class="ps__rail-x" style="left: 0px; bottom: 0px;"><br>      <div class="ps__thumb-x" tabindex="0" style="left: 0px; width: 0px;"></div><br>    </div><br>    <div class="ps__rail-y" style="top: 0px; right: 0px;"><br>      <div class="ps__thumb-y" tabindex="0" style="top: 0px; height: 0px;"></div><br>    </div><br></code>是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。<br><br>讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。<br><br>你甚至可以理解为什么会有“JavaScript 不是面向对象”这样的说法了。这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。<br><br>可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍 JavaScript中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。<br><br>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。<br><br>所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。<br><br><h2>结语</h2><br>要想理解 JavaScript 对象，必须清空我们脑子里“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解 JavaScript 面向对象设计的思路。<br><br>在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了 JavaScript 对象的设计思路。接下来又从运行时的角度，介绍了 JavaScript 对象的具体设计：具有高度动态性的属性集合。<br><br>很多人在思考 JavaScript 对象时，会带着已有的“对象”观来看问题，最后的结果当然就是“剪不断理还乱”了。<br><br>在后面的文章中，我会继续带你探索 JavaScript 对象的一些机制，看 JavaScript 如何基于这样的动态对象模型设计自己的原型系统，以及你熟悉的函数、类等基础设施。<br><br>转自—《重学前端》<br></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript类型：关于类型，有哪些你不知道的细节？</title>
    <link href="https://jdsheng.cn/2019/03/25/JavaScript%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%BB%86%E8%8A%82%EF%BC%9F/"/>
    <id>https://jdsheng.cn/2019/03/25/JavaScript类型：关于类型，有哪些你不知道的细节？/</id>
    <published>2019-03-25T12:48:32.377Z</published>
    <updated>2019-10-02T03:33:49.706Z</updated>
    
    <content type="html"><![CDATA[<div class="_1kh1ihh6_0"><br>  <p>这次我们来讲讲 JavaScript 的内容，在这个部分，我首先想跟你聊一聊类型。</p><a id="more"></a><br>  <p>JavaScript 类型对每个前端程序员来说，几乎都是最为熟悉的概念了。但是你真的很了解它们吗？我们不妨来看看下面的几个问题。</p><br><br>  <ul><br>    <li>为什么有的编程规范要求用 void 0 代替 undefined？</li><br>    <li>字符串有最大长度吗？</li><br>    <li>0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？</li><br>    <li>ES6 新加入的 Symbol 是个什么东西？</li><br>    <li>为什么给对象添加的方法能用在基本类型上？</li><br>  </ul><br><br>  <p>如果你答起来还有些犹豫的地方，这就说明你对这部分知识点，还是有些遗漏之处的。没关系，今天我来帮你一一补上。</p><br>  <p>我在前面提到过，我们的 JavaScript 模块会从运行时、文法和执行过程三个角度去剖析 JS 的知识体系，本篇我们就从运行时的角度去看 JavaScript 的类型系统。</p><br>  <blockquote><br>    <p><span class="reference">运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript<br>        代码运行过程中产生的数据，都具有运行时类型</span>。</p><br>  </blockquote><br>  <h2>类型</h2><br>  <p>JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是：</p><br>  <ol><br>    <li>Undefined；</li><br>    <li>Null；</li><br>    <li>Boolean；</li><br>    <li>String；</li><br>    <li>Number；</li><br>    <li>Symbol；</li><br>    <li>Object。</li><br>  </ol><br>  <p>除了 ES6 中新加入的 Symbol 类型，剩下 6 种类型都是我们日常开发中的老朋友了，但是，要想回答文章一开始的问题，我们需要重新认识一下这些老朋友，下面我们就来从简单到复杂，重新学习一下这些类型。</p><br>  <h2>Undefined、Null</h2><br>  <p>我们的第一个问题，为什么有的编程规范要求用 void 0 代替 undefined？现在我们就分别来看一下。</p><br>  <p>Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined<br>    的这个变量）来表达这个值，或者 void 运算来把任一一个表达式变成 undefined 值。</p><br>  <p>但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取<br>    undefined 值。</p><br>  <p>Undefined 跟 null 有一定的表意差别，null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined<br>    的变量，都是从未赋值的自然状态。</p><br>  <p>Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</p><br>  <h2>Boolean</h2><br>  <p>Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。这个类型很简单，我就不做过多介绍了。</p><br>  <h2>String</h2><br>  <p>我们来看看字符串是否有最大长度。</p><br>  <p>String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。</p><br>  <p>因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16<br>    编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。</p><br>  <blockquote><br>    <p><span class="reference">Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是<br>        Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 -<br>        U+FFFF）的码点被称为基本字符区域（BMP）。</span></p><br>  </blockquote><br>  <p>JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。</p><br>  <p>JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。</p><br>  <p>JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。</p><br>  <h2>Number</h2><br>  <p>下面，我们来说说 Number 类型。Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。</p><br>  <p>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。</p><br>  <p>JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0<br>    出错，而引入了无穷大的概念），规定了几个例外情况：</p><br>  <ul><br>    <li>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；</li><br>    <li>Infinity，无穷大；</li><br>    <li>-Infinity，负无穷大。</li><br>  </ul><br>  <p>另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测<br>    1/x 是 Infinity 还是 -Infinity。</p><br>  <p>根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。</p><br>  <p>同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：</p><br><br><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>);</span><br></pre></td></tr></table></figure><br><br><p>这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。</p><p>所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：</p><br><br><figure class="highlight fortran hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="hljs-built_in">log</span>( Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> - <span class="hljs-number">0.3</span>) &lt;= <span class="hljs-keyword">Number</span>.<span class="hljs-built_in">EPSILON</span>);</span><br></pre></td></tr></table></figure><br><br><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。</p><h2>Symbol</h2><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。</p><p>在后面的文章中，我会详细叙述 Symbol 跟对象系统。这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。</p><p>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。</p><p>我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> mySymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"my symbol"</span>);</span><br></pre></td></tr></table></figure><br><br><p>一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span></span><br><span class="line"></span><br><span class="line">o[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> v = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        next: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: v++, <span class="hljs-attr">done</span>: v &gt; <span class="hljs-number">10</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v <span class="hljs-keyword">of</span> o) </span><br><span class="line">    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">// 0 1 2 3 ... 9</span></span><br></pre></td></tr></table></figure><br><br><p>代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。</p><p>这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。</p><p>这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。</p><h2>Object</h2><p>Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。</p><p>下面我们来看一看，为什么给对象添加的方法能用在基本类型上？</p><p>在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><p>关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。</p><p>提到对象，我们必须要提到一个概念：类。</p><p>因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。</p><p>事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。</p><p>JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p><ul><br><li>Number；</li><br><li>String；</li><br><li>Boolean；</li><br><li>Symbol。</li><br></ul><p>所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。</p><p>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。</p><p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p><p>JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"abc"</span>.charAt(<span class="hljs-number">0</span>)); <span class="hljs-comment">//a</span></span><br></pre></td></tr></table></figure><br><br><p>甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Symbol</span>.prototype.hello = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">//symbol，a 并非对象</span></span><br><span class="line">a.hello(); <span class="hljs-comment">//hello，有效</span></span><br></pre></td></tr></table></figure><br><br><p>所以我们文章开头的问题，答案就是 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</p><h2>类型转换</h2><p>讲完了基本类型，我们来介绍一个现象：类型转换。</p><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。</p><p>其中最为臭名昭著的是 JS 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。</p><p>这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。</p><p>其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：</p><p><img src="https://static001.geekbang.org/resource/image/71/20/71bafbd2404dc3ffa5ccf5d0ba077720.jpg" alt=""></p><p>在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。</p><h3>StringToNumber</h3><p>字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：</p><ul><br><li>30；</li><br><li>0b111；</li><br><li>0o13；</li><br><li>0xFF。</li><br></ul><p>此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：</p><ul><br><li>1e3；</li><br><li>-1e-2。</li><br></ul><p>需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。</p><p>在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。</p><p>在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。</p><p>多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。</p><h3>NumberToString</h3><p>在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。</p><p>具体的算法，你可以去参考 JavaScript 的语言标准。由于这个部分内容，我觉得在日常开发中很少用到，所以这里我就不去详细地讲解了。</p><h3>装箱转换</h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。</p><p>前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。</p><p>我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。</p><p>我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> symbolObject = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; &#125;).call(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> symbolObject); <span class="hljs-comment">//object</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject.constructor == <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure><br><br><p>装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。</p><p>使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> symbolObject = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> symbolObject); <span class="hljs-comment">//object</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(symbolObject.constructor == <span class="hljs-built_in">Symbol</span>); <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure><br><br><p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> symbolObject = <span class="hljs-built_in">Object</span>(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">"a"</span>));</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(symbolObject)); <span class="hljs-comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure><br><br><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p><p>但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p><h3>拆箱转换</h3><p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。</p><p>对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><p>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"valueOf"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toString"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o * <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-comment">// valueOf</span></span><br><span class="line"><span class="hljs-comment">// toString</span></span><br><span class="line"><span class="hljs-comment">// TypeError</span></span><br></pre></td></tr></table></figure><br><br><p>我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o<em>2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。</em></p><p>到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o2 换成 String(o)，那么你会看到调用顺序就变了。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">     valueOf : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"valueOf"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">     toString : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toString"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">String</span>(o)</span><br><span class="line"> <span class="hljs-comment">// toString</span></span><br><span class="line"> <span class="hljs-comment">// valueOf</span></span><br><span class="line"> <span class="hljs-comment">// TypeError</span></span><br></pre></td></tr></table></figure><br><br><p>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。</p><br><br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"valueOf"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toString"</span>); <span class="hljs-keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[<span class="hljs-built_in">Symbol</span>.toPrimitive] = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"toPrimitive"</span>); <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(o + <span class="hljs-string">""</span>)</span><br><span class="line"><span class="hljs-comment">// toPrimitive</span></span><br><span class="line"><span class="hljs-comment">// hello</span></span><br></pre></td></tr></table></figure><br><br><h2>结语</h2><p>在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。这里回顾一下今天讲解的知识点。</p><p>除了这七种语言类型，还有一些语言的实现者更关心的规范类型。</p><ul><br><li>List 和 Record： 用于描述函数传参过程。</li><br><li>Set：主要用于解释字符集等。</li><br><li>Completion Record：用于描述异常、跳出等语句执行过程。</li><br><li>Reference：用于描述对象属性访问、delete 等。</li><br><li>Property Descriptor：用于描述对象的属性。</li><br><li>Lexical Environment 和 Environment Record：用于描述变量和作用域。</li><br><li>Data Block：用于描述二进制数据。</li><br></ul><p>有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。</p><p>最后我们留一个实践问题，如果我们不用原生的 Number 和 parseInt，用 JS 代码实现 String 到 Number 的转换，该怎么做呢？请你把自己的代码留言给我吧！</p><hr><h2>补充阅读</h2><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。</p><p><img src="https://static001.geekbang.org/resource/image/ec/6b/ec4299a73fb84c732efcd360fed6e16b.png" alt=""></p><p>在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。</p><p>从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JS 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。</p><p>转自—《重学前端》</p></div>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;_1kh1ihh6_0&quot;&gt;&lt;br&gt;  &lt;p&gt;这次我们来讲讲 JavaScript 的内容，在这个部分，我首先想跟你聊一聊类型。&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jdsheng.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://jdsheng.cn/tags/js/"/>
    
      <category term="前端" scheme="https://jdsheng.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
