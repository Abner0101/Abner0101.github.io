<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈PHP面向对象编程]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B5%85%E8%B0%88php%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本篇文章给大家分享的内容是关于浅谈PHP面向对象编程 ，有着一定的参考价值，有需要的朋友可以参考一下。 一、PHP面向对象编程基础实践123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** 通过对象的编程方式，可将实现生活中的一切事物以对象的形式表现出来。便于理解、维护、扩展等；* 本示例：定义一个“人”类* $name : 对象中的成员属性，在此类中表示人的姓名* say() : 对象中的成员方法，在此类中表示人说话的方法* $this : PHP中的伪变量，表示自身的类* __construct() : php中的魔术方法，构造函数，在实例化类时自动执行* __destruct() : php中的魔术方法，析构函数，当类调用完成后自动执行*/class Human&#123; public $name; public $sex; public $age; public function __construct($name,$sex,$age) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; public function say() &#123; echo '大家好，我的名字叫'.$this-&gt;name.'，今年'.$this-&gt;age.'岁，我的性别是'.$this-&gt;sex; &#125; public function __destruct() &#123; $this-&gt;name = null; $this-&gt;sex = null; $this-&gt;age = null; &#125;&#125;//实例化“人”类$male = new Human("张三","男","20");//调用“人”类说话的方法$male-&gt;say(); //输出结果：大家好，我的名字叫张三，今年20岁，我的性别是男?&gt; 二、PHP面向对象高级编程实践知识点：类的继承、方法重写、访问控制、static关键字、final关键字、数据访问、接口、多态、抽象类 2.1、类的继承：extends 关键字例如：一员运行员、一位主持人，他们有人类共同的行为方法，但他们都有自己不同的特长专业。因此在编程时需要给他们创建一个父类并继承； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** 创建一个“人”类做为父类，继承的子类都拥有其父类的成员属性、方法*/class Human&#123; public $name; public function say() &#123; echo "父类说话的方法，姓名：".$this-&gt;name."\n"; &#125; public function eat() &#123; echo "父类吃饭的方法\n"; &#125;&#125;/** 创建一个“运动员”类，继承“人”类* extends : 关键字，继承某个类*/class Sport extends Human&#123; public $type; public function __construct($name,$type) &#123; $this-&gt;name = $name; //给父类 $name 属性赋值 $this-&gt;type = $type; &#125; public function run() &#123; $this-&gt;say(); //调用父类“说话”的方法 echo "我在正跑步，我是一员".$this-&gt;type."运动员.....\n"; &#125;&#125;/** 创建一个“主持人”类，继承“人”类* extends : 关键字，继承某个类*/class Host extends Human&#123; public $television; public function __construct($name,$television) &#123; $this-&gt;name = $name; $this-&gt;television= $television; &#125; public function perform() &#123; $this-&gt;eat(); //调用父类“吃饭”的方法 echo "我在正表演一个节目，我是".$this-&gt;television."电视台的一名主持人.....\n"; &#125;&#125; //实例化“运动员”类$nba = new Sport("乔丹","篮球");$nba-&gt;run(); //实例化“主持人”类$tv = new Host("张三","北京卫视");$tv-&gt;perform(); //输出结果：//父类说话的方法，姓名：乔丹 我在正跑步，我是一员篮球运动员..... //父类吃饭的方法 我在正表演一个节目，我是北京卫视电视台的一名主持人.....?&gt; 2.2、方法重写：子类重写父类的方法 1234567891011121314151617181920&lt;?phpclass Human&#123; public function say() &#123; echo "父类说话的方法"; &#125;&#125;class Sport extends Human&#123; //重写父类“说话”的方法 public function say() &#123; echo "子类说话的方法"; &#125;&#125;$nba = new Sport();$nba-&gt;say();//输出结果：子类说话的方法?&gt; 2.3、访问控制：public 、 protected 、private 关键字 public：定义公共的成员属性或方法，任何地方都可使用protected : 定义受保护的成员属性或方法，只允许类本身或子类使用private : 定义私有的成员属性或方法，只允许类的本身使用 123456789101112&lt;?phpclass Human&#123; public $name; protected $sex; private $age; &#125;//实例化对象，给公共属性赋值可正常输出结果，外部不能给protected、private受保护的成员属性赋值或使用$worker = new Human();$worker-&gt;name = "张三";echo $worker-&gt;name;?&gt; 2.4、static（静态）关键字1）、静态属性用于保存类的公有数据；2）、静态方法里面只能访问静态属性或方法，不能使用 $this 伪变量；3）、静态成员不需要通过 new 关键字来实例化对象就可访问使用； 123456789101112131415&lt;?phpclass Human&#123; static $name = "张三"; static function say() &#123; echo "我的姓名叫：".self::$name; &#125;&#125;//外部使用静态成员属性或方法echo Human::$name;Human::say(); //输出结果：张三 我的姓名叫：张三?&gt; 2.5、final关键字：不允许成员方法被重写，不允许被继承例：1、对于父类“吃饭”这个方法，不希望子类重写它；2、对于“运动员”这个类，不希望它再创建子类； 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Human&#123; final public function eat() &#123; echo "父类吃饭的方法，不允许子类重写"; &#125;&#125;final class Sport extends Human&#123; public function eat() &#123; echo "子类吃饭的方法。此时程序将会报致命错误"; &#125;&#125;//创建一个类继承 Sport 这个类。此时程序也将会报致命错误。因为 Sport 类不允许再创建子类class Student extends Sport&#123; public $name;&#125; //实例化 Sport 类 ，调用 eat() 方法$nba = new Sport();$nba-&gt;eat(); //实例化 Student 类 ，给 name 属性负值$obj = new Student();$obj-&gt;name = "张三"; //输出结果：Fatal error: Cannot override final method Human::eat() in ******.php on line 15//Fatal error: Class Student may not inherit from final class (Sport) in ****.php on line 20?&gt; 2.6、数据访问：$this 、 self 、parent 关键字$this ： 伪变量，代表类的本身，可访问本类及父类中的成员属性与方法。self ： 访问类中的静态成员属性或方法parent ：访问父类的成员属性或方法 1234567891011121314151617181920&lt;?phpclass Human&#123; static $name = "张三";&#125;class Sport extends Human&#123; static function getParentName() &#123; echo parent::$name; &#125; public function get() &#123; self::getParentName(); &#125;&#125;$obj = new Sport();$obj-&gt;get();//输出结果：张三?&gt; 2.7、接口：把不同类的共同行为方法进行定义，但不具体实现，由子类来实现具体的方法；例如：人会吃饭，动物也会吃饭，甚至有些植物也会吃饭，但他们吃饭的方式不一样，因此这时需要定义一个接口类，具体的方式由子类来实现；定义接口关键字：interface实现接口方法关键字：implements 123456789101112131415161718192021222324252627282930313233&lt;?php//定义一个接口类，有吃饭的方法，但不具体实现。interface ICanEat&#123; public function eat($food);&#125;class Human implements ICanEat&#123; //eat()方法必须由子类来实现，否则程序将报致命错误 public function eat($food) &#123; echo "I'm eating ".$food; &#125;&#125;class Animal implements ICanEat&#123; public function eat($food) &#123; echo "It's eating ".$food; &#125;&#125;//实例化一个“人”类$people = new Human();$people-&gt;eat('rice'); //实例化一个“动物”类$monkey = new Animal();$monkey-&gt;eat('banana'); //输出结果：I'm eating rice// It's eating banana ?&gt; 2.8、多态：比如接口A有两个实现B和C，B和C对A接口里面定义的方法实现可以是不同的，这种现象称之为多态；上述实例中，ICanEat接口定义了一个eat()方法，人类吃米饭，猴子吃香蕉。他们都实现了一个“吃”的方法，但他们吃东西有不同的行为，称之为多态； 2.9、抽象类：介入接口与类的定义之间，允许类里面一部分方法不实现，实现一部分有相同功能且不会更改的方法。然而接口类里面不允许有任何实现的方法。例如：人和动物都具有吃饭与呼吸的方法，除吃饭不同以外，呼吸方法是相同的，此时需要定义一个抽象类来实现。定义抽象类关键字：abstract 1234567891011121314151617181920212223&lt;?php//定义一个抽象类，里面有吃饭和呼吸的方法。呼吸方法需要在抽象类中具体实现abstract class ICanEat&#123; abstract function eat($food); public function breath() &#123; echo 'Breath use the air...'; &#125;&#125;class Human extends ICanEat&#123; public function eat($food) &#123; echo "I'm eating ".$food; $this-&gt;breath(); &#125;&#125;//实例化“人”类$people = new Human();$people-&gt;eat('rice');//输出结果:I'm eating rice Breath use the air...?&gt; 三、PHP面向对象编程特殊实践PHP语言特定的一些魔术方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Object&#123; public function __construct() &#123; echo "当类在被实例化的时候，自动执行该函数"; &#125; public function __toString() &#123; return "当对象被当作字符串形式输出时，自动执行该函数"; &#125; public function __invoke($value) &#123; echo "当对象被当作函数调用时，自动执行该函数".$value; &#125; /* * 当对象访问不存在的方法时，自动执行该函数。也称之为“方法重载” * $fun : 方法名称 * $param : 传递的参数 */ public function __call($fun,$param) &#123; echo "调用".$fun."方法不存在，传递的参数".implode(',',$param); &#125; /* * 当对象访问不存在的静态方法时，自动执行该函数。 * $fun : 方法名称 * $param : 传递的参数 */ static function __callStatic($fun,$param) &#123; echo "调用".$fun."静态方法不存在，传递的参数".implode(',',$param); &#125; public function __get($key) &#123; echo "当读取对象中不可访问（未定义）的属性值时，自动调用该函数。".$key."属性不可访问或未定义"; &#125; public function __set($key,$value) &#123; echo "当给对象中不可访问（未定义）的属性赋值时，自动调用该函数。".$key."属性不可访问或未定义，值".$value; &#125; public function __isset($key) &#123; echo "判断对象中的属性不存在时，自动执行该函数。属性：".$key."值未定义"; &#125; public function __unset($key) &#123; echo "释放对象中的不存在的属性值时，自动执行该函数。属性：".$key."值未定义"; &#125; public function __clone() &#123; echo "当对象被克隆时，自动执行该函数。"; &#125; public function __destruct() &#123; echo "当对象执行完成后，自动执行该函数"; &#125;&#125;$obj = new Object(); //实例化对象时，调用__construct()方法echo $obj; //将对象以字符串形式输出时，调用__toString()方法$obj(123); //当对象以函数形式调用时，执行__invoke()方法$obj-&gt;runTest(); //当调用对象中不存在的方法时，执行__call()方法$obj::runTest(); //当调用对象中不存在的静态方法时，执行__callStatic()方法$obj-&gt;name; //当调用对象中不存在的成员属性时，执行__get()方法$obj-&gt;name = "张三"; //当给对象中不存在的成员属性赋值时，执行__set()方法isset($obj-&gt;name) ? 1 : 0; //判断对象中不存在的成员属性时，执行__isset()方法unset($obj-&gt;name); //释放对象中的不存在的属性值时，执行__unset()方法$obj2 = clone $obj; //当对象被克隆时，执行__clone()方法 //对象执行完毕，执行__destruct()方法?&gt;]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用jQuery实现简单的图片轮播效果]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%95%88%E6%9E%9C%20%2F</url>
    <content type="text"><![CDATA[以下代码使用了jQuery来实现简单的图片轮播效果： html部分：12345678910111213141516171819202122&lt;div id="slider"&gt; &lt;ul class="slider_list"&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="4.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="5.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="6.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="7.jpeg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="8.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="slider_icon"&gt; &lt;i class="btn btn_act"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;/div&gt; &lt;a href="javascript:;" class="arrow left"&gt; &lt;span class="slider_left"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href="javascript:;" class="arrow right"&gt; &lt;span class="slider_right"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; css部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#slider&#123; width: 750px; height: 450px; margin: 10% auto; position: relative; border: 0px red solid &#125;#slider img&#123; width: 750px; height: 450px; &#125;li&#123; list-style: none; &#125;.slider_list li&#123; position: absolute; display: none; &#125;.slider_list li:first-child&#123; display: block; &#125;.arrow&#123; display: none; width:40px; height: 60px; background: rgba(0,0,0,.2); position: absolute; top: 50%; margin-top: -40px; &#125;.left&#123; left: 0px; &#125;.right&#123; right: 0px; &#125;.arrow span&#123; display: none; width: 15px; height: 15px; border-bottom: 2px solid #fff; border-left: 2px solid #fff; &#125;.slider_left&#123; margin-top:25px; margin-left: 15px; transform: rotate(45deg); &#125;.slider_right&#123; margin-top:25px; margin-left: 5px; transform: rotate(-135deg); &#125;.arrow:hover&#123;background: #444&#125;#slider:hover .arrow&#123;display:block;&#125;#slider:hover .arrow span&#123;display:block;&#125;.slider_icon&#123; width: 195px; height: 35px; background-color:hsla(0,0%,100%,.3); position: absolute; bottom: 0px; left: 50%; margin-left: -100px; border-radius: 30px; margin-bottom: 15px; z-index: 2; display: block; &#125;.slider_icon i&#123; display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 11px; margin-left: 11px; margin-top: 13px; &#125;.slider_icon:hover&#123;background-color:rgba(0,0,0,.4);&#125; .btn&#123; background: #fff; &#125;.btn_act&#123; background: #FCD705 &#125; js部分：12345678910111213141516171819202122232425var count=0;var $li=$(".slider_list&gt;li");var timer=setInterval("next()",4000); function next() &#123; count++; if (count==$li.length) &#123; count=0; &#125; $li.eq(count).fadeIn().siblings().fadeOut(); $(".slider_icon&gt;i").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); &#125; $(".right").click(function()&#123;next();&#125;); $(".left").click(function()&#123; count--; if (count == -1) &#123; count=$li.length-1; &#125; $li.eq(count).fadeIn().siblings().fadeOut(); $(".slider_icon&gt;i").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); &#125;) $(".slider_icon&gt;i").mouseenter(function()&#123; $(this).addClass('btn_act').siblings().removeClass('btn_act'); $li.eq($(this).index()).fadeIn().siblings().fadeOut(); count=$(this).index(); &#125;)]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题SEO优化]]></title>
    <url>%2F2018%2F07%2F29%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98SEO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[刚搭建完博客，发现自己发表的文章在谷歌或者百度都搜索不到，今天看了一些文章，原来是需要seo优化的，所以就来总结一下seo优化的方法，让自己的博文能在谷歌百度上搜索到。本文主要以谷歌搜索为主。 添加站点地图–安装sitemap站点地图自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save –修改站点配置文件将sitemap文件添加到站点配置文件_config.yml中，并修改url字段的值，其值默认为https://yoursite.com(你的博客域名）。 123456sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlurl: https://abner0101.github.io 配置好后，执行hexo g 就能在站点public\目录中生成sitemap.xml 和 baidusitemap.xml了;其中第一个是一会要提交给google的，后面那个看名字当然就是提交给Baidu的了； 添加蜘蛛协议在站点source文件夹下新建robots.txt文件，文件内容如下：（参考我的） 123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://abner0101.github.io/sitemap.xmlSitemap: https://abner0101.github.io/baidusitemap.xml 其中Allow后面的就是你的menu请自行将abner0101.github.io改成自己的域名，然后hexo d -g提交一下 提交站点到Google打开Google Search Console，根据提示注册好之后，添加你的博客域名。 站点验证我选择了备用方法中的HTML 标记，将给出的元标记复制到\themes\hexo-theme-next\layout_partials\head.swig文件中。添加后运行hexo d -g将改动提交。稍后就可以验证成功了。 123456&lt;meta charset="UTF-8"/&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/&gt;&lt;meta name="theme-color" content="&#123;&#123; theme.android_chrome_color &#125;&#125;"&gt;&lt;meta name="google-site-verification" content="xxxxxxxxxxxxx" /&gt;&lt;meta name="baidu-site-verification" content="xxxxxxxxx" /&gt; 测试robots.txt点击左侧的robots.txt测试工具，根据提示提交你的robots.txt，其实刚才我们已经提交了。 注意要0错误才可以，如果有错误的话，会有提示，改正确就可以了。 提交站点地图还记得我们刚才创建创建sitemap.xml文件吧,现在它要派上用场了。点击左侧工具栏的站点地图 Google 抓取方式提交站点地图之后，点击左侧的Google 抓取方式 这一步很重要！这一不很重要！这一步很重要！在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。提交完成后，提交至索引，根据提示操作就可以了。 网站结构自身优化出站链接添加nofollow标签网络爬虫会在当前页面搜索所有的链接，然后一个个查看，所以就很有可能跳到别的网站就不回来了。这个时候就需要nofollow起作用了。 nofollow标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 修改footer.swig文件路径在your-hexo-site\themes\next\layout_partials，将下面代码中的a标签加上rel=”external nofollow”属性。 1&#123;&#123; __('footer.powered', '&lt;a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 1&lt;a rel="external nofollow" class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next"&gt; 修改sidebar.swig文件路径在your-hexo-site\themes\next\layout_macro，将下面代码中的a标签加上rel=”external nofollow”属性 1&lt;a href="https://creativecommons.org/&#123;% if theme.creative_commons === 'zero' %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/" rel="external nofollow" class="cc-opacity" target="_blank"&gt; 1&lt;a href="&#123;&#123; link &#125;&#125;" title="&#123;&#123; name &#125;&#125;" rel="external nofollow" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 1&lt;a rel="external nofollow" href="&#123;&#123; link.split('||')[0] | trim &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; 至此，seo优化得差不多了，还有很多可以优化的地方，博主日后再更新。马上上google搜索一下你的关键词和博客title测试一下吧！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记Hexo + Github Pages博客搭建]]></title>
    <url>%2F2018%2F07%2F27%2F%E8%AE%B0Hexo%20%2B%20Github%20pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[很早之前就听说可以通过github pages来搭建博客，但是由于种种原因（就是懒），迟迟没有付诸行动，终于，趁着暑假，开始了我的hexo+github pages 搭建博客的踩坑记，折腾了两天，终于成功搭建好了博客，接下来，开始分享搭建本博客的过程中以及各种坑。。。 用Hexo + Gitpages的原因 不用配置服务器 不用数据库 访问速度相当快 没有安全性可言 使用户可更注重博客内容 支持markdown还有就是hexo相对来说轻巧一些，生成文章的速度也比较快（静态博客生成页面时都是要整站生成，所以，页面越多，速度就越慢） 从hexo开始首先本地得装上了node.js、git和hexo 安装git：git 安装nodejs：node.js官网 hexo：hexo官网 hexo使用npm安装（过程如下） 1234npm install hexo-cli -ghexo init blogcd bloghexo server 然后打开http://localhost:4000/就可以查看效果了。如果4000端口打不开，可以通过以下命令更改端口访问(改为3000） 1hexo s -p 3000 注：Hexo依赖Node.js和Git，需要先安装。hexo的使用可参详官网文档。 常用命令： 1234hexo g 生成静态博客，即重新生成public文件夹hexo s 本地预览调试 (一般组合使用 hexo g &amp;&amp; hexo s)hexo d (发布到github)hexo n (执行该命令之后在source/_posts目录下产生&lt; blog name &gt;.md文件，这是你的一篇新博客。可以在markdown工具下编写，markdown工具在网上搜有一大堆，比如本博主使用的csdn的markdown工具，具体怎么使用也可以自己百度啦~） 部署到Github在github上创建一个仓库，仓库必须命名为：你的github账号.github.io(例如我的账号为Abner0101，所以我的仓库名为：Abner0101.github.io) 配置hexo config.yml，修改Deployment 1234deploy: type: git repo: git@github.com:你的帐号/你的帐号.github.com.git branch: master 然后执行命令： 123hexo cleanhexo ghexo d 此时，在博客的根目录下会生成一个文件夹：.deploy 然后我们把这个文件夹里面的文件都push到刚才新建那个项目就OK了。几分钟过后，就可以打开：你的用户名.github.io 看到你的博客了。 绑定域名在项目的根目录，新建名为CNAME的文件，内容为：你的域名，例如我的就是：jdsheng.cn再到把你的域名指向你的用户名.github.io，几分钟过后，就可以看到成功的诞生了。 NexT主题与第三方服务我使用的主题是next，在你的博客根目录下gitbash，安装next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件(_config.yml)，增加一行： 1theme: next 进入themes/next，修改主题配置文件 _config.yml 定位到scheme参数来选择自己喜欢的主题风格： 1scheme: Mist 关于next主题更多的配置（添加评论，分享，喜欢，添加头像等功能）可以参考NexT使用文档 关于更换电脑，如何继续写博客1.将你原来的电脑上已经配置好的源代码项目拷贝到你新的电脑，注意，无需拷贝全部，只需要拷贝一下几个目录： 12345_config.ymlpackage.jsonscaffolds/source/themes/ 将这些目录放在一个目录下，例如：blog/ 2.在你的新电脑上配置hexo环境：安装git、安装node.js3.安装hexo，执行命令： 1npm install -g hexo 4.安装好之后，在hexo目录下gitbash，执行命令： 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 5.部署，执行命令： 12 hexo ghexo d 在执行第5步时，可能会出错，不知道你们会不会遇到，反正我是遇到了，在部署提交代码的时候出现了这个问题： 123456*** Please tell me who you are.Run git config --global user.email "you@example.com" git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository. 所以解决方法是当出现这个上述提示后 接着补充你在命令行中执行 12git config --global user.email "你的邮箱"git config --global user.name "你的名字" （注意 “ 前面是有空格的）输入后在接着执行git g、git d即可！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习记录]]></title>
    <url>%2F2018%2F07%2F27%2Fnode.js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[–node.js入门]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
