<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段二）]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我在上一篇文章中，简要介绍了浏览器的工作大致可以分为 6 个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面的过程。今天我们主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。解析代码我们在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的 Response 的 body，就要交给我们今天学习的内容去处理了。HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA 节点几种。实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。“&lt;?”和“&lt;%”什么的也是必须要支持好的，报了错也不能吭声。1. 词（token）是如何被拆分的首先我们来看看一个非常标准的标签，会被如何拆分：1&lt;p class="a"&gt;text text text&lt;/p&gt;如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了（它甚至可以嵌套）。那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“&lt;p” ，所以“ &lt;p” 就是我们的第一个词（token）。我们继续拆分，可以把这段代码依次拆成词（token）：&lt;p“标签开始”的开始；class=“a” 属性；&gt; “标签开始”的结束；text text text 文本；&lt;/p&gt; 标签结束。这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子：根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。比如，假设我们接受了一个字符“ &lt; ” 我们一下子就知道这不是一个文本节点啦。之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。2. 状态机绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看：当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML 官方文档，HTML 官方文档规定了 80 个状态（顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。这里我们为了理解原理，用这个简单的状态机就足够说明问题了。状态机的初始状态，我们仅仅区分 “&lt; ”和 “非 &lt;”：如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点；如果获得的是一个 &lt; 字符，那么进入一个标签状态。不过当我们在标签状态时，则会面临着一些可能性。比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。如果下一个字符是字母，那么可以确定进入了一个开始标签。如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。接下来就是代码实现的事情了，在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装状态机。）为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344var data = function(c)&#123; if(c=="&amp;") &#123; return characterReferenceInData; &#125; if(c=="&lt;") &#123; return tagOpen; &#125; else if(c=="\0") &#123; error(); emitToken(c); return data; &#125; else if(c==EOF) &#123; emitToken(EOF); return data; &#125; else &#123; emitToken(c); return data; &#125;&#125;;var tagOpenState = function tagOpenState(c)&#123; if(c=="/") &#123; return endTagOpenState; &#125; if(c.match(/[A-Z]/)) &#123; token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; &#125; if(c.match(/[a-z]/)) &#123; token = new StartTagToken(); token.name = c; return tagNameState; &#125; if(c=="?") &#123; return bogusCommentState; &#125; else &#123; error(); return dataState; &#125;&#125;;//……这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个“ &lt; ” 字符，来判断标签类型的状态。这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。这样，我们的状态迁移代码非常的简单：1234var state = data;var charwhile(char = getInput()) state = state(char);这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理方式。词法分析器接受字符的方式很简单，就像下面这样：12345678910111213141516function HTMLLexicalParser()&#123; // 状态函数们…… function data() &#123; // …… &#125; function tagOpen() &#123; // …… &#125; // …… var state = data; this.receiveInput = function(char) &#123; state = state(char); &#125;&#125;至此，我们就把字符流拆成了词（token）了。构建 DOM 树接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。123456789function HTMLSyntaticalParser()&#123; var stack = [new HTMLDocument]; this.receiveInput = function(token) &#123; //…… &#125; this.getOutput = function()&#123; return stack[0]; &#125;&#125;我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emmitToken 来调用。在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP 的话，我们还需要抽象工厂来创建对象），123456function Element()&#123; this.childNodes = [];&#125;function Text(value)&#123; this.value = value || "";&#125;前面我们的词（token）中，以下两个是需要成对匹配的：tag starttag end根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点同样我们来看看直观的解析过程：12345678&lt;html maaa=a &gt; &lt;head&gt; &lt;title&gt;cool&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="a" /&gt; &lt;/body&gt;&lt;/html&gt;通过这个栈，我们可以构建 DOM 树：栈顶元素就是当前节点；遇到属性，就添加到当前节点；遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；遇到注释节点，作为当前节点的子节点；遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；遇到 tag end 就出栈一个节点（还可以检查是否匹配）。我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。当我们的源代码完全遵循 xhtml（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction结语好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段一）]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它能做什么，而不知道它是如何做到的。在我面试和接触过的前端开发者中，70% 的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师实现浏览器”的水准。那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。这个过程是这样的： 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面； 把请求回来的 HTML 代码经过解析，构建成 DOM 树； 计算 DOM 树上的 CSS 属性； 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图； 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度； 合成之后，再绘制到界面上。我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。首先我们来介绍下网络通讯的部分。HTTP 协议浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议（实际上这个过程之前还有 DNS 查询，不过这里就不详细展开了。）我先来了解下 HTTP 的标准。HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份： HTTP1.1 https://tools.ietf.org/html/rfc26162.HTTP1.1 https://tools.ietf.org/html/rfc7234HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP 一下：实验我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具（安装方法）。首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容： 1telnet time.geekbang.org 80 这个时候，TCP 连接已经建立，我们输入以下字符作为请求： 12GET / HTTP/1.1Host: time.geekbang.org 按下两次回车，我们收到了服务端的回复： 123456789101112131415HTTP/1.1 301 Moved PermanentlyDate: Fri, 25 Jan 2019 13:28:12 GMTContent-Type: text/htmlContent-Length: 182Connection: keep-aliveLocation: https://time.geekbang.org/Strict-Transport-Security: max-age=15768000&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和版本。在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 html 代码。HTTP 协议格式根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分。我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。下面我们就来逐个给你介绍其它部分。HTTP Method（方法）我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型。方法有以下几种定义： GET POST HEAD PUT DELETE CONNECT OPTIONS TRACE浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。CONNECT 现在多用于 HTTPS 和 WebSocket。OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。HTTP Status code（状态码）和 Status text（状态文本）接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。 1xx：临时回应，表示客户端请继续。 2xx：请求成功。 200：请求成功。 3xx: 表示请求的目标有变化，希望客户端进一步处理。 301&amp;302：永久性与临时性跳转。 304：跟客户端缓存没有更新。 4xx：客户端请求错误。 403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议） 5xx：服务端请求错误。 500：服务端错误。 503：服务端暂时性错误，可以一会再试。对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。HTTP Head (HTTP 头)HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，我们现在就来了解一下它们。在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下：我们先来看看 Request Header。接下来看一下 Response Header。这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完整的列表还是请你参考我给出的 rfc2616 标准。HTTP Request BodyHTTP 请求的 body 主要用于提交表单场景。实际上，http 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是： application/json application/x-www-form-urlencoded multipart/form-data text/xml我们使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。HTTPS在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：https://tools.ietf.org/html/rfc2818HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。HTTP 2HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。https://tools.ietf.org/html/rfc7540HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。 Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。结语在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的这一过程。在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head 和 HTTP Request Body 几个重点需要注意的部分。最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。转自–《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP知识点积累]]></title>
    <url>%2F2018%2F09%2F17%2FPHP%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[1、关于$_FILES 处理文件上传2、数组的定义和遍历3、关于命名空间的简单介绍]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP mysql数据库面向对象简单操作类（增删改查）、分页类和图片验证码类的封装]]></title>
    <url>%2F2018%2F09%2F17%2Fphp%20mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%89%E3%80%81%E5%88%86%E9%A1%B5%E7%B1%BB%E5%92%8C%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这篇文章中已经介绍了PHP连接数据库的方法以及最基本的对数据库的操作，但并没有实现模块化，所有的代码全都集中在表现页面中，造成了代码冗余，不仅不利于维护也不利于代码的重用性，那么在这篇文章中将用面向对象的知识对数据库的连接和基本操作方法进行封装，也简单地对地分页功能进行了封装，这样就大大避免了代码的重复。 以下文件放置于space文件夹中 一、封装简单的数据库的增删改查等函数 libs/Db文件夹 1、先写一个db.config.php文件来使用里面是你数据库的信息 123456789&lt;?phpreturn array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'password' =&gt; 'root', 'port' =&gt; '3306', 'dbname' =&gt; 'test', 'charset' =&gt; 'utf8'); 2、通过Idb.class.php文件来定义接口 12345678910&lt;?phpnamespace libs\Db; //引入命名空间interface Idb &#123; public function add(); public function getOne(); public function getList(); public function update(); public function delete(); public function count();&#125; 什么是命名空间 3、通过Mysql.class.php来封装接口的各个功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;?phpnamespace libs\Db;class Mysql implements Idb &#123; private $_link = NULL; private $_debug = false; private $_where = NULL; private $_table = NULL; private $_data = NULL; private $_fields = NULL; private $_limit=NULL; private $_order = NULL; private static $_instance = NULL; private function __construct() &#123; if ( $this-&gt;_link == NULL ) &#123; $this-&gt;connect(); &#125; &#125; public static function init() &#123; if ( self::$_instance == NULL ) &#123; self::$_instance = new self(); &#125; return self::$_instance; &#125; private function excute($sql) //执行sql语句 &#123; if ( $this-&gt;_debug == true ) &#123; echo "EXCUTE SQL: &#123;$sql&#125; &lt;br/&gt;"; &#125; $ret = $this-&gt;_link-&gt;query($sql); return $ret; &#125; public function setDebug( $debug = true ) //调试函数 &#123; $this-&gt;_debug = $debug; &#125; private function connect() //连接数据库 &#123; $conf = require_once 'db.config.php'; $this-&gt;_link = new \mysqli($conf['host'], $conf['user'], $conf['password'], $conf['dbname'],$conf['port']); if ($this-&gt;_link-&gt;connect_error) &#123; die('Connect Error (' . $this-&gt;_link-&gt;connect_errno . ') ' . $this-&gt;_link-&gt;connect_error); &#125; date_default_timezone_set('PRC'); //设时区 $this-&gt;_link-&gt;query("SET NAME &#123;$conf['charset']&#125;"); &#125; public function table( $table ) //获取表 &#123; $this-&gt;_table = $table; return $this; &#125; public function where($where= NULL) &#123; $this-&gt;_where = $where; return $this; &#125; public function data($data) &#123; $this-&gt;_data = $data; return $this; &#125; public function field($fields)&#123; $this-&gt;_fields = $fields; return $this; &#125; public function order($order)&#123; $this-&gt;_order = $order; return $this; &#125; public function limit($limit)&#123; $this-&gt;_limit = $limit; return $this; &#125; public function add() //添加数据 &#123; $sql = "INSERT INTO &#123;$this-&gt;_table&#125; ("; $fields = ""; $values = ""; foreach( $this-&gt;_data as $key =&gt; $val ) &#123; if ( $fields == "" ) $fields = $key; else $fields .= ",".$key; if ( $values == "" ) $values = "'&#123;$val&#125;'"; else $values .= ","."'&#123;$val&#125;'"; &#125; $sql .= "&#123;$fields&#125; )VALUES(&#123;$values&#125;)"; $ret = $this-&gt;excute($sql); return $ret; &#125; public function getOne() //获取一组数据 &#123; //select id,name from table where id = 10 if ( is_array($this-&gt;_fields) ) $fields = implode(',', $fields); $sql = "SELECT &#123;$this-&gt;_fields&#125; FROM &#123;$this-&gt;_table&#125;"; if ( $this-&gt;_where != NULL ) $sql .= " WHERE &#123;$this-&gt;_where&#125;"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row; &#125; public function getList() //获取多组数据 &#123; //select id,name from table where id &gt; 10 //若查询字段为一维数组，以,拼接为目标字符串 if ( is_array($this-&gt;_fields) ) $this-&gt;_fields = implode(',', $this-&gt;_fields); $sql = "SELECT &#123;$this-&gt;_fields&#125; FROM &#123;$this-&gt;_table&#125;"; if ( $this-&gt;_where != NULL ) $sql .= " WHERE &#123;$this-&gt;_where&#125;"; if ($this-&gt;_order !=NULL) $sql .= " ORDER BY &#123;$this-&gt;_order&#125;"; if ( $this-&gt;_limit != NULL ) $sql .= " LIMIT &#123;$this-&gt;_limit&#125;"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $result = []; while ( ($row = $ret-&gt;fetch_assoc()) != false) &#123; $result[] = $row; &#125; return $result; &#125; public function update() //更新数据 &#123; //update table set name = "wein" where id = 1 $sql = "UPDATE &#123;$this-&gt;_table&#125; SET "; $fields = ""; foreach( $this-&gt;_data as $key =&gt; $val ) &#123; if ( $fields == "" ) $fields = "&#123;$key&#125;='&#123;$val&#125;'"; else $fields .= ","."&#123;$key&#125;='&#123;$val&#125;'"; &#125; if ( $this-&gt;_where != NULL ) $sql .= "&#123;$fields&#125; WHERE &#123;$this-&gt;_where&#125;"; else $sql .= "&#123;$fields&#125;"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $row = $this-&gt;_link-&gt;affected_rows; if ( $row == 0 ) return false; return true; &#125; public function delete()//删除数据 &#123; //拼接sql语句 //delete from table where id =1 $sql = "DELETE FROM &#123;$this-&gt;_table&#125; WHERE &#123;$this-&gt;_where&#125;"; $ret = $this-&gt;excute($sql); return $ret; &#125; public function count() //统计数据 &#123; $sql = "SELECT COUNT(&#123;$this-&gt;_fields&#125;) AS num FROM &#123;$this-&gt;_table&#125;"; if ( $this-&gt;_where != NULL ) $sql .= " WHERE &#123;$this-&gt;_where&#125;"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row['num']; &#125; public function __destruct() //断开数据库连接 &#123; $this-&gt;_link-&gt;close(); $this-&gt;_link = NULL; &#125; &#125; 二、分页类的封装 libs/Page文件夹 1、通过Page.class.php文件来封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpnamespace libs\Page;class Page &#123; private $_totals = 0; private $_pagesize = 0; public function __construct( $pagesize, $total ) &#123; $this-&gt;_totals = $total; $this-&gt;_pagesize = $pagesize; &#125; public function getoffset() //获取展示下一页开始的id值 &#123; $page = isset($_GET['page'])?$_GET['page']:1; $offset = ($page -1) * $this-&gt;_pagesize; return $offset; &#125; public function show($left = 2) &#123; $page = isset($_GET['page'])?$_GET['page']:1; $totalPages = ceil($this-&gt;_totals / $this-&gt;_pagesize); $html = '&lt;ul class="page-ui-box"&gt;'; if ( $page &gt; 1 )&#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page=1"&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.($page-1).'"&gt;上一页&lt;/a&gt;&lt;/li&gt;'; &#125; else &#123; $html .= '&lt;li class="unable"&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="unable"&gt;&lt;a&gt;上一页&lt;/a&gt;&lt;/li&gt;'; &#125; //当前页的前面显示两个数字页面 $start = ($page - $left); if ( $start &lt;= 0 ) $start = 1; for( $i = $start; $i &lt; $page; $i++ ) &#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.$i.'"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; &#125; $html .= '&lt;li class="unable"&gt;&lt;a&gt;'.$page.'&lt;/a&gt;&lt;/li&gt;'; //当前页的后面显示两个数字页面 $end = $page + 2; if ( $end &gt; $totalPages ) $end = $totalPages; for( $i = $page + 1; $i &lt;= $end; $i++ ) &#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.$i.'"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; &#125; if ( $page &lt; $totalPages ) &#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.($page+1).'"&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.$totalPages.'"&gt;尾页&lt;/a&gt;&lt;/li&gt;'; &#125; else &#123; $html .= '&lt;li class="unable"&gt;&lt;a&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="unable"&gt;&lt;a&gt;尾页&lt;/a&gt;&lt;/li&gt;'; &#125; $html .= '&lt;/ul&gt;'; return $html; &#125;&#125;?&gt; 2、样式文件Page-ui.css 12345678910* &#123;margin: 0px;padding: 0px;&#125;ul, li &#123;list-style: none;&#125;.page-ui-box &#123;overflow: hidden;border-left: 1px solid #CCC;&#125;.page-ui-box li &#123;float: left;padding: 5px 25px;height: 30px;line-height: 30px;border: 1px solid #CCC;border-left:none;cursor: pointer;&#125;.unable &#123;background: #EEE;&#125;.page-ui-box a &#123;text-decoration: none;&#125;.able a &#123;color: blue;&#125;.able a:hover &#123;text-decoration: underline;&#125;table&#123;border-collapse:collapse; border-spacing:0; border-left:1px solid #aaa; border-top:1px solid #aaa; &#125;td&#123;border-right:1px solid #aaa; border-bottom:1px solid #aaa; padding:3px 15px; text-align:left; color:#3C3C3C;&#125; 三、图片验证码类的封装 libs/Verify文件夹 1、Verify.class.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?php namespace libs\Verify;class Verify&#123; private $width=100; private $height=30; private $content="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; private $num=4; private $point=100; private $line= 4; public function __construct()&#123; &#125; public function show()&#123; /** * 字母+数字的验证码生成 */ // 开启session session_start(); //1.创建黑色画布 $image = imagecreatetruecolor($this-&gt;width, $this-&gt;height); //2.为画布定义(背景)颜色 $bgcolor = imagecolorallocate($image, 255, 255, 255); //3.填充颜色 imagefill($image, 0, 0, $bgcolor); // 4.设置验证码内容 //4.1 定义验证码的内容 //4.1 创建一个变量存储产生的验证码数据，便于用户提交核对 $captcha = ""; for ($i = 0; $i &lt; $this-&gt;num; $i++) &#123; // 字体大小 $fontsize = 5; // 字体颜色 随机生成字体颜色 $fontcolor = imagecolorallocate($image, mt_rand(0, 120), mt_rand(0, 120), mt_rand(0, 120)); // 设置字体内容 $fontcontent = substr($this-&gt;content, mt_rand(0, strlen($this-&gt;content)), 1); $captcha .= $fontcontent; // 显示的坐标 $x = ($i * $this-&gt;width / $this-&gt;num) + mt_rand(5, 10); $y = mt_rand($this-&gt;height/3, $this-&gt;height/2); // 填充内容到画布中 imagestring($image, $fontsize, $x, $y, $fontcontent, $fontcolor); &#125; $_SESSION["captcha"] = $captcha; //4.3 设置背景干扰元素 for ($i = 0; $i &lt; $this-&gt;point; $i++) &#123; $pointcolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imagesetpixel($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $pointcolor); &#125; //4.4 设置干扰线 for ($i = 0; $i &lt; $this-&gt;line; $i++) &#123; $linecolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imageline($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $linecolor); &#125; return $image; //6.输出图片到浏览器 // imagepng($image); //7.销毁图片 // imagedestroy($image); &#125; public function width($width) //设置验证码图片的宽度 &#123; $this-&gt;width=$width; return $this; &#125; public function height($height) //设置验证码图片的高度 &#123; $this-&gt;height=$height; return $this; &#125; public function setLine($line) //设置验证码图片的干扰线数量 &#123; $this-&gt;line=$line; return $this; &#125; public function setNum($num) // 设置验证码的位数 &#123; $this-&gt;num=$num; return $this; &#125; public function setChars($content) //设置验证码出现的字符集， 比如设置 123456789,那么验证码中出现的字符只能是这个字符串中的某几个 &#123; $this-&gt;content=$content; return $this; &#125; public function setPoint($point) // 设置验证码图片中出现的杂点数量 &#123; $this-&gt;point=$point; return $this; &#125;&#125;?&gt; 2、Verify类的实例verify.php： 12345678910111213141516171819&lt;?php//5.向浏览器输出图片头信息 header('content-type:image/png');spl_autoload_register(function($class)&#123; //$class = libs\Db\Mysql //libs\Db\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;&#125;); use libs\Verify\Verify; $verify=new Verify(); $char="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; $verifyhtml=$verify-&gt;width(200)-&gt;height(80)-&gt;setLine(6)-&gt;setNum(6)-&gt;setChars($char)-&gt;setPoint(500)-&gt;show(); //链式操作 //6.输出图片到浏览器 imagepng($verifyhtml); //7.销毁图片 imagedestroy($verifyhtml);?&gt; 四、运用实例这里通过start.php文件来运用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php//namespace "上级文件夹名称"// require_once 'libs/Db/Mysql.class.php';//引入命名空间spl_autoload_register(function($class)&#123; //$class = libs\Db\Mysql //libs\Db\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;&#125;); use libs\Db\Mysql; use libs\Page\Page; $db = Mysql::init(); //新建Mysql对象 $totals = $db-&gt;table("contact")-&gt;field("id")-&gt;count(); $pagesize = 3; //每一页显示的数据条数 $page = new Page($pagesize,$totals); //新建Page对象 $pagehtml = $page-&gt;show(); $left = $page-&gt;getoffset(); $db-&gt;setDebug(true); $data=$db-&gt;table("contact")-&gt;where(NULL)-&gt;field("*")-&gt;order("id desc")-&gt;limit("&#123;$left&#125;,&#123;$pagesize&#125;")-&gt;getList(); //链式操作 // $data = $db-&gt;getList('contact', NULL,"*", 'id desc', "&#123;$left&#125;, &#123;$pagesize&#125;"); // var_dump($data);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="libs/Page/page-ui.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;工作&lt;/td&gt; &lt;td&gt;QQ&lt;/td&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;留言内容&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach ($data as $key =&gt; $val) &#123; ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$val['id']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['userName']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['job']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['qqnum']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['phone']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['remark']?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; ?&gt; &lt;/table&gt; &lt;?=$pagehtml?&gt; &lt;!-- 显示分页样式 --&gt; &lt;img src="http://localhost/space/verify.php" onclick="resetPic(this)"&gt; &lt;!-- 显示图片验证码 --&gt; &lt;script type="text/javascript" src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function resetPic(obj) &#123; $(obj).attr('src', "http://localhost/space/verify.php"); //点击二维码刷新 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附：本人建立test数据库contact表的sql文件： 123456789use test; create table contact( id int primary key auto_increment, userName char(20) not null unique, job char(10) not null, qqnum char(10) not null, phone char(100), remark text );]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>数据库</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈PHP面向对象编程]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B5%85%E8%B0%88php%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本篇文章给大家分享的内容是关于浅谈PHP面向对象编程 ，有着一定的参考价值，有需要的朋友可以参考一下。 一、PHP面向对象编程基础实践123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** 通过对象的编程方式，可将实现生活中的一切事物以对象的形式表现出来。便于理解、维护、扩展等；* 本示例：定义一个“人”类* $name : 对象中的成员属性，在此类中表示人的姓名* say() : 对象中的成员方法，在此类中表示人说话的方法* $this : PHP中的伪变量，表示自身的类* __construct() : php中的魔术方法，构造函数，在实例化类时自动执行* __destruct() : php中的魔术方法，析构函数，当类调用完成后自动执行*/class Human&#123; public $name; public $sex; public $age; public function __construct($name,$sex,$age) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; public function say() &#123; echo '大家好，我的名字叫'.$this-&gt;name.'，今年'.$this-&gt;age.'岁，我的性别是'.$this-&gt;sex; &#125; public function __destruct() &#123; $this-&gt;name = null; $this-&gt;sex = null; $this-&gt;age = null; &#125;&#125;//实例化“人”类$male = new Human("张三","男","20");//调用“人”类说话的方法$male-&gt;say(); //输出结果：大家好，我的名字叫张三，今年20岁，我的性别是男?&gt; 二、PHP面向对象高级编程实践知识点：类的继承、方法重写、访问控制、static关键字、final关键字、数据访问、接口、多态、抽象类 2.1、类的继承：extends 关键字例如：一员运行员、一位主持人，他们有人类共同的行为方法，但他们都有自己不同的特长专业。因此在编程时需要给他们创建一个父类并继承； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** 创建一个“人”类做为父类，继承的子类都拥有其父类的成员属性、方法*/class Human&#123; public $name; public function say() &#123; echo "父类说话的方法，姓名：".$this-&gt;name."\n"; &#125; public function eat() &#123; echo "父类吃饭的方法\n"; &#125;&#125;/** 创建一个“运动员”类，继承“人”类* extends : 关键字，继承某个类*/class Sport extends Human&#123; public $type; public function __construct($name,$type) &#123; $this-&gt;name = $name; //给父类 $name 属性赋值 $this-&gt;type = $type; &#125; public function run() &#123; $this-&gt;say(); //调用父类“说话”的方法 echo "我在正跑步，我是一员".$this-&gt;type."运动员.....\n"; &#125;&#125;/** 创建一个“主持人”类，继承“人”类* extends : 关键字，继承某个类*/class Host extends Human&#123; public $television; public function __construct($name,$television) &#123; $this-&gt;name = $name; $this-&gt;television= $television; &#125; public function perform() &#123; $this-&gt;eat(); //调用父类“吃饭”的方法 echo "我在正表演一个节目，我是".$this-&gt;television."电视台的一名主持人.....\n"; &#125;&#125; //实例化“运动员”类$nba = new Sport("乔丹","篮球");$nba-&gt;run(); //实例化“主持人”类$tv = new Host("张三","北京卫视");$tv-&gt;perform(); //输出结果：//父类说话的方法，姓名：乔丹 我在正跑步，我是一员篮球运动员..... //父类吃饭的方法 我在正表演一个节目，我是北京卫视电视台的一名主持人.....?&gt; 2.2、方法重写：子类重写父类的方法 1234567891011121314151617181920&lt;?phpclass Human&#123; public function say() &#123; echo "父类说话的方法"; &#125;&#125;class Sport extends Human&#123; //重写父类“说话”的方法 public function say() &#123; echo "子类说话的方法"; &#125;&#125;$nba = new Sport();$nba-&gt;say();//输出结果：子类说话的方法?&gt; 2.3、访问控制：public 、 protected 、private 关键字 public：定义公共的成员属性或方法，任何地方都可使用protected : 定义受保护的成员属性或方法，只允许类本身或子类使用private : 定义私有的成员属性或方法，只允许类的本身使用 123456789101112&lt;?phpclass Human&#123; public $name; protected $sex; private $age; &#125;//实例化对象，给公共属性赋值可正常输出结果，外部不能给protected、private受保护的成员属性赋值或使用$worker = new Human();$worker-&gt;name = "张三";echo $worker-&gt;name;?&gt; 2.4、static（静态）关键字1）、静态属性用于保存类的公有数据；2）、静态方法里面只能访问静态属性或方法，不能使用 $this 伪变量；3）、静态成员不需要通过 new 关键字来实例化对象就可访问使用； 123456789101112131415&lt;?phpclass Human&#123; static $name = "张三"; static function say() &#123; echo "我的姓名叫：".self::$name; &#125;&#125;//外部使用静态成员属性或方法echo Human::$name;Human::say(); //输出结果：张三 我的姓名叫：张三?&gt; 2.5、final关键字：不允许成员方法被重写，不允许被继承例：1、对于父类“吃饭”这个方法，不希望子类重写它；2、对于“运动员”这个类，不希望它再创建子类； 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Human&#123; final public function eat() &#123; echo "父类吃饭的方法，不允许子类重写"; &#125;&#125;final class Sport extends Human&#123; public function eat() &#123; echo "子类吃饭的方法。此时程序将会报致命错误"; &#125;&#125;//创建一个类继承 Sport 这个类。此时程序也将会报致命错误。因为 Sport 类不允许再创建子类class Student extends Sport&#123; public $name;&#125; //实例化 Sport 类 ，调用 eat() 方法$nba = new Sport();$nba-&gt;eat(); //实例化 Student 类 ，给 name 属性负值$obj = new Student();$obj-&gt;name = "张三"; //输出结果：Fatal error: Cannot override final method Human::eat() in ******.php on line 15//Fatal error: Class Student may not inherit from final class (Sport) in ****.php on line 20?&gt; 2.6、数据访问：$this 、 self 、parent 关键字$this ： 伪变量，代表类的本身，可访问本类及父类中的成员属性与方法。self ： 访问类中的静态成员属性或方法parent ：访问父类的成员属性或方法 1234567891011121314151617181920&lt;?phpclass Human&#123; static $name = "张三";&#125;class Sport extends Human&#123; static function getParentName() &#123; echo parent::$name; &#125; public function get() &#123; self::getParentName(); &#125;&#125;$obj = new Sport();$obj-&gt;get();//输出结果：张三?&gt; 2.7、接口：把不同类的共同行为方法进行定义，但不具体实现，由子类来实现具体的方法；例如：人会吃饭，动物也会吃饭，甚至有些植物也会吃饭，但他们吃饭的方式不一样，因此这时需要定义一个接口类，具体的方式由子类来实现；定义接口关键字：interface实现接口方法关键字：implements 123456789101112131415161718192021222324252627282930313233&lt;?php//定义一个接口类，有吃饭的方法，但不具体实现。interface ICanEat&#123; public function eat($food);&#125;class Human implements ICanEat&#123; //eat()方法必须由子类来实现，否则程序将报致命错误 public function eat($food) &#123; echo "I'm eating ".$food; &#125;&#125;class Animal implements ICanEat&#123; public function eat($food) &#123; echo "It's eating ".$food; &#125;&#125;//实例化一个“人”类$people = new Human();$people-&gt;eat('rice'); //实例化一个“动物”类$monkey = new Animal();$monkey-&gt;eat('banana'); //输出结果：I'm eating rice// It's eating banana ?&gt; 2.8、多态：比如接口A有两个实现B和C，B和C对A接口里面定义的方法实现可以是不同的，这种现象称之为多态；上述实例中，ICanEat接口定义了一个eat()方法，人类吃米饭，猴子吃香蕉。他们都实现了一个“吃”的方法，但他们吃东西有不同的行为，称之为多态； 2.9、抽象类：介入接口与类的定义之间，允许类里面一部分方法不实现，实现一部分有相同功能且不会更改的方法。然而接口类里面不允许有任何实现的方法。例如：人和动物都具有吃饭与呼吸的方法，除吃饭不同以外，呼吸方法是相同的，此时需要定义一个抽象类来实现。定义抽象类关键字：abstract 1234567891011121314151617181920212223&lt;?php//定义一个抽象类，里面有吃饭和呼吸的方法。呼吸方法需要在抽象类中具体实现abstract class ICanEat&#123; abstract function eat($food); public function breath() &#123; echo 'Breath use the air...'; &#125;&#125;class Human extends ICanEat&#123; public function eat($food) &#123; echo "I'm eating ".$food; $this-&gt;breath(); &#125;&#125;//实例化“人”类$people = new Human();$people-&gt;eat('rice');//输出结果:I'm eating rice Breath use the air...?&gt; 三、PHP面向对象编程特殊实践PHP语言特定的一些魔术方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Object&#123; public function __construct() &#123; echo "当类在被实例化的时候，自动执行该函数"; &#125; public function __toString() &#123; return "当对象被当作字符串形式输出时，自动执行该函数"; &#125; public function __invoke($value) &#123; echo "当对象被当作函数调用时，自动执行该函数".$value; &#125; /* * 当对象访问不存在的方法时，自动执行该函数。也称之为“方法重载” * $fun : 方法名称 * $param : 传递的参数 */ public function __call($fun,$param) &#123; echo "调用".$fun."方法不存在，传递的参数".implode(',',$param); &#125; /* * 当对象访问不存在的静态方法时，自动执行该函数。 * $fun : 方法名称 * $param : 传递的参数 */ static function __callStatic($fun,$param) &#123; echo "调用".$fun."静态方法不存在，传递的参数".implode(',',$param); &#125; public function __get($key) &#123; echo "当读取对象中不可访问（未定义）的属性值时，自动调用该函数。".$key."属性不可访问或未定义"; &#125; public function __set($key,$value) &#123; echo "当给对象中不可访问（未定义）的属性赋值时，自动调用该函数。".$key."属性不可访问或未定义，值".$value; &#125; public function __isset($key) &#123; echo "判断对象中的属性不存在时，自动执行该函数。属性：".$key."值未定义"; &#125; public function __unset($key) &#123; echo "释放对象中的不存在的属性值时，自动执行该函数。属性：".$key."值未定义"; &#125; public function __clone() &#123; echo "当对象被克隆时，自动执行该函数。"; &#125; public function __destruct() &#123; echo "当对象执行完成后，自动执行该函数"; &#125;&#125;$obj = new Object(); //实例化对象时，调用__construct()方法echo $obj; //将对象以字符串形式输出时，调用__toString()方法$obj(123); //当对象以函数形式调用时，执行__invoke()方法$obj-&gt;runTest(); //当调用对象中不存在的方法时，执行__call()方法$obj::runTest(); //当调用对象中不存在的静态方法时，执行__callStatic()方法$obj-&gt;name; //当调用对象中不存在的成员属性时，执行__get()方法$obj-&gt;name = "张三"; //当给对象中不存在的成员属性赋值时，执行__set()方法isset($obj-&gt;name) ? 1 : 0; //判断对象中不存在的成员属性时，执行__isset()方法unset($obj-&gt;name); //释放对象中的不存在的属性值时，执行__unset()方法$obj2 = clone $obj; //当对象被克隆时，执行__clone()方法 //对象执行完毕，执行__destruct()方法?&gt;]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用jQuery实现简单的图片轮播效果]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%95%88%E6%9E%9C%20%2F</url>
    <content type="text"><![CDATA[以下代码使用了jQuery来实现简单的图片轮播效果： html部分：12345678910111213141516171819202122&lt;div id="slider"&gt; &lt;ul class="slider_list"&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="4.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="5.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="6.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="7.jpeg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="8.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="slider_icon"&gt; &lt;i class="btn btn_act"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;/div&gt; &lt;a href="javascript:;" class="arrow left"&gt; &lt;span class="slider_left"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href="javascript:;" class="arrow right"&gt; &lt;span class="slider_right"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; css部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#slider&#123; width: 750px; height: 450px; margin: 10% auto; position: relative; border: 0px red solid &#125;#slider img&#123; width: 750px; height: 450px; &#125;li&#123; list-style: none; &#125;.slider_list li&#123; position: absolute; display: none; &#125;.slider_list li:first-child&#123; display: block; &#125;.arrow&#123; display: none; width:40px; height: 60px; background: rgba(0,0,0,.2); position: absolute; top: 50%; margin-top: -40px; &#125;.left&#123; left: 0px; &#125;.right&#123; right: 0px; &#125;.arrow span&#123; display: none; width: 15px; height: 15px; border-bottom: 2px solid #fff; border-left: 2px solid #fff; &#125;.slider_left&#123; margin-top:25px; margin-left: 15px; transform: rotate(45deg); &#125;.slider_right&#123; margin-top:25px; margin-left: 5px; transform: rotate(-135deg); &#125;.arrow:hover&#123;background: #444&#125;#slider:hover .arrow&#123;display:block;&#125;#slider:hover .arrow span&#123;display:block;&#125;.slider_icon&#123; width: 195px; height: 35px; background-color:hsla(0,0%,100%,.3); position: absolute; bottom: 0px; left: 50%; margin-left: -100px; border-radius: 30px; margin-bottom: 15px; z-index: 2; display: block; &#125;.slider_icon i&#123; display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 11px; margin-left: 11px; margin-top: 13px; &#125;.slider_icon:hover&#123;background-color:rgba(0,0,0,.4);&#125; .btn&#123; background: #fff; &#125;.btn_act&#123; background: #FCD705 &#125; js部分：12345678910111213141516171819202122232425var count=0;var $li=$(".slider_list&gt;li");var timer=setInterval("next()",4000); function next() &#123; count++; if (count==$li.length) &#123; count=0; &#125; $li.eq(count).fadeIn().siblings().fadeOut(); $(".slider_icon&gt;i").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); &#125; $(".right").click(function()&#123;next();&#125;); $(".left").click(function()&#123; count--; if (count == -1) &#123; count=$li.length-1; &#125; $li.eq(count).fadeIn().siblings().fadeOut(); $(".slider_icon&gt;i").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); &#125;) $(".slider_icon&gt;i").mouseenter(function()&#123; $(this).addClass('btn_act').siblings().removeClass('btn_act'); $li.eq($(this).index()).fadeIn().siblings().fadeOut(); count=$(this).index(); &#125;)]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题SEO优化]]></title>
    <url>%2F2018%2F07%2F29%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98SEO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[刚搭建完博客，发现自己发表的文章在谷歌或者百度都搜索不到，今天看了一些文章，原来是需要seo优化的，所以就来总结一下seo优化的方法，让自己的博文能在谷歌百度上搜索到。本文主要以谷歌搜索为主。 添加站点地图–安装sitemap站点地图自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save –修改站点配置文件将sitemap文件添加到站点配置文件_config.yml中，并修改url字段的值，其值默认为https://yoursite.com(你的博客域名）。 123456sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlurl: https://abner0101.github.io 配置好后，执行hexo g 就能在站点public\目录中生成sitemap.xml 和 baidusitemap.xml了;其中第一个是一会要提交给google的，后面那个看名字当然就是提交给Baidu的了； 添加蜘蛛协议在站点source文件夹下新建robots.txt文件，文件内容如下：（参考我的） 123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://abner0101.github.io/sitemap.xmlSitemap: https://abner0101.github.io/baidusitemap.xml 其中Allow后面的就是你的menu请自行将abner0101.github.io改成自己的域名，然后hexo d -g提交一下 提交站点到Google打开Google Search Console，根据提示注册好之后，添加你的博客域名。 站点验证我选择了备用方法中的HTML 标记，将给出的元标记复制到\themes\hexo-theme-next\layout_partials\head.swig文件中。添加后运行hexo d -g将改动提交。稍后就可以验证成功了。 123456&lt;meta charset="UTF-8"/&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/&gt;&lt;meta name="theme-color" content="&#123;&#123; theme.android_chrome_color &#125;&#125;"&gt;&lt;meta name="google-site-verification" content="xxxxxxxxxxxxx" /&gt;&lt;meta name="baidu-site-verification" content="xxxxxxxxx" /&gt; 测试robots.txt点击左侧的robots.txt测试工具，根据提示提交你的robots.txt，其实刚才我们已经提交了。 注意要0错误才可以，如果有错误的话，会有提示，改正确就可以了。 提交站点地图还记得我们刚才创建创建sitemap.xml文件吧,现在它要派上用场了。点击左侧工具栏的站点地图 Google 抓取方式提交站点地图之后，点击左侧的Google 抓取方式 这一步很重要！这一不很重要！这一步很重要！在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。提交完成后，提交至索引，根据提示操作就可以了。 网站结构自身优化出站链接添加nofollow标签网络爬虫会在当前页面搜索所有的链接，然后一个个查看，所以就很有可能跳到别的网站就不回来了。这个时候就需要nofollow起作用了。 nofollow标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 修改footer.swig文件路径在your-hexo-site\themes\next\layout_partials，将下面代码中的a标签加上rel=”external nofollow”属性。 1&#123;&#123; __('footer.powered', '&lt;a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 1&lt;a rel="external nofollow" class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next"&gt; 修改sidebar.swig文件路径在your-hexo-site\themes\next\layout_macro，将下面代码中的a标签加上rel=”external nofollow”属性 1&lt;a href="https://creativecommons.org/&#123;% if theme.creative_commons === 'zero' %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/" rel="external nofollow" class="cc-opacity" target="_blank"&gt; 1&lt;a href="&#123;&#123; link &#125;&#125;" title="&#123;&#123; name &#125;&#125;" rel="external nofollow" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 1&lt;a rel="external nofollow" href="&#123;&#123; link.split('||')[0] | trim &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; 至此，seo优化得差不多了，还有很多可以优化的地方，博主日后再更新。马上上google搜索一下你的关键词和博客title测试一下吧！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记Hexo + Github Pages博客搭建]]></title>
    <url>%2F2018%2F07%2F27%2F%E8%AE%B0Hexo%20%2B%20Github%20pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[很早之前就听说可以通过github pages来搭建博客，但是由于种种原因（就是懒），迟迟没有付诸行动，终于，趁着暑假，开始了我的hexo+github pages 搭建博客的踩坑记，折腾了两天，终于成功搭建好了博客，接下来，开始分享搭建本博客的过程中以及各种坑。。。 用Hexo + Gitpages的原因 不用配置服务器 不用数据库 访问速度相当快 没有安全性可言 使用户可更注重博客内容 支持markdown还有就是hexo相对来说轻巧一些，生成文章的速度也比较快（静态博客生成页面时都是要整站生成，所以，页面越多，速度就越慢） 从hexo开始首先本地得装上了node.js、git和hexo 安装git：git 安装nodejs：node.js官网 hexo：hexo官网 hexo使用npm安装（过程如下） 1234npm install hexo-cli -ghexo init blogcd bloghexo server 然后打开http://localhost:4000/就可以查看效果了。如果4000端口打不开，可以通过以下命令更改端口访问(改为3000） 1hexo s -p 3000 注：Hexo依赖Node.js和Git，需要先安装。hexo的使用可参详官网文档。 常用命令： 1234hexo g 生成静态博客，即重新生成public文件夹hexo s 本地预览调试 (一般组合使用 hexo g &amp;&amp; hexo s)hexo d (发布到github)hexo n (执行该命令之后在source/_posts目录下产生&lt; blog name &gt;.md文件，这是你的一篇新博客。可以在markdown工具下编写，markdown工具在网上搜有一大堆，比如本博主使用的csdn的markdown工具，具体怎么使用也可以自己百度啦~） 部署到Github在github上创建一个仓库，仓库必须命名为：你的github账号.github.io(例如我的账号为Abner0101，所以我的仓库名为：Abner0101.github.io) 配置hexo config.yml，修改Deployment 1234deploy: type: git repo: git@github.com:你的帐号/你的帐号.github.com.git branch: master 然后执行命令： 123hexo cleanhexo ghexo d 此时，在博客的根目录下会生成一个文件夹：.deploy 然后我们把这个文件夹里面的文件都push到刚才新建那个项目就OK了。几分钟过后，就可以打开：你的用户名.github.io 看到你的博客了。 绑定域名在项目的根目录，新建名为CNAME的文件，内容为：你的域名，例如我的就是：jdsheng.cn再到把你的域名指向你的用户名.github.io，几分钟过后，就可以看到成功的诞生了。 NexT主题与第三方服务我使用的主题是next，在你的博客根目录下gitbash，安装next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件(_config.yml)，增加一行： 1theme: next 进入themes/next，修改主题配置文件 _config.yml 定位到scheme参数来选择自己喜欢的主题风格： 1scheme: Mist 关于next主题更多的配置（添加评论，分享，喜欢，添加头像等功能）可以参考NexT使用文档 关于更换电脑，如何继续写博客1.将你原来的电脑上已经配置好的源代码项目拷贝到你新的电脑，注意，无需拷贝全部，只需要拷贝一下几个目录： 12345_config.ymlpackage.jsonscaffolds/source/themes/ 将这些目录放在一个目录下，例如：blog/ 2.在你的新电脑上配置hexo环境：安装git、安装node.js3.安装hexo，执行命令： 1npm install -g hexo 4.安装好之后，在hexo目录下gitbash，执行命令： 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 5.部署，执行命令： 12 hexo ghexo d 在执行第5步时，可能会出错，不知道你们会不会遇到，反正我是遇到了，在部署提交代码的时候出现了这个问题： 123456*** Please tell me who you are.Run git config --global user.email "you@example.com" git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository. 所以解决方法是当出现这个上述提示后 接着补充你在命令行中执行 12git config --global user.email "你的邮箱"git config --global user.name "你的名字" （注意 “ 前面是有空格的）输入后在接着执行hexo g、hexo d即可！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习记录]]></title>
    <url>%2F2018%2F07%2F27%2Fnode.js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[–node.js入门]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
