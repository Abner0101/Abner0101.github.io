<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript执行（二）：闭包和执行上下文到底是怎么回事？]]></title>
    <url>%2F2019%2F03%2F23%2FJavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在上一课，我们了解了 JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据“由 JavaScript 引擎发起”还是“由宿主发起”，分成了宏观任务和微观任务，接下来我们继续去看一看更细的执行粒度。一段 JavaScript 代码可能会包含函数调用的相关内容，从今天开始，我们就用两节课的时间来了解一下函数的执行。我们今天要讲的知识在网上有不同的名字，比较常见的可能有：闭包；作用域链；执行上下文；this 值。实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。我们可以简单看一下图。看着也许会有点晕，别着急，我会和你共同理一下它们之间的关系。当然，除了让你理解函数执行过程的知识，理清这些概念也非常重要。所以我们先来讲讲这个有点复杂的概念：闭包。闭包闭包翻译自英文单词 closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。闭包这个概念第一次出现在 1964 年的《The Computer Journal》上，由 P. J. Landin 在《The mechanical evaluation of expressions》一文中提出了 applicative expression 和 closure 的概念。在上世纪 60 年代，主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。这个古典的闭包定义中，闭包包含两个部分。环境部分环境标识符列表表达式部分当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。环境部分环境：函数的词法环境（执行上下文的一部分）标识符列表：函数中用到的未声明的变量表达式部分：函数体至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。实际上 JavaScript 中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧（其实我早年也是这么理解闭包，直到后来被朋友纠正，查了资料才改正过来）。执行上下文：执行的基础设施相比普通函数，JavaScript 函数的主要复杂性来自于它携带的“环境部分”。当然，发展到今天的 JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。JavaScript 中与闭包“环境部分”相对应的术语是“词法环境”，但是 JavaScript 函数比λ函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ函数中可没有这些东西，所以，在 JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。执行上下文在 ES3 中，包含三个部分。scope：作用域，也常常被叫做作用域链。variable object：变量对象，用于存储变量的对象。this value：this 值。在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。lexical environment：词法环境，当获取变量时使用。variable environment：变量环境，当声明变量时使用。this value：this 值。在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。lexical environment：词法环境，当获取变量或者 this 值时使用。variable environment：变量环境，当声明变量时使用code evaluation state：用于恢复代码执行位置。Function：执行的任务是函数时使用，表示正在被执行的函数。ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。Realm：使用的基础库和内置对象实例。Generator：仅生成器上下文有这个属性，表示当前生成器。我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的 ES2018 中规定的术语定义。尽管我们介绍了这些定义，但我并不打算按照 JavaScript 标准的思路，从实现的角度去介绍函数的执行过程，这是不容易被理解的。我想试着从代码实例出发，跟你一起推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分。比如，我们看以下的这段 JavaScript 代码：123var b = &#123;&#125;let c = 1this.a = 2;要想正确执行它，我们需要知道以下信息：var 把 b 声明到哪里；b 表示哪个变量；b 的原型是哪个对象；let 把 c 声明到哪里；this 指向哪个对象。这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。在这两篇文章中，我会基本覆盖执行上下文的组成部分，本篇我们先讲 var 声明与赋值，let，realm 三个特性来分析上下文提供的信息，分析执行上下文中提供的信息。var 声明与赋值我们来分析一段代码：1var b = 1通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用域函数执行的作用域。也就是说，var 会穿透 for 、if 等语句。在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。12345678910(function()&#123; var a; //code&#125;());(function()&#123; var a; //code&#125;)();但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。12345678910;(function()&#123; var a; //code&#125;());(function()&#123; var a; //code&#125;)()我比较推荐的写法是使用 void 关键字。也就是下面的这种形式。1234void function()&#123; var a; //code&#125;();这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。值得特别注意的是，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，JavaScript 中有特例，那就是使用 with 的时候：1234567891011var b;void function()&#123; var env = &#123;b:1&#125;; b = 2; console.log("In function b:", b); with(env) &#123; var b = 3; console.log("In with b:", b); &#125;&#125;();console.log("Global b:", b);在这个例子中，我们利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境，并且在里面使用了我们一开头的代码。可以看到，在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。letlet 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。我简单统计了下，以下语句会产生 let 使用的作用域：for；if；switch；try/catch/finally。Realm在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。这个英文的用法就有点比喻的意思，几个翻译都不太适合 JavaScript 语境，所以这里就不翻译啦。我们继续来看这段代码：1var b = &#123;&#125;在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：12345678910var iframe = document.createElement('iframe')document.documentElement.appendChild(iframe)iframe.src="javascript:var b = &#123;&#125;;"var b1 = iframe.contentWindow.b;var b2 = &#123;&#125;;console.log(typeof b1, typeof b2); //object objectconsole.log(b1 instanceof Object, b2 instanceof Object); //false true可以看到，由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。结语在今天的课程中，我帮你梳理了一些概念：有编程语言的概念闭包，也有各个版本中的 JavaScript 标准中的概念：执行上下文、作用域、this 值等等。之后我们又从代码的角度，分析了一些执行上下文中所需要的信息，并从var、let、对象字面量等语法中，推导出了词法作用域、变量作用域、Realm的设计。最后留给你一个问题：你喜欢使用 let 还是 var？转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段一）]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们的浏览器系列已经进行到最后一篇。在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM 树，并且根据样式信息，计算了每个元素的位置和大小。那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。渲染首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，也有“粉刷墙壁”的意思。在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，我们需要一个底层库来支持。一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++ 编写的开源的字体库。在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。合成合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 html 创建一个合成后的位图，把所有子元素都进行合成，那么会发生什么呢？那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制所有的元素。那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。我们来举个例子：1234&lt;div id="a"&gt; &lt;div id="b"&gt;...&lt;/div&gt; &lt;div id="c" style="transform:translate(0,0)"&gt;&lt;/div&gt;&lt;/div&gt;假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：1document.getElementById("c").style.transform = "translate(100px, 0)";我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。绘制绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。一般最终显式的位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者显式驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。然而如果在实际中这样做, 会带来极其糟糕的性能。有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免”重排”和”重绘”，前者讲的是我们上一课的排版行为，后者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的目标，当然，简单想想就知道，这种事情不可能总是发生的。计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。总结在这一节课程中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段一）]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到这样了。尤其是表格相关排版、flex 排版和 grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。基本概念首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。“排版”这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的位置。在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型）此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由 position 属性控制。浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 flex 排版，这些排版方式由外部元素的 display 属性来控制（注意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。正常流文字排版我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，我们先从文字来讲起。要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去继续写。书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面：纵向版本：这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、word-spacing 等。在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性（例如主轴为横向时的 margin-left 和 margin-right）也会被计算进排版前进距离当中。注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。正常流中的盒在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而 vertical-align 属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。绝对定位元素position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。浮动元素排版float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。float 元素排布完成后，float 元素所在的行需要重新确定位置。其它的排版CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height 属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。总结这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 flex 排版。这属于进阶版的排版方式了，你可以了解一下。你平时喜欢使用方式排版呢，欢迎留言告诉我。转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段一）]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%88%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在上一节课中，我已经讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的。整体过程首先我们还是要感性地理解一下这个过程。首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS 属性计算出来呢？答案是肯定的。在这个过程中，我们依次拿到上一部构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下：空格: 后代，选中它的子节点和所有子节点的后代节点。&gt;: 子代，选中它的子节点。+：直接后继选择器，选中它的下一个相邻节点。~：后继，选中它之后所有的相邻节点。||：列，选中表格中的一列。关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。理解了 CSS 构建的大概过程，我们下面来看看具体的操作。首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。后代选择器 “空格”我们先来分析一下后代选择器，我们来一起看一个例子：123a#b .cls &#123; width: 100px;&#125;可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：12345&lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt;&lt;/a&gt;&lt;span class=cls&gt;3&lt;span&gt;当遇到 &lt;/a&gt; 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。后继选择器“ ~ ”接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：123456789101112.cls~* &#123; border:solid 1px green;&#125;&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它的后继，因此应该被选中。按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。子代选择器“ &gt;”我们继续看，子代选择器是如何实现的。实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。123456789101112div&gt;.cls &#123; border:solid 1px green;&#125;&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。直接后继选择器“ +”直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。列选择器“ || ”列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。其它我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。比如123a#b, .cls &#123;&#125;我们当作两条规则来处理：123a#b &#123;&#125;123.cls &#123;&#125;还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：12345678910#a .cls &#123;&#125;#a span &#123;&#125;#a&gt;span &#123;&#125;这里实际上可以把选择器构造成一棵树：#a&lt; 空格 &gt;.cls&lt; 空格 &gt;span&gt;span需要注意的是，这里的树，必须要带上连接符。结语这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续继续显式打下了基础。最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？]]></title>
    <url>%2F2019%2F03%2F23%2FJavaScript%E6%89%A7%E8%A1%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APromise%E9%87%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94setTimeout%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这一部分我们来讲一讲 JavaScript 的执行。首先我们考虑一下，如果我们是浏览器或者 Node 的开发者，我们该如何使用 JavaScript 引擎。当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。宏观和微观任务JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：1234while(TRUE) &#123; r = wait(); execute(r);&#125;我们可以看到，整个循环做的事情基本上就是反复“等待 - 执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：有了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。接下来，我们来详细介绍一下 Promise。PromisePromise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。Promise 的基本用法示例如下：123456function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve,duration); &#125;)&#125;sleep(1000).then( ()=&gt; console.log("finished"));这段代码定义了一个函数 sleep，它的作用是等候传入参数指定的时长。Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序，我们来看一段代码示例：123456var r = new Promise(function(resolve, reject)&#123; console.log("a"); resolve()&#125;);r.then(() =&gt; console.log("c"));console.log("b")我们执行这段代码后，注意输出的顺序是 a b c。在进入 console.log(“b”) 之前，毫无疑问 r 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。接下来我们试试跟 setTimeout 混用的 Promise。在这段代码中，我设置了两段互不相干的异步操作：通过 setTimeout 执行 console.log(“d”)，通过 Promise 执行 console.log(“c”)1234567var r = new Promise(function(resolve, reject)&#123; console.log("a"); resolve()&#125;);setTimeout(()=&gt;console.log("d"), 0)r.then(() =&gt; console.log("c"));console.log("b")我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。为了理解微任务始终先于宏任务，我们设计一个实验：执行一个耗时 1 秒的 Promise。123456789101112setTimeout(()=&gt;console.log("d"), 0)var r1 = new Promise(function(resolve, reject)&#123; resolve()&#125;);r.then(() =&gt; &#123; var begin = Date.now(); while(Date.now() - begin &lt; 1000); console.log("c1") new Promise(function(resolve, reject)&#123; resolve() &#125;).then(() =&gt; console.log("c2"))&#125;);这里我们强制了 1 秒的执行耗时，这样，我们可以确保任务 c2 是在 d 之后被添加到任务队列。我们可以看到，即使耗时一秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行了，这很好地解释了微任务优先的原理。通过一系列的实验，我们可以总结一下如何分析异步执行的顺序：首先我们分析有多少个宏任务；在每个宏任务中，分析有多少个微任务；根据调用次序，确定宏任务中的微任务执行次序；根据宏任务的触发规则和调用次序，确定宏任务的执行次序；确定整个顺序。我们再来看一个稍微复杂的例子：12345678function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; console.log("b"); setTimeout(resolve,duration); &#125;)&#125;console.log("a");sleep(5000).then(()=&gt;console.log("c"));这是一段非常常用的封装方法，利用 Promise 把 setTimeout 封装成可以用于异步的函数。我们首先来看，setTimeout 把整个代码分割成了 2 个宏观任务，这里不论是 5 秒还是 0 秒，都是一样的。第一个宏观任务中，包含了先后同步执行的 console.log(“a”); 和 console.log(“b”);。setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(“c”)，最终输出的顺序才是： a b c。Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。新特性：async/awaitasync/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise，面对这种比较新的特性，我们先来看一下基本用法。async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。12345678910function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve,duration); &#125;)&#125;async function foo()&#123; console.log("a") await sleep(2000) console.log("b")&#125;这段代码利用了我们之前定义的 sleep 函数。在异步函数 foo 中，我们调用 sleep。async 函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。12345678910111213function sleep(duration) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(resolve,duration); &#125;)&#125;async function foo(name)&#123; await sleep(2000) console.log(name)&#125;async function foo2()&#123; await foo("a"); await foo("b");&#125;这里 foo2 用 await 调用了两次异步函数 foo，可以看到，如果我们把 sleep 这样的异步操作放入某一个框架或者库中，使用者几乎不需要了解 Promise 的概念即可进行异步编程了。此外，generator/iterator 也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。结语在今天的文章里，我们学习了 JavaScript 执行部分的知识，首先我们学习了 JavaScript 的宏观任务和微观任务相关的知识。我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。除此之外，我们还展开介绍了用 Promise 来添加微观任务的方式，并且介绍了 async/await 这个语法的改进。最后，留给你一个小练习：我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色，你会怎样编写这个代码呢？转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段二）]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我在上一篇文章中，简要介绍了浏览器的工作大致可以分为 6 个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面的过程。今天我们主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。解析代码我们在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的 Response 的 body，就要交给我们今天学习的内容去处理了。HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA 节点几种。实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。“&lt;?”和“&lt;%”什么的也是必须要支持好的，报了错也不能吭声。1. 词（token）是如何被拆分的首先我们来看看一个非常标准的标签，会被如何拆分：1&lt;p class="a"&gt;text text text&lt;/p&gt;如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了（它甚至可以嵌套）。那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“&lt;p” ，所以“ &lt;p” 就是我们的第一个词（token）。我们继续拆分，可以把这段代码依次拆成词（token）：&lt;p“标签开始”的开始；class=“a” 属性；&gt; “标签开始”的结束；text text text 文本；&lt;/p&gt; 标签结束。这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子：根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。比如，假设我们接受了一个字符“ &lt; ” 我们一下子就知道这不是一个文本节点啦。之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。2. 状态机绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看：当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML 官方文档，HTML 官方文档规定了 80 个状态（顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。这里我们为了理解原理，用这个简单的状态机就足够说明问题了。状态机的初始状态，我们仅仅区分 “&lt; ”和 “非 &lt;”：如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点；如果获得的是一个 &lt; 字符，那么进入一个标签状态。不过当我们在标签状态时，则会面临着一些可能性。比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。如果下一个字符是字母，那么可以确定进入了一个开始标签。如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。接下来就是代码实现的事情了，在 C/C++ 和 JavaScript 中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装状态机。）为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344var data = function(c)&#123; if(c=="&amp;") &#123; return characterReferenceInData; &#125; if(c=="&lt;") &#123; return tagOpen; &#125; else if(c=="\0") &#123; error(); emitToken(c); return data; &#125; else if(c==EOF) &#123; emitToken(EOF); return data; &#125; else &#123; emitToken(c); return data; &#125;&#125;;var tagOpenState = function tagOpenState(c)&#123; if(c=="/") &#123; return endTagOpenState; &#125; if(c.match(/[A-Z]/)) &#123; token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; &#125; if(c.match(/[a-z]/)) &#123; token = new StartTagToken(); token.name = c; return tagNameState; &#125; if(c=="?") &#123; return bogusCommentState; &#125; else &#123; error(); return dataState; &#125;&#125;;//……这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个“ &lt; ” 字符，来判断标签类型的状态。这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。这样，我们的状态迁移代码非常的简单：1234var state = data;var charwhile(char = getInput()) state = state(char);这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理方式。词法分析器接受字符的方式很简单，就像下面这样：12345678910111213141516function HTMLLexicalParser()&#123; // 状态函数们…… function data() &#123; // …… &#125; function tagOpen() &#123; // …… &#125; // …… var state = data; this.receiveInput = function(char) &#123; state = state(char); &#125;&#125;至此，我们就把字符流拆成了词（token）了。构建 DOM 树接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。123456789function HTMLSyntaticalParser()&#123; var stack = [new HTMLDocument]; this.receiveInput = function(token) &#123; //…… &#125; this.getOutput = function()&#123; return stack[0]; &#125;&#125;我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emmitToken 来调用。在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP 的话，我们还需要抽象工厂来创建对象），123456function Element()&#123; this.childNodes = [];&#125;function Text(value)&#123; this.value = value || "";&#125;前面我们的词（token）中，以下两个是需要成对匹配的：tag starttag end根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点同样我们来看看直观的解析过程：12345678&lt;html maaa=a &gt; &lt;head&gt; &lt;title&gt;cool&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="a" /&gt; &lt;/body&gt;&lt;/html&gt;通过这个栈，我们可以构建 DOM 树：栈顶元素就是当前节点；遇到属性，就添加到当前节点；遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；遇到注释节点，作为当前节点的子节点；遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；遇到 tag end 就出栈一个节点（还可以检查是否匹配）。我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。当我们的源代码完全遵循 xhtml（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction结语好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。转自—《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器：一个浏览器是如何工作的？（阶段一）]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它能做什么，而不知道它是如何做到的。在我面试和接触过的前端开发者中，70% 的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师实现浏览器”的水准。那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。这个过程是这样的： 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面； 把请求回来的 HTML 代码经过解析，构建成 DOM 树； 计算 DOM 树上的 CSS 属性； 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图； 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度； 合成之后，再绘制到界面上。我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。首先我们来介绍下网络通讯的部分。HTTP 协议浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议（实际上这个过程之前还有 DNS 查询，不过这里就不详细展开了。）我先来了解下 HTTP 的标准。HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份： HTTP1.1 https://tools.ietf.org/html/rfc26162.HTTP1.1 https://tools.ietf.org/html/rfc7234HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP 一下：实验我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具（安装方法）。首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容： 1telnet time.geekbang.org 80 这个时候，TCP 连接已经建立，我们输入以下字符作为请求： 12GET / HTTP/1.1Host: time.geekbang.org 按下两次回车，我们收到了服务端的回复： 123456789101112131415HTTP/1.1 301 Moved PermanentlyDate: Fri, 25 Jan 2019 13:28:12 GMTContent-Type: text/htmlContent-Length: 182Connection: keep-aliveLocation: https://time.geekbang.org/Strict-Transport-Security: max-age=15768000&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和版本。在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 html 代码。HTTP 协议格式根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分。我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。下面我们就来逐个给你介绍其它部分。HTTP Method（方法）我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型。方法有以下几种定义： GET POST HEAD PUT DELETE CONNECT OPTIONS TRACE浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。CONNECT 现在多用于 HTTPS 和 WebSocket。OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。HTTP Status code（状态码）和 Status text（状态文本）接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。 1xx：临时回应，表示客户端请继续。 2xx：请求成功。 200：请求成功。 3xx: 表示请求的目标有变化，希望客户端进一步处理。 301&amp;302：永久性与临时性跳转。 304：跟客户端缓存没有更新。 4xx：客户端请求错误。 403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议） 5xx：服务端请求错误。 500：服务端错误。 503：服务端暂时性错误，可以一会再试。对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。HTTP Head (HTTP 头)HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，我们现在就来了解一下它们。在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下：我们先来看看 Request Header。接下来看一下 Response Header。这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完整的列表还是请你参考我给出的 rfc2616 标准。HTTP Request BodyHTTP 请求的 body 主要用于提交表单场景。实际上，http 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是： application/json application/x-www-form-urlencoded multipart/form-data text/xml我们使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。HTTPS在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：https://tools.ietf.org/html/rfc2818HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。HTTP 2HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。https://tools.ietf.org/html/rfc7540HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。 Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。结语在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的这一过程。在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head 和 HTTP Request Body 几个重点需要注意的部分。最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。转自–《重学前端》]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP知识点积累]]></title>
    <url>%2F2018%2F09%2F17%2FPHP%E7%9F%A5%E8%AF%86%E7%82%B9%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[1、关于$_FILES 处理文件上传2、数组的定义和遍历3、关于命名空间的简单介绍]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP mysql数据库面向对象简单操作类（增删改查）、分页类和图片验证码类的封装]]></title>
    <url>%2F2018%2F09%2F17%2Fphp%20mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%B1%BB%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%89%E3%80%81%E5%88%86%E9%A1%B5%E7%B1%BB%E5%92%8C%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[这篇文章中已经介绍了PHP连接数据库的方法以及最基本的对数据库的操作，但并没有实现模块化，所有的代码全都集中在表现页面中，造成了代码冗余，不仅不利于维护也不利于代码的重用性，那么在这篇文章中将用面向对象的知识对数据库的连接和基本操作方法进行封装，也简单地对地分页功能进行了封装，这样就大大避免了代码的重复。 以下文件放置于space文件夹中 一、封装简单的数据库的增删改查等函数 libs/Db文件夹 1、先写一个db.config.php文件来使用里面是你数据库的信息 123456789&lt;?phpreturn array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'password' =&gt; 'root', 'port' =&gt; '3306', 'dbname' =&gt; 'test', 'charset' =&gt; 'utf8'); 2、通过Idb.class.php文件来定义接口 12345678910&lt;?phpnamespace libs\Db; //引入命名空间interface Idb &#123; public function add(); public function getOne(); public function getList(); public function update(); public function delete(); public function count();&#125; 什么是命名空间 3、通过Mysql.class.php来封装接口的各个功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;?phpnamespace libs\Db;class Mysql implements Idb &#123; private $_link = NULL; private $_debug = false; private $_where = NULL; private $_table = NULL; private $_data = NULL; private $_fields = NULL; private $_limit=NULL; private $_order = NULL; private static $_instance = NULL; private function __construct() &#123; if ( $this-&gt;_link == NULL ) &#123; $this-&gt;connect(); &#125; &#125; public static function init() &#123; if ( self::$_instance == NULL ) &#123; self::$_instance = new self(); &#125; return self::$_instance; &#125; private function excute($sql) //执行sql语句 &#123; if ( $this-&gt;_debug == true ) &#123; echo "EXCUTE SQL: &#123;$sql&#125; &lt;br/&gt;"; &#125; $ret = $this-&gt;_link-&gt;query($sql); return $ret; &#125; public function setDebug( $debug = true ) //调试函数 &#123; $this-&gt;_debug = $debug; &#125; private function connect() //连接数据库 &#123; $conf = require_once 'db.config.php'; $this-&gt;_link = new \mysqli($conf['host'], $conf['user'], $conf['password'], $conf['dbname'],$conf['port']); if ($this-&gt;_link-&gt;connect_error) &#123; die('Connect Error (' . $this-&gt;_link-&gt;connect_errno . ') ' . $this-&gt;_link-&gt;connect_error); &#125; date_default_timezone_set('PRC'); //设时区 $this-&gt;_link-&gt;query("SET NAME &#123;$conf['charset']&#125;"); &#125; public function table( $table ) //获取表 &#123; $this-&gt;_table = $table; return $this; &#125; public function where($where= NULL) &#123; $this-&gt;_where = $where; return $this; &#125; public function data($data) &#123; $this-&gt;_data = $data; return $this; &#125; public function field($fields)&#123; $this-&gt;_fields = $fields; return $this; &#125; public function order($order)&#123; $this-&gt;_order = $order; return $this; &#125; public function limit($limit)&#123; $this-&gt;_limit = $limit; return $this; &#125; public function add() //添加数据 &#123; $sql = "INSERT INTO &#123;$this-&gt;_table&#125; ("; $fields = ""; $values = ""; foreach( $this-&gt;_data as $key =&gt; $val ) &#123; if ( $fields == "" ) $fields = $key; else $fields .= ",".$key; if ( $values == "" ) $values = "'&#123;$val&#125;'"; else $values .= ","."'&#123;$val&#125;'"; &#125; $sql .= "&#123;$fields&#125; )VALUES(&#123;$values&#125;)"; $ret = $this-&gt;excute($sql); return $ret; &#125; public function getOne() //获取一组数据 &#123; //select id,name from table where id = 10 if ( is_array($this-&gt;_fields) ) $fields = implode(',', $fields); $sql = "SELECT &#123;$this-&gt;_fields&#125; FROM &#123;$this-&gt;_table&#125;"; if ( $this-&gt;_where != NULL ) $sql .= " WHERE &#123;$this-&gt;_where&#125;"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row; &#125; public function getList() //获取多组数据 &#123; //select id,name from table where id &gt; 10 //若查询字段为一维数组，以,拼接为目标字符串 if ( is_array($this-&gt;_fields) ) $this-&gt;_fields = implode(',', $this-&gt;_fields); $sql = "SELECT &#123;$this-&gt;_fields&#125; FROM &#123;$this-&gt;_table&#125;"; if ( $this-&gt;_where != NULL ) $sql .= " WHERE &#123;$this-&gt;_where&#125;"; if ($this-&gt;_order !=NULL) $sql .= " ORDER BY &#123;$this-&gt;_order&#125;"; if ( $this-&gt;_limit != NULL ) $sql .= " LIMIT &#123;$this-&gt;_limit&#125;"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $result = []; while ( ($row = $ret-&gt;fetch_assoc()) != false) &#123; $result[] = $row; &#125; return $result; &#125; public function update() //更新数据 &#123; //update table set name = "wein" where id = 1 $sql = "UPDATE &#123;$this-&gt;_table&#125; SET "; $fields = ""; foreach( $this-&gt;_data as $key =&gt; $val ) &#123; if ( $fields == "" ) $fields = "&#123;$key&#125;='&#123;$val&#125;'"; else $fields .= ","."&#123;$key&#125;='&#123;$val&#125;'"; &#125; if ( $this-&gt;_where != NULL ) $sql .= "&#123;$fields&#125; WHERE &#123;$this-&gt;_where&#125;"; else $sql .= "&#123;$fields&#125;"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $row = $this-&gt;_link-&gt;affected_rows; if ( $row == 0 ) return false; return true; &#125; public function delete()//删除数据 &#123; //拼接sql语句 //delete from table where id =1 $sql = "DELETE FROM &#123;$this-&gt;_table&#125; WHERE &#123;$this-&gt;_where&#125;"; $ret = $this-&gt;excute($sql); return $ret; &#125; public function count() //统计数据 &#123; $sql = "SELECT COUNT(&#123;$this-&gt;_fields&#125;) AS num FROM &#123;$this-&gt;_table&#125;"; if ( $this-&gt;_where != NULL ) $sql .= " WHERE &#123;$this-&gt;_where&#125;"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row['num']; &#125; public function __destruct() //断开数据库连接 &#123; $this-&gt;_link-&gt;close(); $this-&gt;_link = NULL; &#125; &#125; 二、分页类的封装 libs/Page文件夹 1、通过Page.class.php文件来封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpnamespace libs\Page;class Page &#123; private $_totals = 0; private $_pagesize = 0; public function __construct( $pagesize, $total ) &#123; $this-&gt;_totals = $total; $this-&gt;_pagesize = $pagesize; &#125; public function getoffset() //获取展示下一页开始的id值 &#123; $page = isset($_GET['page'])?$_GET['page']:1; $offset = ($page -1) * $this-&gt;_pagesize; return $offset; &#125; public function show($left = 2) &#123; $page = isset($_GET['page'])?$_GET['page']:1; $totalPages = ceil($this-&gt;_totals / $this-&gt;_pagesize); $html = '&lt;ul class="page-ui-box"&gt;'; if ( $page &gt; 1 )&#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page=1"&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.($page-1).'"&gt;上一页&lt;/a&gt;&lt;/li&gt;'; &#125; else &#123; $html .= '&lt;li class="unable"&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="unable"&gt;&lt;a&gt;上一页&lt;/a&gt;&lt;/li&gt;'; &#125; //当前页的前面显示两个数字页面 $start = ($page - $left); if ( $start &lt;= 0 ) $start = 1; for( $i = $start; $i &lt; $page; $i++ ) &#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.$i.'"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; &#125; $html .= '&lt;li class="unable"&gt;&lt;a&gt;'.$page.'&lt;/a&gt;&lt;/li&gt;'; //当前页的后面显示两个数字页面 $end = $page + 2; if ( $end &gt; $totalPages ) $end = $totalPages; for( $i = $page + 1; $i &lt;= $end; $i++ ) &#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.$i.'"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; &#125; if ( $page &lt; $totalPages ) &#123; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.($page+1).'"&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="able"&gt;&lt;a href="?page='.$totalPages.'"&gt;尾页&lt;/a&gt;&lt;/li&gt;'; &#125; else &#123; $html .= '&lt;li class="unable"&gt;&lt;a&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class="unable"&gt;&lt;a&gt;尾页&lt;/a&gt;&lt;/li&gt;'; &#125; $html .= '&lt;/ul&gt;'; return $html; &#125;&#125;?&gt; 2、样式文件Page-ui.css 12345678910* &#123;margin: 0px;padding: 0px;&#125;ul, li &#123;list-style: none;&#125;.page-ui-box &#123;overflow: hidden;border-left: 1px solid #CCC;&#125;.page-ui-box li &#123;float: left;padding: 5px 25px;height: 30px;line-height: 30px;border: 1px solid #CCC;border-left:none;cursor: pointer;&#125;.unable &#123;background: #EEE;&#125;.page-ui-box a &#123;text-decoration: none;&#125;.able a &#123;color: blue;&#125;.able a:hover &#123;text-decoration: underline;&#125;table&#123;border-collapse:collapse; border-spacing:0; border-left:1px solid #aaa; border-top:1px solid #aaa; &#125;td&#123;border-right:1px solid #aaa; border-bottom:1px solid #aaa; padding:3px 15px; text-align:left; color:#3C3C3C;&#125; 三、图片验证码类的封装 libs/Verify文件夹 1、Verify.class.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?php namespace libs\Verify;class Verify&#123; private $width=100; private $height=30; private $content="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; private $num=4; private $point=100; private $line= 4; public function __construct()&#123; &#125; public function show()&#123; /** * 字母+数字的验证码生成 */ // 开启session session_start(); //1.创建黑色画布 $image = imagecreatetruecolor($this-&gt;width, $this-&gt;height); //2.为画布定义(背景)颜色 $bgcolor = imagecolorallocate($image, 255, 255, 255); //3.填充颜色 imagefill($image, 0, 0, $bgcolor); // 4.设置验证码内容 //4.1 定义验证码的内容 //4.1 创建一个变量存储产生的验证码数据，便于用户提交核对 $captcha = ""; for ($i = 0; $i &lt; $this-&gt;num; $i++) &#123; // 字体大小 $fontsize = 5; // 字体颜色 随机生成字体颜色 $fontcolor = imagecolorallocate($image, mt_rand(0, 120), mt_rand(0, 120), mt_rand(0, 120)); // 设置字体内容 $fontcontent = substr($this-&gt;content, mt_rand(0, strlen($this-&gt;content)), 1); $captcha .= $fontcontent; // 显示的坐标 $x = ($i * $this-&gt;width / $this-&gt;num) + mt_rand(5, 10); $y = mt_rand($this-&gt;height/3, $this-&gt;height/2); // 填充内容到画布中 imagestring($image, $fontsize, $x, $y, $fontcontent, $fontcolor); &#125; $_SESSION["captcha"] = $captcha; //4.3 设置背景干扰元素 for ($i = 0; $i &lt; $this-&gt;point; $i++) &#123; $pointcolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imagesetpixel($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $pointcolor); &#125; //4.4 设置干扰线 for ($i = 0; $i &lt; $this-&gt;line; $i++) &#123; $linecolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imageline($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $linecolor); &#125; return $image; //6.输出图片到浏览器 // imagepng($image); //7.销毁图片 // imagedestroy($image); &#125; public function width($width) //设置验证码图片的宽度 &#123; $this-&gt;width=$width; return $this; &#125; public function height($height) //设置验证码图片的高度 &#123; $this-&gt;height=$height; return $this; &#125; public function setLine($line) //设置验证码图片的干扰线数量 &#123; $this-&gt;line=$line; return $this; &#125; public function setNum($num) // 设置验证码的位数 &#123; $this-&gt;num=$num; return $this; &#125; public function setChars($content) //设置验证码出现的字符集， 比如设置 123456789,那么验证码中出现的字符只能是这个字符串中的某几个 &#123; $this-&gt;content=$content; return $this; &#125; public function setPoint($point) // 设置验证码图片中出现的杂点数量 &#123; $this-&gt;point=$point; return $this; &#125;&#125;?&gt; 2、Verify类的实例verify.php： 12345678910111213141516171819&lt;?php//5.向浏览器输出图片头信息 header('content-type:image/png');spl_autoload_register(function($class)&#123; //$class = libs\Db\Mysql //libs\Db\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;&#125;); use libs\Verify\Verify; $verify=new Verify(); $char="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; $verifyhtml=$verify-&gt;width(200)-&gt;height(80)-&gt;setLine(6)-&gt;setNum(6)-&gt;setChars($char)-&gt;setPoint(500)-&gt;show(); //链式操作 //6.输出图片到浏览器 imagepng($verifyhtml); //7.销毁图片 imagedestroy($verifyhtml);?&gt; 四、运用实例这里通过start.php文件来运用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php//namespace "上级文件夹名称"// require_once 'libs/Db/Mysql.class.php';//引入命名空间spl_autoload_register(function($class)&#123; //$class = libs\Db\Mysql //libs\Db\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;&#125;); use libs\Db\Mysql; use libs\Page\Page; $db = Mysql::init(); //新建Mysql对象 $totals = $db-&gt;table("contact")-&gt;field("id")-&gt;count(); $pagesize = 3; //每一页显示的数据条数 $page = new Page($pagesize,$totals); //新建Page对象 $pagehtml = $page-&gt;show(); $left = $page-&gt;getoffset(); $db-&gt;setDebug(true); $data=$db-&gt;table("contact")-&gt;where(NULL)-&gt;field("*")-&gt;order("id desc")-&gt;limit("&#123;$left&#125;,&#123;$pagesize&#125;")-&gt;getList(); //链式操作 // $data = $db-&gt;getList('contact', NULL,"*", 'id desc', "&#123;$left&#125;, &#123;$pagesize&#125;"); // var_dump($data);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="libs/Page/page-ui.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;工作&lt;/td&gt; &lt;td&gt;QQ&lt;/td&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;留言内容&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach ($data as $key =&gt; $val) &#123; ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$val['id']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['userName']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['job']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['qqnum']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['phone']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['remark']?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php &#125; ?&gt; &lt;/table&gt; &lt;?=$pagehtml?&gt; &lt;!-- 显示分页样式 --&gt; &lt;img src="http://localhost/space/verify.php" onclick="resetPic(this)"&gt; &lt;!-- 显示图片验证码 --&gt; &lt;script type="text/javascript" src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function resetPic(obj) &#123; $(obj).attr('src', "http://localhost/space/verify.php"); //点击二维码刷新 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附：本人建立test数据库contact表的sql文件： 123456789use test; create table contact( id int primary key auto_increment, userName char(20) not null unique, job char(10) not null, qqnum char(10) not null, phone char(100), remark text );]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>数据库</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈PHP面向对象编程]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%B5%85%E8%B0%88php%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本篇文章给大家分享的内容是关于浅谈PHP面向对象编程 ，有着一定的参考价值，有需要的朋友可以参考一下。 一、PHP面向对象编程基础实践123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** 通过对象的编程方式，可将实现生活中的一切事物以对象的形式表现出来。便于理解、维护、扩展等；* 本示例：定义一个“人”类* $name : 对象中的成员属性，在此类中表示人的姓名* say() : 对象中的成员方法，在此类中表示人说话的方法* $this : PHP中的伪变量，表示自身的类* __construct() : php中的魔术方法，构造函数，在实例化类时自动执行* __destruct() : php中的魔术方法，析构函数，当类调用完成后自动执行*/class Human&#123; public $name; public $sex; public $age; public function __construct($name,$sex,$age) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; public function say() &#123; echo '大家好，我的名字叫'.$this-&gt;name.'，今年'.$this-&gt;age.'岁，我的性别是'.$this-&gt;sex; &#125; public function __destruct() &#123; $this-&gt;name = null; $this-&gt;sex = null; $this-&gt;age = null; &#125;&#125;//实例化“人”类$male = new Human("张三","男","20");//调用“人”类说话的方法$male-&gt;say(); //输出结果：大家好，我的名字叫张三，今年20岁，我的性别是男?&gt; 二、PHP面向对象高级编程实践知识点：类的继承、方法重写、访问控制、static关键字、final关键字、数据访问、接口、多态、抽象类 2.1、类的继承：extends 关键字例如：一员运行员、一位主持人，他们有人类共同的行为方法，但他们都有自己不同的特长专业。因此在编程时需要给他们创建一个父类并继承； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** 创建一个“人”类做为父类，继承的子类都拥有其父类的成员属性、方法*/class Human&#123; public $name; public function say() &#123; echo "父类说话的方法，姓名：".$this-&gt;name."\n"; &#125; public function eat() &#123; echo "父类吃饭的方法\n"; &#125;&#125;/** 创建一个“运动员”类，继承“人”类* extends : 关键字，继承某个类*/class Sport extends Human&#123; public $type; public function __construct($name,$type) &#123; $this-&gt;name = $name; //给父类 $name 属性赋值 $this-&gt;type = $type; &#125; public function run() &#123; $this-&gt;say(); //调用父类“说话”的方法 echo "我在正跑步，我是一员".$this-&gt;type."运动员.....\n"; &#125;&#125;/** 创建一个“主持人”类，继承“人”类* extends : 关键字，继承某个类*/class Host extends Human&#123; public $television; public function __construct($name,$television) &#123; $this-&gt;name = $name; $this-&gt;television= $television; &#125; public function perform() &#123; $this-&gt;eat(); //调用父类“吃饭”的方法 echo "我在正表演一个节目，我是".$this-&gt;television."电视台的一名主持人.....\n"; &#125;&#125; //实例化“运动员”类$nba = new Sport("乔丹","篮球");$nba-&gt;run(); //实例化“主持人”类$tv = new Host("张三","北京卫视");$tv-&gt;perform(); //输出结果：//父类说话的方法，姓名：乔丹 我在正跑步，我是一员篮球运动员..... //父类吃饭的方法 我在正表演一个节目，我是北京卫视电视台的一名主持人.....?&gt; 2.2、方法重写：子类重写父类的方法 1234567891011121314151617181920&lt;?phpclass Human&#123; public function say() &#123; echo "父类说话的方法"; &#125;&#125;class Sport extends Human&#123; //重写父类“说话”的方法 public function say() &#123; echo "子类说话的方法"; &#125;&#125;$nba = new Sport();$nba-&gt;say();//输出结果：子类说话的方法?&gt; 2.3、访问控制：public 、 protected 、private 关键字 public：定义公共的成员属性或方法，任何地方都可使用protected : 定义受保护的成员属性或方法，只允许类本身或子类使用private : 定义私有的成员属性或方法，只允许类的本身使用 123456789101112&lt;?phpclass Human&#123; public $name; protected $sex; private $age; &#125;//实例化对象，给公共属性赋值可正常输出结果，外部不能给protected、private受保护的成员属性赋值或使用$worker = new Human();$worker-&gt;name = "张三";echo $worker-&gt;name;?&gt; 2.4、static（静态）关键字1）、静态属性用于保存类的公有数据；2）、静态方法里面只能访问静态属性或方法，不能使用 $this 伪变量；3）、静态成员不需要通过 new 关键字来实例化对象就可访问使用； 123456789101112131415&lt;?phpclass Human&#123; static $name = "张三"; static function say() &#123; echo "我的姓名叫：".self::$name; &#125;&#125;//外部使用静态成员属性或方法echo Human::$name;Human::say(); //输出结果：张三 我的姓名叫：张三?&gt; 2.5、final关键字：不允许成员方法被重写，不允许被继承例：1、对于父类“吃饭”这个方法，不希望子类重写它；2、对于“运动员”这个类，不希望它再创建子类； 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Human&#123; final public function eat() &#123; echo "父类吃饭的方法，不允许子类重写"; &#125;&#125;final class Sport extends Human&#123; public function eat() &#123; echo "子类吃饭的方法。此时程序将会报致命错误"; &#125;&#125;//创建一个类继承 Sport 这个类。此时程序也将会报致命错误。因为 Sport 类不允许再创建子类class Student extends Sport&#123; public $name;&#125; //实例化 Sport 类 ，调用 eat() 方法$nba = new Sport();$nba-&gt;eat(); //实例化 Student 类 ，给 name 属性负值$obj = new Student();$obj-&gt;name = "张三"; //输出结果：Fatal error: Cannot override final method Human::eat() in ******.php on line 15//Fatal error: Class Student may not inherit from final class (Sport) in ****.php on line 20?&gt; 2.6、数据访问：$this 、 self 、parent 关键字$this ： 伪变量，代表类的本身，可访问本类及父类中的成员属性与方法。self ： 访问类中的静态成员属性或方法parent ：访问父类的成员属性或方法 1234567891011121314151617181920&lt;?phpclass Human&#123; static $name = "张三";&#125;class Sport extends Human&#123; static function getParentName() &#123; echo parent::$name; &#125; public function get() &#123; self::getParentName(); &#125;&#125;$obj = new Sport();$obj-&gt;get();//输出结果：张三?&gt; 2.7、接口：把不同类的共同行为方法进行定义，但不具体实现，由子类来实现具体的方法；例如：人会吃饭，动物也会吃饭，甚至有些植物也会吃饭，但他们吃饭的方式不一样，因此这时需要定义一个接口类，具体的方式由子类来实现；定义接口关键字：interface实现接口方法关键字：implements 123456789101112131415161718192021222324252627282930313233&lt;?php//定义一个接口类，有吃饭的方法，但不具体实现。interface ICanEat&#123; public function eat($food);&#125;class Human implements ICanEat&#123; //eat()方法必须由子类来实现，否则程序将报致命错误 public function eat($food) &#123; echo "I'm eating ".$food; &#125;&#125;class Animal implements ICanEat&#123; public function eat($food) &#123; echo "It's eating ".$food; &#125;&#125;//实例化一个“人”类$people = new Human();$people-&gt;eat('rice'); //实例化一个“动物”类$monkey = new Animal();$monkey-&gt;eat('banana'); //输出结果：I'm eating rice// It's eating banana ?&gt; 2.8、多态：比如接口A有两个实现B和C，B和C对A接口里面定义的方法实现可以是不同的，这种现象称之为多态；上述实例中，ICanEat接口定义了一个eat()方法，人类吃米饭，猴子吃香蕉。他们都实现了一个“吃”的方法，但他们吃东西有不同的行为，称之为多态； 2.9、抽象类：介入接口与类的定义之间，允许类里面一部分方法不实现，实现一部分有相同功能且不会更改的方法。然而接口类里面不允许有任何实现的方法。例如：人和动物都具有吃饭与呼吸的方法，除吃饭不同以外，呼吸方法是相同的，此时需要定义一个抽象类来实现。定义抽象类关键字：abstract 1234567891011121314151617181920212223&lt;?php//定义一个抽象类，里面有吃饭和呼吸的方法。呼吸方法需要在抽象类中具体实现abstract class ICanEat&#123; abstract function eat($food); public function breath() &#123; echo 'Breath use the air...'; &#125;&#125;class Human extends ICanEat&#123; public function eat($food) &#123; echo "I'm eating ".$food; $this-&gt;breath(); &#125;&#125;//实例化“人”类$people = new Human();$people-&gt;eat('rice');//输出结果:I'm eating rice Breath use the air...?&gt; 三、PHP面向对象编程特殊实践PHP语言特定的一些魔术方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Object&#123; public function __construct() &#123; echo "当类在被实例化的时候，自动执行该函数"; &#125; public function __toString() &#123; return "当对象被当作字符串形式输出时，自动执行该函数"; &#125; public function __invoke($value) &#123; echo "当对象被当作函数调用时，自动执行该函数".$value; &#125; /* * 当对象访问不存在的方法时，自动执行该函数。也称之为“方法重载” * $fun : 方法名称 * $param : 传递的参数 */ public function __call($fun,$param) &#123; echo "调用".$fun."方法不存在，传递的参数".implode(',',$param); &#125; /* * 当对象访问不存在的静态方法时，自动执行该函数。 * $fun : 方法名称 * $param : 传递的参数 */ static function __callStatic($fun,$param) &#123; echo "调用".$fun."静态方法不存在，传递的参数".implode(',',$param); &#125; public function __get($key) &#123; echo "当读取对象中不可访问（未定义）的属性值时，自动调用该函数。".$key."属性不可访问或未定义"; &#125; public function __set($key,$value) &#123; echo "当给对象中不可访问（未定义）的属性赋值时，自动调用该函数。".$key."属性不可访问或未定义，值".$value; &#125; public function __isset($key) &#123; echo "判断对象中的属性不存在时，自动执行该函数。属性：".$key."值未定义"; &#125; public function __unset($key) &#123; echo "释放对象中的不存在的属性值时，自动执行该函数。属性：".$key."值未定义"; &#125; public function __clone() &#123; echo "当对象被克隆时，自动执行该函数。"; &#125; public function __destruct() &#123; echo "当对象执行完成后，自动执行该函数"; &#125;&#125;$obj = new Object(); //实例化对象时，调用__construct()方法echo $obj; //将对象以字符串形式输出时，调用__toString()方法$obj(123); //当对象以函数形式调用时，执行__invoke()方法$obj-&gt;runTest(); //当调用对象中不存在的方法时，执行__call()方法$obj::runTest(); //当调用对象中不存在的静态方法时，执行__callStatic()方法$obj-&gt;name; //当调用对象中不存在的成员属性时，执行__get()方法$obj-&gt;name = "张三"; //当给对象中不存在的成员属性赋值时，执行__set()方法isset($obj-&gt;name) ? 1 : 0; //判断对象中不存在的成员属性时，执行__isset()方法unset($obj-&gt;name); //释放对象中的不存在的属性值时，执行__unset()方法$obj2 = clone $obj; //当对象被克隆时，执行__clone()方法 //对象执行完毕，执行__destruct()方法?&gt;]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用jQuery实现简单的图片轮播效果]]></title>
    <url>%2F2018%2F09%2F09%2F%E7%94%A8jQuery%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E6%95%88%E6%9E%9C%20%2F</url>
    <content type="text"><![CDATA[以下代码使用了jQuery来实现简单的图片轮播效果： html部分：12345678910111213141516171819202122&lt;div id="slider"&gt; &lt;ul class="slider_list"&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="4.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="5.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="6.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="7.jpeg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="8.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="slider_icon"&gt; &lt;i class="btn btn_act"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;i class="btn"&gt;&lt;/i&gt; &lt;/div&gt; &lt;a href="javascript:;" class="arrow left"&gt; &lt;span class="slider_left"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href="javascript:;" class="arrow right"&gt; &lt;span class="slider_right"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; css部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#slider&#123; width: 750px; height: 450px; margin: 10% auto; position: relative; border: 0px red solid &#125;#slider img&#123; width: 750px; height: 450px; &#125;li&#123; list-style: none; &#125;.slider_list li&#123; position: absolute; display: none; &#125;.slider_list li:first-child&#123; display: block; &#125;.arrow&#123; display: none; width:40px; height: 60px; background: rgba(0,0,0,.2); position: absolute; top: 50%; margin-top: -40px; &#125;.left&#123; left: 0px; &#125;.right&#123; right: 0px; &#125;.arrow span&#123; display: none; width: 15px; height: 15px; border-bottom: 2px solid #fff; border-left: 2px solid #fff; &#125;.slider_left&#123; margin-top:25px; margin-left: 15px; transform: rotate(45deg); &#125;.slider_right&#123; margin-top:25px; margin-left: 5px; transform: rotate(-135deg); &#125;.arrow:hover&#123;background: #444&#125;#slider:hover .arrow&#123;display:block;&#125;#slider:hover .arrow span&#123;display:block;&#125;.slider_icon&#123; width: 195px; height: 35px; background-color:hsla(0,0%,100%,.3); position: absolute; bottom: 0px; left: 50%; margin-left: -100px; border-radius: 30px; margin-bottom: 15px; z-index: 2; display: block; &#125;.slider_icon i&#123; display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 11px; margin-left: 11px; margin-top: 13px; &#125;.slider_icon:hover&#123;background-color:rgba(0,0,0,.4);&#125; .btn&#123; background: #fff; &#125;.btn_act&#123; background: #FCD705 &#125; js部分：12345678910111213141516171819202122232425var count=0;var $li=$(".slider_list&gt;li");var timer=setInterval("next()",4000); function next() &#123; count++; if (count==$li.length) &#123; count=0; &#125; $li.eq(count).fadeIn().siblings().fadeOut(); $(".slider_icon&gt;i").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); &#125; $(".right").click(function()&#123;next();&#125;); $(".left").click(function()&#123; count--; if (count == -1) &#123; count=$li.length-1; &#125; $li.eq(count).fadeIn().siblings().fadeOut(); $(".slider_icon&gt;i").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); &#125;) $(".slider_icon&gt;i").mouseenter(function()&#123; $(this).addClass('btn_act').siblings().removeClass('btn_act'); $li.eq($(this).index()).fadeIn().siblings().fadeOut(); count=$(this).index(); &#125;)]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题SEO优化]]></title>
    <url>%2F2018%2F07%2F29%2FHexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98SEO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[刚搭建完博客，发现自己发表的文章在谷歌或者百度都搜索不到，今天看了一些文章，原来是需要seo优化的，所以就来总结一下seo优化的方法，让自己的博文能在谷歌百度上搜索到。本文主要以谷歌搜索为主。 添加站点地图–安装sitemap站点地图自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save –修改站点配置文件将sitemap文件添加到站点配置文件_config.yml中，并修改url字段的值，其值默认为https://yoursite.com(你的博客域名）。 123456sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlurl: https://abner0101.github.io 配置好后，执行hexo g 就能在站点public\目录中生成sitemap.xml 和 baidusitemap.xml了;其中第一个是一会要提交给google的，后面那个看名字当然就是提交给Baidu的了； 添加蜘蛛协议在站点source文件夹下新建robots.txt文件，文件内容如下：（参考我的） 123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://abner0101.github.io/sitemap.xmlSitemap: https://abner0101.github.io/baidusitemap.xml 其中Allow后面的就是你的menu请自行将abner0101.github.io改成自己的域名，然后hexo d -g提交一下 提交站点到Google打开Google Search Console，根据提示注册好之后，添加你的博客域名。 站点验证我选择了备用方法中的HTML 标记，将给出的元标记复制到\themes\hexo-theme-next\layout_partials\head.swig文件中。添加后运行hexo d -g将改动提交。稍后就可以验证成功了。 123456&lt;meta charset="UTF-8"/&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/&gt;&lt;meta name="theme-color" content="&#123;&#123; theme.android_chrome_color &#125;&#125;"&gt;&lt;meta name="google-site-verification" content="xxxxxxxxxxxxx" /&gt;&lt;meta name="baidu-site-verification" content="xxxxxxxxx" /&gt; 测试robots.txt点击左侧的robots.txt测试工具，根据提示提交你的robots.txt，其实刚才我们已经提交了。 注意要0错误才可以，如果有错误的话，会有提示，改正确就可以了。 提交站点地图还记得我们刚才创建创建sitemap.xml文件吧,现在它要派上用场了。点击左侧工具栏的站点地图 Google 抓取方式提交站点地图之后，点击左侧的Google 抓取方式 这一步很重要！这一不很重要！这一步很重要！在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。提交完成后，提交至索引，根据提示操作就可以了。 网站结构自身优化出站链接添加nofollow标签网络爬虫会在当前页面搜索所有的链接，然后一个个查看，所以就很有可能跳到别的网站就不回来了。这个时候就需要nofollow起作用了。 nofollow标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 修改footer.swig文件路径在your-hexo-site\themes\next\layout_partials，将下面代码中的a标签加上rel=”external nofollow”属性。 1&#123;&#123; __('footer.powered', '&lt;a rel="external nofollow" class="theme-link" target="_blank" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 1&lt;a rel="external nofollow" class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next"&gt; 修改sidebar.swig文件路径在your-hexo-site\themes\next\layout_macro，将下面代码中的a标签加上rel=”external nofollow”属性 1&lt;a href="https://creativecommons.org/&#123;% if theme.creative_commons === 'zero' %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/" rel="external nofollow" class="cc-opacity" target="_blank"&gt; 1&lt;a href="&#123;&#123; link &#125;&#125;" title="&#123;&#123; name &#125;&#125;" rel="external nofollow" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 1&lt;a rel="external nofollow" href="&#123;&#123; link.split('||')[0] | trim &#125;&#125;" target="_blank" title="&#123;&#123; name &#125;&#125;"&gt; 至此，seo优化得差不多了，还有很多可以优化的地方，博主日后再更新。马上上google搜索一下你的关键词和博客title测试一下吧！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记Hexo + Github Pages博客搭建]]></title>
    <url>%2F2018%2F07%2F27%2F%E8%AE%B0Hexo%20%2B%20Github%20pages%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[很早之前就听说可以通过github pages来搭建博客，但是由于种种原因（就是懒），迟迟没有付诸行动，终于，趁着暑假，开始了我的hexo+github pages 搭建博客的踩坑记，折腾了两天，终于成功搭建好了博客，接下来，开始分享搭建本博客的过程中以及各种坑。。。 用Hexo + Gitpages的原因 不用配置服务器 不用数据库 访问速度相当快 没有安全性可言 使用户可更注重博客内容 支持markdown还有就是hexo相对来说轻巧一些，生成文章的速度也比较快（静态博客生成页面时都是要整站生成，所以，页面越多，速度就越慢） 从hexo开始首先本地得装上了node.js、git和hexo 安装git：git 安装nodejs：node.js官网 hexo：hexo官网 hexo使用npm安装（过程如下） 1234npm install hexo-cli -ghexo init blogcd bloghexo server 然后打开http://localhost:4000/就可以查看效果了。如果4000端口打不开，可以通过以下命令更改端口访问(改为3000） 1hexo s -p 3000 注：Hexo依赖Node.js和Git，需要先安装。hexo的使用可参详官网文档。 常用命令： 1234hexo g 生成静态博客，即重新生成public文件夹hexo s 本地预览调试 (一般组合使用 hexo g &amp;&amp; hexo s)hexo d (发布到github)hexo n (执行该命令之后在source/_posts目录下产生&lt; blog name &gt;.md文件，这是你的一篇新博客。可以在markdown工具下编写，markdown工具在网上搜有一大堆，比如本博主使用的csdn的markdown工具，具体怎么使用也可以自己百度啦~） 部署到Github在github上创建一个仓库，仓库必须命名为：你的github账号.github.io(例如我的账号为Abner0101，所以我的仓库名为：Abner0101.github.io) 配置hexo config.yml，修改Deployment 1234deploy: type: git repo: git@github.com:你的帐号/你的帐号.github.com.git branch: master 然后执行命令： 123hexo cleanhexo ghexo d 此时，在博客的根目录下会生成一个文件夹：.deploy 然后我们把这个文件夹里面的文件都push到刚才新建那个项目就OK了。几分钟过后，就可以打开：你的用户名.github.io 看到你的博客了。 绑定域名在项目的根目录，新建名为CNAME的文件，内容为：你的域名，例如我的就是：jdsheng.cn再到把你的域名指向你的用户名.github.io，几分钟过后，就可以看到成功的诞生了。 NexT主题与第三方服务我使用的主题是next，在你的博客根目录下gitbash，安装next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件(_config.yml)，增加一行： 1theme: next 进入themes/next，修改主题配置文件 _config.yml 定位到scheme参数来选择自己喜欢的主题风格： 1scheme: Mist 关于next主题更多的配置（添加评论，分享，喜欢，添加头像等功能）可以参考NexT使用文档 关于更换电脑，如何继续写博客1.将你原来的电脑上已经配置好的源代码项目拷贝到你新的电脑，注意，无需拷贝全部，只需要拷贝一下几个目录： 12345_config.ymlpackage.jsonscaffolds/source/themes/ 将这些目录放在一个目录下，例如：blog/ 2.在你的新电脑上配置hexo环境：安装git、安装node.js3.安装hexo，执行命令： 1npm install -g hexo 4.安装好之后，在hexo目录下gitbash，执行命令： 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 5.部署，执行命令： 12 hexo ghexo d 在执行第5步时，可能会出错，不知道你们会不会遇到，反正我是遇到了，在部署提交代码的时候出现了这个问题： 123456*** Please tell me who you are.Run git config --global user.email "you@example.com" git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository. 所以解决方法是当出现这个上述提示后 接着补充你在命令行中执行 12git config --global user.email "你的邮箱"git config --global user.name "你的名字" （注意 “ 前面是有空格的）输入后在接着执行hexo g、hexo d即可！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习记录]]></title>
    <url>%2F2018%2F07%2F27%2Fnode.js%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[–node.js入门]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
