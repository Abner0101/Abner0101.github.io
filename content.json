{"pages":[{"title":"about","text":"DAWSON","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"ES6的Set和Map数据结构","text":"最近在写业务代码的时候经常碰到数组或者对象去重问题，常用的方法当然就是遍历，然后，我自己搜了一下有没有更简洁的做法，发现了es6的Set和Map数据结构也可以用于去重，最主要的是省了好多代码。 那么Set和Map到底是何方神圣呢，刚开始看的时候越看越懵逼，因为我不明白实现这样的数据结构，目的是什么，意义又是什么呢？ Set和Map主要的应用场景在于数组去重和数据存储，幸运的是在读了关于数据结构和算法之类的书籍后，恍然大悟的发现 原来Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构 那么下面就跟随我一起去了解下这两种数据结构，最后来亲手实现的一个ES6中的Set和Map吧 集合 集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组 ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值 Set 本身是一个构造函数，用来生成 Set数据结构 这里说的Set其实就是我们所要讲到的集合，先来看下基础用法 1234567891011const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) { console.log(i); // 2 3 5 4}// 去除数组的重复成员let array = [1,2,1,4,5,3];[...new Set(array)] // [1, 2, 4, 5, 3] Set实例的属性和方法Set的属性： size：返回集合所包含元素的数量 Set的方法：操作方法—— add(value)：向集合添加一个新的项 delete(value)：从集合中移除一个值 has(value)：如果值在集合中存在，返回true,否则false clear(): 移除集合里所有的项 遍历方法—— keys()：返回一个包含集合中所有键的数组 values()：返回一个包含集合中所有值的数组 entries：返回一个包含集合中所有键值对的数组(感觉没什么用就不实现了) forEach()：用于对集合成员执行某种操作，没有返回值 Set完整实现在此，先给大家贴一下完整的实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function Set(arr = []) { let items = {}; this.size = 0; // has方法 this.has = function (val) { return items.hasOwnProperty(val); }; // add方法 this.add = function (val) { // 如果没有存在items里面就可以直接写入 if (!this.has(val)) { items[val] = val; this.size++; return true; } return false; }; arr.forEach((val, i) =&gt; { this.add(val); }); // delete方法 this.delete = function (val) { if (this.has(val)) { delete items[val]; // 将items对象上的属性删掉 this.size--; return true; } return false; }; // clear方法 this.clear = function () { items = {}; this.size = 0; }; // keys方法 this.keys = function () { return Object.keys(items); }; // values方法 this.values = function () { return Object.values(items); } // forEach方法 this.forEach = function (fn, context = this) { for (let i = 0; i &lt; this.size; i++) { let item = Object.keys(items)[i]; fn.call(context, item, item, items); } } // 并集 this.union = function (other) { let union = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) { union.add(values[i]); } values = other.values(); // 将values重新赋值为新的集合 for (let i = 0; i &lt; values.length; i++) { union.add(values[i]); } return union; }; // 交集 this.intersect = function (other) { let intersect = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) { if (other.has(values[i])) { intersect.add(values[i]); } } return intersect; }; // 差集 this.difference = function (other) { let difference = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) { if (!other.has(values[i])) { difference.add(values[i]); } } return difference; }; // 子集 this.subset = function(other) { if (this.size &gt; other.size) { return false; } else { let values = this.values(); for (let i = 0; i &lt; values.length; i++) { console.log(values[i]) console.log(other.values()) if (!other.has(values[i])) { return false; } } return true; } };}module.exports = Set; 写了辣么多一起来测试一下吧 1234567891011121314151617181920212223242526const Set = require('./Set.js');let set = new Set([2, 1, 3]);console.log(set.keys()); // [ '1', '2', '3' ]console.log(set.values()); // [ 1, 2, 3 ]console.log(set.size); // 3set.delete(1);console.log(set.values()); // [ 2, 3 ]set.clear();console.log(set.size); // 0// 并集let a = [1, 2, 3];let b = new Set([4, 3, 2]);let union = new Set(a).union(b).values();console.log(union); // [ 1, 2, 3, 4 ]// 交集let c = new Set([4, 3, 2]);let intersect = new Set([1,2,3]).intersect(c).values();console.log(intersect); // [ 2, 3 ]// 差集let d = new Set([4, 3, 2]);let difference = new Set([1,2,3]).difference(d).values();// [1,2,3]和[4,3,2]的差集是1console.log(difference); // [ 1 ] 字典在数据结构还有一种结构叫做字典，它就是实现基于ES6中的Map类的结构 那么集合又和字典有什么区别呢： 共同点：集合、字典可以存储不重复的值 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储 所以这一下让我们明白了，Map其实的主要用途也是用于存储数据的，相比于Object只提供“字符串—值”的对应，Map提供了“值—值”的对应。也就是说如果你需要“键值对”的数据结构，Map比Object更合适 下面来看一下基本使用： 12345678const m = new Map();const o = {p: 'Hello World'};m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 以上是Map的基本使用，还有更多有用的方法稍后会随着实现的深入分别展示 Map的属性和方法属性： size：返回字典所包含的元素个数 操作方法： set(key, val): 向字典中添加新元素 get(key):通过键值查找特定的数值并返回 has(key):如果键存在字典中返回true,否则false delete(key): 通过键值从字典中移除对应的数据 clear():将这个字典中的所有元素删除 遍历方法： keys():将字典中包含的所有键名以数组形式返回 values():将字典中包含的所有数值以数组形式返回 forEach()：遍历字典的所有成员 Map完整实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function Map() { let items = {}; this.size = 0; // 操作方法 // has方法 this.has = function(val) { return items.hasOwnProperty(val); }; // set(key, val)方法 this.set = function(key, val) { items[key] = val; this.size++; }; // get(key)方法 this.get = function(key) { return this.has(key) ? items[key] : undefined; }; // delete(key)方法 this.delete = function(key) { if (this.has(key)) { delete items[key]; this.size--; return true; } return false; }; // clear()方法 this.clear = function() { items = {}; this.size = 0; }; // 遍历方法 // keys()方法 this.keys = function() { return Object.keys(items); }; // values()方法 this.values = function() { return Object.values(items); }; // forEach(fn, context)方法 this.forEach = function(fn, context = this) { for (let i = 0; i &lt; this.size; i++) { let key = Object.keys(items)[i]; let value = Object.values(items)[i]; fn.call(context, value, key, items); } };}module.exports = Map; 再来看看下面的测试： 123456789101112131415// map.js // 使用Map类 const Map = require('./Map.js'); let m = new Map(); m.set('Jay', 'Jay的Chou'); m.set(true, '真的'); console.log(m.has('Chou')); // false console.log(m.size); // 2 console.log(m.keys()); // [ 'Jay', 'true' ] console.log(m.values()); // [ 'Jay的Chou', '真的' ] console.log(m.get('jay')); // undefined m.delete(true); console.log(m.keys()); // [ 'Jay' ] console.log(m.values()); // [ 'Jay的Chou' ]","link":"/2020/06/06/ES6的Set和Map数据结构/"},{"title":"Echarts 图表填（天）坑篇","text":"1.echarts 图表大小随窗口变动而自适应变动（无需刷新浏览器调整）问题： 这是做过echarts图表的同学大部分都会遇到的坑，在应用echarts进行统计图制作时候会遇到这样的问题，进入渲染页面统计图比例显示ok，但是当主动调整浏览器大小时候，统计图比例并没有随窗口大小改变而自动调整到最佳视觉效果，比如下图，缩小窗口就会出现溢出的情况。 原因分析： echarts的图表实例事实上并没有主动的去绑定resize()事件，就是说显示区域大小发生改变内部并不知道，当你需要去做一些自适应的效果的时候，需要使用方主动的去绑定这个事件达到自适应的效果，常见如window.onresize = myChart.resize。 填坑： 12345678910111213141516171819202122232425262728var myChart = echarts.init(document.getElementById('main'));// 指定图表的配置项和数据var option = { title: { text: 'ECharts 入门示例' }, tooltip: {}, legend: { data:['销量'] }, xAxis: { data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }]};// 使用刚指定的配置项和数据显示图表。myChart.setOption(option);//根据窗口的大小变动图表 --- 重点window.onresize = function(){ myChart.resize(); //myChart1.resize(); //若有多个图表变动，可多写} 2.解决Vue+Echarts的内存泄漏问题问题： 当页面存在echarts图表的时候，跳转路由到其他页面，然后来回切换的时候，打开浏览器调试工具，会发现页面占用内存持续增加，如下图所示：前几次切换页面可以正常生成图表，但是当切换多次以后，页面会出现空白或浏览器奔溃的情况，页面也不会报错并且无明显提示。很明显是发生了内存泄漏问题。 原因分析： 先说一个知识点： js中的内存垃圾回收机制：垃圾回收器会定期扫描内存，当某个内存中的值被引用为零时就会将其回收。当前变量已经使用完毕但依然被引用，导致垃圾回收器无法回收这就造成了内存泄漏。传统页面每次跳转都会释放内存，所以并不是特别明显。Web App 与 传统Web的区别，因为Web App是单页面应用页面通过路由跳转不会刷新页面，导致内存泄漏不断堆积，导致页面卡顿。 原因就是echarts图表初始化时引用了DOM对象，js不回对此自动回收，切换生成echarts时需要用到一部分内存，重复切换页面，之前生成的图表内存并没有进行清空，因此一直切换内存也一直叠加，最终导致内存溢出。 填坑： 1.在生成echarts之前进行判断，dom不存在时就不初始化echarts 2.去掉重复初始化echarts，这个主要就是在不需要使用时销毁实例。那么很自然想到官方API，查阅echarts官方API果然发现有这个方法： 代码示例： （1）页面容器： 12345&lt;template&gt; &lt;div class=\"chart-main\"&gt; &lt;div ref=\"dom\" :style=\"chartStyle\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; （2）初始化echarts方法： 1234567891011121314initChart() { //-dom 不存在时不画 if (!this.$refs.dom) { return } //去掉重复初始化 this.myChart = echarts.getInstanceByDom(this.$refs.dom); if(!this.myChart){ this.myChart = echarts.init(this.$refs.dom); this.$once('hook:beforeDestroy', function () { echarts.dispose(this.myChart) }) } } 没修改之前的代码： 123initChart() { this.myChart = echarts.init(this.$refs.dom);}","link":"/2020/06/06/Echarts 图表填（天）坑篇/"},{"title":"Git 基本知识与常用指令","text":"一、Git代码状态转换图其中： 未被Git跟踪的状态为unstage状态； 已被Git跟踪的状态为stage状态（stage：阶段），因此包括staging状态和staged状态。 untrack files：是指尚未被git所管理的文件； changed but not updated：是指文件被git管理，并且发生了改变，但改动还没被git管理；这两种状态，都可以看成是改动还没被git管理的状态，我们这里称unstage状态。 staging是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。 changes to be commited是指进入staged状态的文件。 .gitignore中的文件，不会出现在以上三个状态中。 注： 这个图也解释了为啥从远端库拉代码，不需要add、commit。 代码一旦修改，就会成为未被git库跟踪的状态。需要add、commit。 二、大白话Git Git 管理代码，保证代码版本迭代连续性，即：向A分支merge或者push代码时，A分支代码必须是当前代码的上一个版本，不然会产生冲突。（换句话说：Git确保当前的本地的代码为最新） Git有修改就有提交，就有新的代码版本，git管理维护的是修改。 Git分支存储的是代码副本。 push ：实际上就是将本地分支合并到远端库分支；pull：实际就是将远端分支合并到本地分支。 三、Git本地常用操作指令 1、创建git库 git init #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库） 2、注册git用户 —&gt;用于在团队合作开发中，表明代码作者。 12345git config --global user.name XXX #用户名git config --global user.email XXX #用户邮箱git config --list #查看用户信息 注：加–global，全局设置。 3、向git库添加修改 git add [path］ #会把对应目录或文件，添加到stage状态git add . #会把当前所有的untrack files和changed but not updated添加到stage状态 实际上是为修改内容添加index索引。 4、向版本库提交修改 git commit –m “XXXX” #提交修改,添加注释 注：git 提示： 未有add红色字体，未有commit绿色字体，已提交则worktree是干净的 5、查看当前代码库的状态 1git status 6、查看版本信息 —&gt;实际是查看修改提交信息 1git log git log --graph #以图形化（节点）展示当前git库的提交信息。 7、查看指定版本信息 git show sdjf974654dd…. #(show后面为每次提交系统自动生成的一串哈希值) git show sdji97 #一般只使用版本号的前几个字符即可 8、撤销修改 1git reset （1）撤销整体修改 git reset --hard #回到原来编辑的地方,改动会丢失。（同样适用于团队对于其他人的修改恢复）git reset --hard sdv143kvf…... #可回到指定的版本#(hard后面为每次提交系统自动生成的一串哈希值)git reset [path] 会改变path指定的文件或目录的stage状态，到非stage状态。git reset 会将所有stage的文件状态，都改变成非stage状态。 （2）撤销某次修改 回退1个change的写法就是git reset HEAD^，2个为HEAD^^，3个为HEAD~3，以此类推。 9、向远端库推送修改（提交修改） git push origin 分支名 10、暂存修改 git stash可以把当前的改动（stage和unstage，但不包括untrack的文件）暂存。 然后通过git stash list查看。 并通过git stash apply重新取出来。但apply之前要保证worktree是干净的。 四、Git团队开发常用操作指令1、获取远端库项目 1git clone/pull 2、团队开发的基本流程（多分支合并一个分支） git add . #添加改动的文件git commit #（提交至本地）git pull --rebase #（将服务器项目与本地项目合并）git push #（将本地项目上传至远端库）（在提交前要git pull –rebase 一下，确保当前的本地的代码为最新。） 五、Git 分支管理1、建立分支 git branch AAA #建立分支AAA 2、分支切换 git checkout AAA #从当前分支切换到AAA分支 (若AAA分支不存在，则自动新建) 3、将分支与主枝master合并 git checkout master #（首先切换回主枝）git merge AAA #（将分支AAA与主枝合并） 注：git merge：默认情况下，Git执行”快进式合并”（fast-farwardmerge），会直接将Master分支指向Develop分支。 使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰（保持提交曲线为直线），建议采用这种方法。 4、当前分支查看 git branch #默认有master（也称为主枝）git branch -r #查看远端库分支git branch –a #查看当前所有分支（包括本地分支和远端库分支） 5、删除分支 git branch –d AAA #删除分支AAA 6、切下远端库A分支到本地库A分支 git checkout -b A origin/A （若本地A分支不存在，则自动新建） 注：上面只是一些基本的操作命令，更多的命令可通过帮助文档查询。 帮助文档的使用：man git-&lt;需查询的指令&gt; #（git后面有“-”）如commit的查询为 man git-commit 六、本地代码上传Github Gtthub上建立远端仓库，复制下载链接。 本地指定目录下，Gitbash粘贴远端仓库下载链接拉取远端仓库代码 复制本地需要提交的代码到远端仓库目录。 Git add、commit、push 提交本地代码至Github远端仓库。","link":"/2020/06/06/Git 基本知识与常用指令/"},{"title":"Hexo博客NexT主题SEO优化","text":"刚搭建完博客，发现自己发表的文章在谷歌或者百度都搜索不到，今天看了一些文章，原来是需要seo优化的，所以就来总结一下seo优化的方法，让自己的博文能在谷歌百度上搜索到。本文主要以谷歌搜索为主。 添加站点地图–安装sitemap站点地图自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save –修改站点配置文件将sitemap文件添加到站点配置文件_config.yml中，并修改url字段的值，其值默认为https://yoursite.com(你的博客域名）。 123456sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlurl: https://abner0101.github.io 配置好后，执行hexo g 就能在站点public\\目录中生成sitemap.xml 和 baidusitemap.xml了;其中第一个是一会要提交给google的，后面那个看名字当然就是提交给Baidu的了； 添加蜘蛛协议在站点source文件夹下新建robots.txt文件，文件内容如下：（参考我的） 123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://abner0101.github.io/sitemap.xmlSitemap: https://abner0101.github.io/baidusitemap.xml 其中Allow后面的就是你的menu请自行将abner0101.github.io改成自己的域名，然后hexo d -g提交一下 提交站点到Google打开Google Search Console，根据提示注册好之后，添加你的博客域名。 站点验证我选择了备用方法中的HTML 标记，将给出的元标记复制到\\themes\\hexo-theme-next\\layout_partials\\head.swig文件中。添加后运行hexo d -g将改动提交。稍后就可以验证成功了。 123456&lt;meta charset=\"UTF-8\"/&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"/&gt;&lt;meta name=\"theme-color\" content=\"{{ theme.android_chrome_color }}\"&gt;&lt;meta name=\"google-site-verification\" content=\"xxxxxxxxxxxxx\" /&gt;&lt;meta name=\"baidu-site-verification\" content=\"xxxxxxxxx\" /&gt; 测试robots.txt点击左侧的robots.txt测试工具，根据提示提交你的robots.txt，其实刚才我们已经提交了。 注意要0错误才可以，如果有错误的话，会有提示，改正确就可以了。 提交站点地图还记得我们刚才创建创建sitemap.xml文件吧,现在它要派上用场了。点击左侧工具栏的站点地图 Google 抓取方式提交站点地图之后，点击左侧的Google 抓取方式 这一步很重要！这一不很重要！这一步很重要！在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。提交完成后，提交至索引，根据提示操作就可以了。 网站结构自身优化出站链接添加nofollow标签网络爬虫会在当前页面搜索所有的链接，然后一个个查看，所以就很有可能跳到别的网站就不回来了。这个时候就需要nofollow起作用了。 nofollow标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 修改footer.swig文件路径在your-hexo-site\\themes\\next\\layout_partials，将下面代码中的a标签加上rel=”external nofollow”属性。 1{{ __('footer.powered', '&lt;a rel=\"external nofollow\" class=\"theme-link\" target=\"_blank\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') }} 1&lt;a rel=\"external nofollow\" class=\"theme-link\" target=\"_blank\" href=\"https://github.com/iissnan/hexo-theme-next\"&gt; 修改sidebar.swig文件路径在your-hexo-site\\themes\\next\\layout_macro，将下面代码中的a标签加上rel=”external nofollow”属性 1&lt;a href=\"https://creativecommons.org/{% if theme.creative_commons === 'zero' %}publicdomain/zero/1.0{% else %}licenses/{{ theme.creative_commons }}/4.0{% endif %}/\" rel=\"external nofollow\" class=\"cc-opacity\" target=\"_blank\"&gt; 1&lt;a href=\"{{ link }}\" title=\"{{ name }}\" rel=\"external nofollow\" target=\"_blank\"&gt;{{ name }}&lt;/a&gt; 1&lt;a rel=\"external nofollow\" href=\"{{ link.split('||')[0] | trim }}\" target=\"_blank\" title=\"{{ name }}\"&gt; 至此，seo优化得差不多了，还有很多可以优化的地方，博主日后再更新。马上上google搜索一下你的关键词和博客title测试一下吧！","link":"/2020/06/06/Hexo博客NexT主题SEO优化/"},{"title":"JS内存管理机制？","text":"前言像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。 内存生命周期JS 环境中分配的内存有如下声明周期： 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存 JS 的内存分配 为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。 12345678910111213141516171819var n = 123; // 给数值变量分配内存var s = \"azerty\"; // 给字符串分配内存 var o = { a: 1, b: null}; // 给对象及其包含的值分配内存 // 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, \"abra\"]; function f(a){ return a + 2;} // 给函数（可调用的对象）分配内存 // 函数表达式也能分配一个对象someElement.addEventListener('click', function(){ someElement.style.backgroundColor = 'blue';}, false); 有些函数调用结果是分配对象内存： 12var d = new Date(); // 分配一个 Date 对象var e = document.createElement('div'); // 分配一个 DOM 元素 有些方法分配新变量或者新对象： 12345678910var s = \"azerty\";var s2 = s.substr(0, 3); // s2 是一个新的字符串// 因为字符串是不变量，// JavaScript 可能决定不分配内存，// 只是存储了 [0-3] 的范围。 var a = [\"ouais ouais\", \"nan nan\"];var a2 = [\"generation\", \"nan nan\"];var a3 = a.concat(a2);// 新数组有四个元素，是 a 连接 a2 的结果 JS 的内存使用使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 12var a = 10; // 分配内存console.log(a); // 对内存的使用 JS 的内存回收 JS 有自动垃圾回收机制，那么这个自动垃圾回收机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。 大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到不再需要使用的变量。 不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在， 当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。 因为自动垃圾回收机制的存在，开发人员可以不关心也不注意内存释放的有关问题，但对无用内存的释放这件事是客观存在的。不幸的是，即使不考虑垃圾回收对性能的影响，目前最新的垃圾回收算法，也无法智能回收所有的极端情况。 接下来我们来探究一下 JS 垃圾回收的机制。 垃圾回收 垃圾回收算法主要依赖于引用的概念。 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。 例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 引用计数垃圾收集 这是最初级的垃圾回收算法。 引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。 12345678910111213141516171819202122var o = { a: { b:2 }};// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集 var o2 = o; // o2变量是第二个对“这个对象”的引用 o = 1; // 现在，“这个对象”的原始引用o被o2替换了 var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oa o2 = \"yo\"; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收 oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。 如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露。 来看一个循环引用的例子： 12345678910function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o 这里 return \"azerty\";} f(); 上面我们申明了一个函数 f ，其中包含两个相互引用的对象。在调用函数结束后，对象 o1 和 o2 实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了。 再来看一个实际的例子： 1234var div = document.createElement(\"div\");div.onclick = function() { console.log(\"click\");}; 上面这种JS写法再普通不过了，创建一个DOM元素并绑定一个点击事件。此时变量 div 有事件处理函数的引用，同时事件处理函数也有div的引用！（div变量可在函数内被访问）。一个循序引用出现了，按上面所讲的算法，该部分内存无可避免的泄露了。 为了解决循环引用造成的问题，现代浏览器通过使用标记清除算法来实现垃圾回收。 标记清除算法标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。但反之未必成立。 工作流程： 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。 从根部出发将能触及到的对象的标记清除。 那些还存在标记的变量被视为准备删除的变量。 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间 循环引用不再是问题了 再看之前循环引用的例子： 12345678910function f(){ var o = {}; var o2 = {}; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return \"azerty\";} f(); 函数调用返回之后，两个循环引用的对象在垃圾收集时从全局对象出发无法再获取他们的引用。因此，他们将会被垃圾回收器回收。 内存泄漏什么是内存泄漏 程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 本质上讲,内存泄漏就是由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。 内存泄漏的识别方法 经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存的占用情况。 在 Chrome 浏览器中，我们可以这样查看内存占用情况 打开开发者工具，选择 Performance 面板 在顶部勾选 Memory 点击左上角的 record 按钮 在页面上进行各种操作，模拟用户的使用情况 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况 我们有两种方式来判定当前是否有内存泄漏： 多次快照后，比较每次快照中内存的占用情况，如果呈上升趋势，那么可以认为存在内存泄漏 某次快照后，看当前内存占用的趋势图，如果走势不平稳，呈上升趋势，那么可以认为存在内存泄漏 在服务器环境中使用 Node 提供的 process.memoryUsage 方法查看内存情况 1234567console.log(process.memoryUsage());// {// rss: 27709440,// heapTotal: 5685248,// heapUsed: 3449392,// external: 8772// } process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。 该对象包含四个字段，单位是字节，含义如下: rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：”堆”占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external：V8 引擎内部的 C++ 对象占用的内存。 判断内存泄漏，以heapUsed字段为准。 常见的内存泄露案例 意外的全局变量 12345function foo() { bar1 = 'some text'; // 没有声明变量 实际上是全局变量 =&gt; window.bar1 this.bar2 = 'some text' // 全局变量 =&gt; window.bar2}foo(); 在这个例子中，意外的创建了两个全局变量 bar1 和 bar2 被遗忘的定时器和回调函数 在很多库中, 如果使用了观察者模式, 都会提供回调方法, 来调用一些回调函数。要记得回收这些回调函数。举一个 setInterval的例子： 1234567var serverData = loadData();setInterval(function() { var renderer = document.getElementById('renderer'); if(renderer) { renderer.innerHTML = JSON.stringify(serverData); }}, 5000); // 每 5 秒调用一次 如果后续 renderer 元素被移除，整个定时器实际上没有任何作用。但如果你没有回收定时器，整个定时器依然有效, 不但定时器无法被内存回收， 定时器函数中的依赖也无法回收。在这个案例中的 serverData 也无法被回收。 闭包 在 JS 开发中，我们会经常用到闭包，一个内部函数，有权访问包含其的外部函数中的变量。下面这种情况下，闭包也会造成内存泄露: 123456789101112131415var theThing = null;var replaceThing = function () { var originalThing = theThing; var unused = function () { if (originalThing) // 对于 'originalThing'的引用 console.log(\"hi\"); }; theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log(\"message\"); } };};setInterval(replaceThing, 1000); 这段代码，每次调用 replaceThing 时，theThing 获得了包含一个巨大的数组和一个对于新闭包 someMethod 的对象。同时 unused 是一个引用了 originalThing 的闭包。 这个范例的关键在于，闭包之间是共享作用域的，尽管 unused 可能一直没有被调用，但是 someMethod 可能会被调用，就会导致无法对其内存进行回收。当这段代码被反复执行时，内存会持续增长。 DOM 引用很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中。 12345678910var elements = { image: document.getElementById('image')};function doStuff() { elements.image.src = 'http://example.com/image_name.png';}function removeImage() { document.body.removeChild(document.getElementById('image')); // 这个时候我们对于 #image 仍然有一个引用, Image 元素, 仍然无法被内存回收.} 上述案例中，即使我们对于 image 元素进行了移除，但是仍然有对 image 元素的引用，依然无法对齐进行内存回收。 另外需要注意的一个点是，对于一个 Dom 树的叶子节点的引用。举个例子: 如果我们引用了一个表格中的td元素，一旦在 Dom 中删除了整个表格，我们直观的觉得内存回收应该回收除了被引用的 td 外的其他元素。但是事实上，这个 td 元素是整个表格的一个子元素，并保留对于其父元素的引用。这就会导致对于整个表格，都无法进行内存回收。所以我们要小心处理对于 Dom 元素的引用。 如何避免内存泄漏记住一个原则：不用的东西，及时归还。 减少不必要的全局变量，使用严格模式避免意外创建全局变量。 在你使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）。 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。","link":"/2020/06/06/JS内存管理机制/"},{"title":"JS变量的创建机制？","text":"JS怎么创建变量？ 12var a;function b(){} 那么它们具体存储在哪里，又怎么运行？ 这次，就聊聊JS的堆栈内存和变量的创建机制。 1.堆栈内存在了解变量创建机制之前，先来了解一下变量的存储空间。 存储空间分为栈内存和堆内存。 栈内存：作用域 提供一个供 JS 代码自上而下执行的环境（代码都是在栈内存中执行的） 存储基本类型值。由于基本类型比较简单，它们都是直接在栈内存中开辟一个位置，直接把值存储进去的 堆内存：引用值对应的空间 对象：键值对 函数：代码字符串 由于引用类型的值可能过于复杂，所以需要另外开辟空间来存储，而变量中存储的只是指向这个空间的地址。 2. 变量的创建（1）创建作用域当浏览器（内核/引擎）渲染和解析 JS 代码的时候，会提供一个供 JS 代码运行的环境，这个环境称为“全局作用域”（global / window scope），是一个栈内存 （2）进行变量提升将在作用域中使用 var / function 声明的变量进行提升。其中 var 声明的变量只提升声明，不定义 function 声明的变量，既提升声明，也提升定义 （3）代码自上而下执行 基本数据类型的值会存储在当前作用域下，以 var a = 12 为例 首先在当前作用域中声明一个变量 a（这一步会在变量提升阶段完成，执行时会忽略这个声明） 然后开辟一个空间存储值 12 最后让声明的变量与存储的值进行关联（就是赋值操作，也叫做定义） 基本数据类型（也叫做值类型），是按照值来操作的：把原有的值赋值一份放到新的空间或者位置上，和原来的值没有关系 引用数据类型的值，我们需要开辟一个新的空间（理解为仓库），把内容存储到这个空间中 首先声明一个变量（同样，这一步是在变量提升阶段完成，执行时会忽略这个声明） 然后开辟一个新的内存空间，把对象中的键值对依次存储起来（此空间有个 16 进制的地址） 让变量与空间地址关联起来（把空间地址赋值给变量） 123456var obj = { n: 10, m: obj.n * 10 //=&gt; Uncaught TypeError: Cannot read property 'n' of undefined};console.log(obj.m); 原因分析 1.形成一个全局作用域（栈内存）2.代码自上而下执行 首先开辟一个新的堆内存，把键值对存储到对内存中 n: 10, m: obj.n * 10 此时堆内存信息还没有存储完成，空间地址还没有与变量 obj 关联，此时的 obj 是 undefined，obj.n &lt;=&gt; undefined.n，所以报错 12345var obj = { n: 10};obj.m = obj.n * 10; // 此时的 obj 已经有值了console.log(obj.m); //=&gt; 100 引用类型不是按照值来操作，它操作的是空间的地址：把原有空间地址赋值给新的变量，但是原来的空间没有被克隆，还是同一个空间，这样就会出现多个变量关联的是相同的空间，相互之间就会存在影响。 1234567var arr1 = [3, 4];var arr2 = arr1;arr2[0] = 1;arr2 = [4, 5];arr2[1] = 2;arr1[1] = 0;console.log(arr1, arr2); //=&gt; 1, 0, 4, 2 原因分析： 数组也是对象，属于引用类型，会开辟一个新的堆内存保存 [3,4] 往下，arr2 = arr1，此时两个变量同时保存一个堆内存的地址 改变 arr2 会反映到 arr1，此时 arr1: [1,4] arr2: [1,4] 新开辟一个堆内存，保存 [4,5]，然后再把地址赋值给 arr2 此时两个变量关联的内存不再一样，对其的操作不再相互影响，此时 arr1: [1,4] arr2:[4,5] 再次赋值后，arr1: [1,0] arr2: [4,2]","link":"/2020/06/06/JS变量的创建机制/"},{"title":"Java函数式编程入门","text":"Lambda表达式Lambda 表达式介绍 是没有声明的方法，也即没有访问修饰符、返回值声明和名字。 一般使用场景 当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效。 Lambda 表达式语法 当方法没有形参的时候，使用 () 表示 1() -&gt; log.info(\"hehe\"); 当方法只有一个形参的时候，可以直接省略括号 1p -&gt; log.info(\"number : {}\",p); 当方法有多个参数时，需要使用 () 括起来 1(a,b) -&gt; return a + b; 参数可以省略类型，也可以写上 12345(a,b) -&gt; return a + b;//等同于(int a ,int b) -&gt; return a + b; 通过两个例子初步体验 Lambda 创建一个线程 1234567891011// 原写法// new Thread(new Runnable() {// @Override// public void run() {// log.info(\"hello lambda\");// }// }).start(); // 使用 lambda 表达式创建一个线程 Thread thread = new Thread(() -&gt; log.info(\"hello lambda\")); thread.start(); 实现 List 排序 123456789101112 List&lt;String&gt; list = Arrays.asList(new String[]{\"y\",\"z\",\"x\"}); // 原写法// Collections.sort(list, new Comparator&lt;String&gt;() {// @Override// public int compare(String o1, String o2) {// return o1.compareTo(o2);// }// }); // 使用 lambda 表达式 完成排序 Collections.sort(list,(o1,o2) -&gt; o1.compareTo(o2)); 深入解析 Lambda Lambda 本身是语法糖，起的作用是重写函数式接口(只包含一个抽象方法声明的接口) 的抽象方法，Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface 注解以便能用在lambda上。 123// new Runnable 只有 run 一个抽象方法，这里是 Lambda 的语法糖效果，自动重写了这个抽象方法Thread thread = new Thread(() -&gt; log.info(\"hello lambda\"));thread.start(); 通过一个自定义函数式接口来理解 Lambda 使用 @FunctionalInterface 来声明一个接口是函数式接口，该注解只能标记在”有且仅有一个抽象方法”的接口上，但它不是必须的，只是为了编译器更好地检测 1234567//函数式接口@FunctionalInterfacepublic interface LambdaInterface { // 一个求和抽象方法，当然后面重写可以自定义，不一定是求和 public Integer sum(int a ,int b);} 一个调用这个函数式接口的类 123456789101112131415161718192021import com.zyy.consumer.bean.User;import lombok.Data;import java.util.List;import java.util.function.Consumer;import java.util.function.Predicate;// lombok 中 @Data ，自动填充 setter 和 getter@Datapublic class FirstLambda { private Integer first; private Integer second; public Integer getSum(LambdaInterface lambdaInterface){ return lambdaInterface.sum(first,second); }} 开始表演 1234567891011121314151617181920 @Test public void testLambdaInterface() { Integer c = 0; FirstLambda firstLambda = new FirstLambda(); firstLambda.setFirst(22); firstLambda.setSecond(33); // 原生态操作// c = firstLambda.getSum(new LambdaInterface() {// @Override// public Integer sum(int a, int b) {// return a + b;// }// }); // 这个时候我们可以使用箭头函数去重写 sum 的实现 c = firstLambda.getSum((a,b) -&gt; {return a + b;}); log.info(\"number : {}\",c); } java.util.function 包使用场景 由于这个包都是 函数式接口，和 Lambda 搭配使用效果更佳 拥有的方法参考：https://blog.csdn.net/huo065000/article/details/78964382 name type description Consumer Consumer&lt; T &gt; 接收T对象，不返回值 Predicate Predicate&lt; T &gt; 接收T对象并返回boolean Function Function&lt; T, R &gt; 接收T对象，返回R对象 Supplier Supplier&lt; T &gt; 提供T对象（例如工厂），不接收值 UnaryOperator UnaryOperator&lt; T &gt; 接收T对象，返回T对象 BiConsumer BiConsumer&lt;T, U&gt; 接收T对象和U对象，不返回值 BiPredicate BiPredicate&lt;T, U&gt; 接收T对象和U对象，返回boolean BiFunction BiFunction&lt;T, U, R&gt; 接收T对象和U对象，返回R对象 BinaryOperator BinaryOperator&lt; T &gt; 接收两个T对象，返回T对象 ### 具体操作 Predicate 用于实现一个条件语句，而 Consumer 用于实现操作,不返回值，两者往往搭配使用 1234567891011121314151617181920212223242526272829import com.zyy.consumer.bean.User;import lombok.Data;import java.util.List;import java.util.function.Consumer;import java.util.function.Predicate;@Datapublic class FirstLambda { private Integer first; private Integer second; public Integer getSum(LambdaInterface lambdaInterface){ return lambdaInterface.sum(first,second); } // 写一个 筛选list 的方法 public void checkNumberBigger(List&lt;Integer&gt; list,Predicate&lt;Integer&gt; predicate,Consumer&lt;Integer&gt; consumer){ for(Integer integer : list){ if(predicate.test(integer)){ consumer.accept(integer); } } }} 调用该方法 123456789101112131415161718192021222324 @Test public void testLambdaPredicate(){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; 10;i++){ list.add(i); } // 这里重写了 Predicate 的test 方法，以完成逻辑的判断，重写了 Consumer 的 accept 方法，完成处理操作 new FirstLambda().checkNumberBigger(list, p -&gt; p &gt; 5, p -&gt; log.info(\"number : {}\",p)); }// 此时 Predicate boolean test(Integer p){ return p &gt; 5 ? true : false;}// 此时 Consumervoid accept(Integer p){ log.info(\"number : {}\",p))} Function&lt;R,T&gt; 类似一个一元函数，通过输入一个 R 类型的参数，通过处理以后 返回 T 类型的返回值，这里的使用例子是通过输入的字符串 返回 该字符串的长度 1234567891011121314// 之前 FirstLambda 中新的方法public Integer getStringLength(String string,Function&lt;String,Integer&gt; function){ return function.apply(string);}// 测试该方法 @Testpublic void testFunction(){ FirstLambda firstLambda = new FirstLambda(); Integer length = firstLambda.getStringLength(\"Hello World\", p -&gt; {return p.length();}); log.info(\"length : {}\",length);} Function 中 compose 可以结合两个函数，以下是它的源码 12345// 可以看出，它是依赖于apply类的，所以这不是一个抽象方法，不影响函数式接口的定义，本质是执行完before 方法以后，继续执行this.apply，从而实现两个函数结合使用 default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } 实例就采用先进行字符串处理，在计算字符串大小 12345678910111213141516// 之前 FirstLambda 中新的方法 public Integer getStringLengthSecond(String string,Function&lt;String,String&gt; before,Function&lt;String,Integer&gt; function){ return function.compose((Function&lt;? super String, ? extends String&gt;) before).apply(string); }// 测试该方法 @Test public void testFunctionCompose(){ FirstLambda firstLambda = new FirstLambda(); Integer length = firstLambda.getStringLengthSecond(\"Hello\", p -&gt; {return p + \" World\";}, p -&gt; {return p.length();}); log.info(\"length : {}\",length); } Function 中 的 andThen 方法则是先执行 this 方法，再去执行 after 方法，也是结合两个Function 1234default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t));} 测试例子是先求字符串的和，再将长度加上100 1234567891011121314151617// 之前 FirstLambda 中新的方法public Integer getStringLengthThird(String string,Function&lt;Integer,Integer&gt; after,Function&lt;String,Integer&gt; function){ return function.andThen(after).apply(string);}// 测试该方法@Testpublic void testFunctionAndThen(){ FirstLambda firstLambda = new FirstLambda(); Integer length = firstLambda.getStringLengthThird(\"Hello World\", p -&gt; {return p + 100;}, p -&gt; {return p.length();}); log.info(\"length : {}\",length);} Supplier 不接受参数，表示一个工厂类，实现工厂的作用,下面是调用User的静态方法返回实例 12345678910111213141516171819// User 类import lombok.Data;@Datapublic class User { private String name; private Integer age; private Double weight; private String sexy; private Double height; public static User getSimpleUser(){ User user = new User(); user.setName(\"simple\"); user.setSexy(\"male\"); user.setAge(21); return user; }} 1234567891011121314// 之前 FirstLambda 中新的方法public User getUser(Supplier&lt;User&gt; supplier){ return supplier.get();}// 测试该方法 @Testpublic void testSupplier(){ FirstLambda firstLambda = new FirstLambda(); User user = firstLambda.getUser(() -&gt; {return User.getSimpleUser();}); log.info(\"user : {}\",user);} UnaryOperator 和 Funtion 有些相似，不同的是它只能返回传入参数同种类型的值 123456789101112131415 // 对字符串进行加工 public String getString(String string,UnaryOperator&lt;String&gt; unaryOperator){ return unaryOperator.apply(string); }// 实现实例 @Test public void testUnaryOperator(){ FirstLambda firstLambda = new FirstLambda(); String string = firstLambda.getString(\"Hello\", p -&gt; {return p + \" World!!!\";}); log.info(\"string : {}\",string); } BiConsumer 比 Consumer 多接收了一个参数 12345678910111213// 拼接一个名字public void getName(String firstName,String secondName,BiConsumer&lt;String,String&gt; biConsumer){ biConsumer.accept(firstName,secondName);}//@Testpublic void testBiConsumer(){ FirstLambda firstLambda = new FirstLambda(); firstLambda.getName(\"Macro\",\"Reus\", (a,b) -&gt; log.info(\"{} {}\",a,b));} BiPredicate 比 Predicate 多接受一个参数 12345678910111213141516171819202122232425// 找出年龄较大的一位 public String getOlderUser(User first,User second,BiPredicate&lt;User,User&gt; biPredicate,Function&lt;User,String&gt; function){ if(biPredicate.test(first,second)){ return function.apply(first); }else{ return function.apply(second); } } @Test public void testBiPredicate(){ FirstLambda firstLambda = new FirstLambda(); User first = new User(); first.setName(\"Ke\"); first.setAge(22); User second = new User(); second.setAge(21); second.setName(\"Liang\");// 找出两个User中年龄较大的User的名字 String name = firstLambda.getOlderUser(first,second, (a,b) -&gt; {return a.getAge() &gt;= b.getAge();}, p -&gt; {return p.getName();}); log.info(\"user : {}\",name); } BiFunction 相比于 Function 多接收一个参数 12345678910111213141516171819// 计算矩形面积public Double getArea(Double length,Double width,BiFunction&lt;Double,Double,Double&gt; biFunction){ return biFunction.apply(length,width);}//测试实例 @Testpublic void testBiFunction(){ FirstLambda firstLambda = new FirstLambda(); Double length = 2.2; Double width = 5.1; Double area = firstLambda.getArea(length,width, (a,b) -&gt; {return a * b;}); log.info(\"area : {}\",area);} BinaryOperator 用法同上，只不过只能操作一种类型的参数 Optional 类实际用处 函数式编程中，用于处理 空指针异常 (NullPointerException) 常用方法 方法 说明 public static Optional of(T value) 为非null的值创建一个Optional public static Optional ofNullable(T value) 为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional public boolean isPresent() 如果值存在返回true，否则返回false public T get() 如果Optional有值则将其返回，否则抛出NoSuchElementException public void ifPresent(Consumer&lt;? super T&gt; consumer) 如果Optional实例有值则为其调用consumer，否则不做处理 public T orElse(T other) 如果有值则将其返回，否则返回指定的其它值 public T orElseGet(Supplier&lt;? extends T&gt; other) orElseGet与orElse方法类似，区别在于得到的默认值 public T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X 如果有值则将其返回，否则抛出supplier接口创建的异常 public Optional map(Function&lt;? super T, ? extends U&gt; mapper) 如果有值，则对其执行调用mapping函数得到返回值。如果返回值不为null，则创建包含mapping返回值的Optional作为map方法返回值，否则返回空Optional。 public Optional flatMap(Function&lt;? super T, Optional&gt; mapper) 如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。 public Optional filter(Predicate&lt;? super T&gt; predicate) 如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional 具体实现 使用 of 创建一个 Optional ，传入的值不能为 NULL，否则抛出 NullPointerException 12345@Testpublic void testOf(){ Optional&lt;String&gt; optional = Optional.of(\"Ke\"); log.info(\"optional : {}\",optional);} 使用 ofNullable 创建一个 Optional ,如果传入一个 NULL ，则返回空的Optional 12345678@Testpublic void testOfNullable(){ Optional&lt;String&gt; optionalFirst = Optional.ofNullable(\"Liang\"); Optional&lt;String&gt; optionalSecond = Optional.ofNullable(null); log.info(\"first : {}\",optionalFirst); // first : Optional[Liang] log.info(\"second ; {}\",optionalSecond); // second ; Optional.empty} 使用 isPresent 判定 Optional 是否为空 12345678@Testpublic void testOfNullable(){ Optional&lt;String&gt; optionalFirst = Optional.ofNullable(\"Liang\"); Optional&lt;String&gt; optionalSecond = Optional.ofNullable(null); log.info(\"firstIsNull : {}\",optionalFirst.isPresent()); // true log.info(\"secondIsNull : {}\",optionalSecond.isPresent()); // false} 使用 get 获取值，如果值不存在，抛出 NoSuchElementException 123456789@Testpublic void testOfNullable(){ Optional&lt;String&gt; optionalFirst = Optional.ofNullable(\"Liang\"); Optional&lt;String&gt; optionalSecond = Optional.ofNullable(null); log.info(\"first : {}\",optionalFirst.get()); // first : Liang log.info(\"second ; {}\",optionalSecond.get()); // java.util.NoSuchElementException: No value present} 使用 ifPresent 实现函数式编程，如果值存在，则执行 Consumer 12345678910111213@Testpublic void testIfPresent(){ Optional&lt;String&gt; optionalFirst = Optional.ofNullable(\"Liang\"); Optional&lt;String&gt; optionalSecond = Optional.ofNullable(null); optionalFirst.ifPresent( p -&gt; log.info(\"firstValue : {}\",p) // firstValue : Liang ); optionalSecond.ifPresent( p -&gt; log.info(\"secondValue : {}\",p) );} 使用 orElse 有值则返回，无值则指定其他值 12345@Testpublic void testOrElse(){ Optional&lt;String&gt; optional = Optional.ofNullable(null); log.info(\"optional : {}\",optional.orElse(\"NULL\")); // optional : NULL} 使用 orElseGet 可以结合函数式编程使用，无值则使用 Supplier 工厂返回 123456789@Testpublic void testOrElseGet(){ Optional&lt;User&gt; optional = Optional.ofNullable(null); log.info(\"optional : {}\",optional.orElseGet( () -&gt; {return User.getSimpleUser();} )); // optional : User(name=simple, age=21, weight=null, sexy=male, height=null)} 使用 orElseThrow 结合函数式编程，无值则使用 Supplier 抛出异常 123456789101112131415161718192021222324252627@Test public void testOrElseThrow(){ Optional&lt;User&gt; optional = Optional.ofNullable(null); try{ log.info(\"optional : {}\",optional.orElseThrow( () -&gt; {return new ArithmeticException();} )); }catch (ArithmeticException a){ log.info(\"error\"); // error } } @Test public void testOrElseThrow(){ User user = new User(); user.setName(\"Kabin\"); Optional&lt;User&gt; optional = Optional.ofNullable(user); // optional : User(name=Kabin, age=null, weight=null, sexy=null, height=null) try{ log.info(\"optional : {}\",optional.orElseThrow( () -&gt; {return new ArithmeticException();} )); }catch (ArithmeticException a){ log.info(\"error\"); } } 使用 map 来结合 Function 实现 对值的处理 12345678 @Test public void testMap(){ Optional&lt;String&gt; optional = Optional.ofNullable(\"Hello\");// optional : Optional[Hello World!!!] log.info(\"optional : {}\",optional.map( p -&gt; {return p + \" World!!!\";} )); } 使用 flatMap 来结合 Function，不同的地方在于如果为 NULL,则返回空的 Optional 12345678@Test public void testFlatMap(){ Optional&lt;String&gt; optional = Optional.ofNullable(null); // optional : Optional.empty log.info(\"optional : {}\",optional.map( p -&gt; {return p + \" World!!!\";} )); } 使用 filter 来结合 Predicate 完成过滤处理 12345678910111213141516171819202122232425262728 @Test public void testFilter(){ List&lt;Optional&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); for(int i = 0 ;i &lt; 10 ;i ++){ Optional&lt;Integer&gt; optional = Optional.ofNullable(i); list.add(optional); } list.forEach( p -&gt; log.info(\"optional : {}\", p.filter( q -&gt; {return q &gt;=5;} ) ) ); }2018-12-16 16:01:24.262 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional.empty2018-12-16 16:01:24.262 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional.empty2018-12-16 16:01:24.262 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional.empty2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional.empty2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional.empty2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional[5]2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional[6]2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional[7]2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional[8]2018-12-16 16:01:24.263 INFO 11424 --- [ main] com.zyy.consumer.OptionalTest : optional : Optional[9] 最为有效的用途之一 连环夺命 NULL 判定 123456789101112131415161718192021222324252627282930313233343536373839404142434445 @Test public void testOptional(){ // 获取 User 类中的 name 并且转换为大写,进行 NULL 判定 Optional&lt;User&gt; optional = Optional.ofNullable(User.getSimpleUser()); // name : SIMPLE log.info(\"name : {}\", optional.map( p -&gt; {return p.getName();} ).map( q -&gt; {return q.toUpperCase();} ).orElse(null) ); } @Test public void testOptional(){ // 获取 User 类中的 name 并且转换为大写,进行 NULL 判定 Optional&lt;User&gt; optional = Optional.ofNullable(null); // name : null log.info(\"name : {}\", optional.map( p -&gt; {return p.getName();} ).map( q -&gt; {return q.toUpperCase();} ).orElse(null) ); }// 最直观的对比，如果使用 if 来判定,如果判定 null 过程过多时，会写出一堆不雅观的代码，一堆的 if 嵌套 @Test public String getUser(){ User user = User.getSimpleUser(); if(user != null){ if(user.getName() != null){ return user.getName().toUpperCase(); }else{ return null; } }else{ return null; } } Stream 类详细参考 https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/ 关于 Stream Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 与 Iterator 的不同 Stream 可以并行化操作，迭代器只能命令式地、串行化操作。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。 流管道的结构图 对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect） 生成 Stream Source 的方法 Collection 和 数组： Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() BufferedReader： java.io.BufferedReader.lines() 静态工厂： java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建： java.util.Spliterator 其他： Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型 Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 short-circuiting： 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。 对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。 Stream 的常见构造 Stream 的 of 可以用于创建，默认是String 类型，如果要创建 Integer，Double，Long，请使用 IntStream, LongStream , DoubleStream ,避免使用泛型可以省去装箱操作，提高性能 12345678910111213 @Test public void testStreamConstruction(){ Stream stream = Stream.of(\"Ke\",\"Liang\",\"Zeng\");// 不用泛型，使用具体Stream,可以省去 装箱操作，提高性能 IntStream intStream = IntStream.of(22,21,21); DoubleStream doubleStream = DoubleStream.of(62,55,63); LongStream longStream = LongStream.of(170,175,170); } 通过数组构造 12345678@Testpublic void testStreamConstructionByArray(){ String[] strings = new String[]{\"Ke\",\"Liang\",\"Zeng\"}; Stream stream = Stream.of(strings); stream = Arrays.stream(strings);} 通过 Collection 来构造 12345678910 @Test public void testStreamConstructionByList(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); }// 待探讨，这里无法用 IntStream 接收 Stream&lt;Integer&gt; stream = list.stream(); } Stream 的操作 现在，我们之前学的 Lambda 就起作用了，因为 Stream 的操作 几乎都是基于 java.utils.function 包来完成的 Stream 的 Intermediate 操作 方法 说明 map 执行Function操作，修改数值 filter 执行 Predicate操作，完成过滤 distinct 去重 sorted 排序 peek 接收一个Consumer，做一些输出或外部处理 limit 限制Stream通过的个数 skip 跳过前几个 parallel 返回一个 parallel stream(转换为并行流) sequential 返回一个 sequential stream(转换为串行流) unordered 返回一个 unordered stream(转换为无序流) Stream 的 Terminal 操作 方法 说明 forEach 接收一个Consumer forEachOrdered 并行时按顺序处理，区别于forEach toArray 返回一个数组 reduce 接收一个BinaryOperator collect 返回一个集合 min 聚合求最小值 max 聚合求最大值 count 聚合计数 anyMatch 接收一个 Predicate，有一个符合就是True allMatch 接收一个 Predicate，所有符合是Ture noneMatch 接收一个 Predicate，所有不符合是Ture findFirst 获取第一个，返回 Optional，并行流中才和findAny有区别 findAny 随机返回一个，返回 Optional iterator 转换成迭代器 Stream 的 Short-circuiting 操作 方法 说明 anyMatch 同上 allMatch 同上 noneMatch 同上 findFirst 同上 findAny 同上 limit 同上 开始表演map Stream map(Function&lt;? super T, ? extends R&gt; mapper) 12345678910111213// 将 流的value 全部转为大写，其中的 collect 是返回集合 @Test public void testStreamMap(){ String[] strings = new String[]{\"Ke\",\"Liang\",\"Zeng\"}; Stream&lt;String&gt; stream = Stream.of(strings); List&lt;String&gt; list = stream.map( p -&gt; p.toUpperCase() ).collect(Collectors.toList()); log.info(\"list : {}\",list); // list : [KE, LIANG, ZENG] } filter Stream filter(Predicate&lt;? super T&gt; predicate) 执行过滤操作 1234567891011121314151617// 将 流的value 小于等于5 的都过滤 @Test public void testStreamFilter(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); list = stream.filter( p -&gt; p &gt;5 ).collect(Collectors.toList()); log.info(\"list : {}\",list); // list : [6, 7, 8, 9] } distinct Stream distinct() 去重 1234567891011121314151617181920// 去重@Testpublic void testStreamDistinct(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 3 ; i++){ list.add(i); } for(int i = 0 ; i &lt; 3 ; i++){ list.add(i); } log.info(\"before ： {}\",list); // before ： [0, 1, 2, 0, 1, 2] Stream&lt;Integer&gt; stream = list.stream(); list = stream.distinct().collect(Collectors.toList()); log.info(\"after : {}\",list); // after : [0, 1, 2]} sorted Stream sorted() 和 Stream sorted(Comparator&lt;? super T&gt; comparator) 12345678910111213141516171819202122@Test public void testStreamSorted(){ Stream&lt;Integer&gt; stream = Stream.of(22,21,21); // 升序排列 List&lt;Integer&gt; integerList = stream.sorted().collect(Collectors.toList()); log.info(\"integerList : {}\",integerList); // integerList : [21, 21, 22] List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 5 ; i++){ list.add(i); } Stream&lt;Integer&gt; streamSecond = list.stream(); // 自定义 CompareTo 完成倒序 list = streamSecond.sorted( (a,b) -&gt; a &gt;= b ? -1 : 1 ).collect(Collectors.toList()); log.info(\"list : {}\",list); // list : [4, 3, 2, 1, 0] } peek Stream peek(Consumer&lt;? super T&gt; action) 12345678910111213 @Test public void testStreamPeek(){ Stream&lt;Integer&gt; stream = Stream.of(22,21,21); // 一个 Stream 必须执行 Terminal 操作，否则 Intermediate 不起作用 stream.peek( p -&gt; log.info(\"number : {}\",p) ).count(); } /* 2018-12-16 17:52:25.639 INFO 7988 --- [ main] com.zyy.consumer.StreamTest : number : 222018-12-16 17:52:25.640 INFO 7988 --- [ main] com.zyy.consumer.StreamTest : number : 212018-12-16 17:52:25.640 INFO 7988 --- [ main] com.zyy.consumer.StreamTest : number : 21*/ limit Stream limit(long maxSize) 12345678910111213141516 // 只需要 3 个元素就足够了@Test public void testStreamLimit(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); list = stream.limit(3).collect(Collectors.toList()); log.info(\"list : {}\",list); // list : [0, 1, 2] } skip Stream skip(long n) 123456789101112131415// 跳过前三个 @Test public void testStreamSkip(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); list = stream.skip(3).collect(Collectors.toList()); log.info(\"list : {}\",list); // list : [3, 4, 5, 6, 7, 8, 9] } parallel S parallel() 转换为并行流 12345678910111213141516171819 @Test public void testStreamParallel(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 5 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); stream.parallel().forEach( p -&gt; log.info(\"number : {}\",p) ); }2018-12-16 18:16:36.558 INFO 15640 --- [ main] com.zyy.consumer.StreamTest : number : 22018-12-16 18:16:36.558 INFO 15640 --- [ main] com.zyy.consumer.StreamTest : number : 42018-12-16 18:16:36.560 INFO 15640 --- [ main] com.zyy.consumer.StreamTest : number : 32018-12-16 18:16:36.561 INFO 15640 --- [ main] com.zyy.consumer.StreamTest : number : 02018-12-16 18:16:36.558 INFO 15640 --- [onPool-worker-1] com.zyy.consumer.StreamTest : number : 1 forEach void forEach(Consumer&lt;? super T&gt; action) 1234567891011121314151617 @Test public void testStreamForEach(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); stream.limit(3).forEach( p -&gt; log.info(\"number : {}\",p) ); }2018-12-16 18:11:22.170 INFO 14328 --- [ main] com.zyy.consumer.StreamTest : number : 02018-12-16 18:11:22.172 INFO 14328 --- [ main] com.zyy.consumer.StreamTest : number : 12018-12-16 18:11:22.172 INFO 14328 --- [ main] com.zyy.consumer.StreamTest : number : 2 forEachOrdered void forEachOrdered(Consumer&lt;? super T&gt; action) 1234567891011121314151617181920 // 并行流也会按顺序执行，不过会牺牲速度 @Test public void testStreamForEachOrdered(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 5 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); stream.parallel().forEachOrdered( p -&gt; log.info(\"number : {}\",p) ); } 2018-12-16 18:20:00.344 INFO 17744 --- [ main] com.zyy.consumer.StreamTest : number : 02018-12-16 18:20:00.344 INFO 17744 --- [onPool-worker-1] com.zyy.consumer.StreamTest : number : 12018-12-16 18:20:00.345 INFO 17744 --- [onPool-worker-1] com.zyy.consumer.StreamTest : number : 22018-12-16 18:20:00.345 INFO 17744 --- [onPool-worker-1] com.zyy.consumer.StreamTest : number : 32018-12-16 18:20:00.345 INFO 17744 --- [onPool-worker-1] com.zyy.consumer.StreamTest : number : 4 toArray Object[] toArray() 1234567891011121314151617181920 @Test public void testStreamToArray(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); Object[] objects = stream.limit(4).toArray(); for(Object o : objects){ log.info(\"number : {}\",o); } }2018-12-16 18:25:40.322 INFO 5544 --- [ main] com.zyy.consumer.StreamTest : number : 02018-12-16 18:25:40.322 INFO 5544 --- [ main] com.zyy.consumer.StreamTest : number : 12018-12-16 18:25:40.322 INFO 5544 --- [ main] com.zyy.consumer.StreamTest : number : 22018-12-16 18:25:40.322 INFO 5544 --- [ main] com.zyy.consumer.StreamTest : number : 3 reduce Optional reduce(BinaryOperator accumulator) 12345678910111213141516// 求和 @Test public void testStreamReduce(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); Optional&lt;Integer&gt; optional = stream.reduce( (a,b) -&gt; a + b ); log.info(\"sum : {}\",optional.get()); // sum : 45 } Match12345678910111213141516171819202122232425262728293031323334// 测试三种 match@Test public void testStreamMatch(){ List&lt;Integer&gt; list = new ArrayList(); for(int i = 0 ; i &lt; 10 ; i++){ list.add(i); } Stream&lt;Integer&gt; stream = list.stream(); log.info(\"AnyFirst : {}\",stream.anyMatch( p -&gt; p &gt;5 )); // true stream = list.stream(); log.info(\"AnySecond : {}\",stream.anyMatch( p -&gt; p &gt;15 )); // false stream = list.stream(); log.info(\"AllFirst : {}\",stream.allMatch( p -&gt; p &gt;=0 )); // true stream = list.stream(); log.info(\"AllSecond : {}\",stream.allMatch( p -&gt; p &gt;5 )); // false stream = list.stream(); log.info(\"NoneFirst : {}\",stream.noneMatch( p -&gt; p &gt; 10 )); // true stream = list.stream(); log.info(\"NoneSecond : {}\",stream.noneMatch( p -&gt; p &gt; 5 )); // false } JDK8 中 :: 的使用本质 就是将 Stream 的参数传入一个方法中执行 要求 一个类的静态方法 参数需要一致 1234567891011121314151617181920// LambdaTest 类 @Test public void testLambdaPredicate(){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; 10;i++){ list.add(i); } new FirstLambda().checkNumberBigger(list, p -&gt; p &gt; 5, LambdaTest::testDoubleQuote); // 将Stream 传入 LambdaTest.testDoubleQuote new FirstLambda().checkNumberBigger(list, p -&gt; p &gt; 5, p -&gt; log.info(\"number : {}\",p)); } public static void testDoubleQuote(Integer s){ log.info(\"element : {}\",s); }","link":"/2020/06/06/Java 函数式编程入门/"},{"title":"JavaScript对象：你知道全部的对象分类吗？","text":"前面讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。比如说，我们不论怎样编写代码，都没法绕开 Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的 length 属性。并且，在浏览器环境中，我们也无法单纯依靠 JavaScript 代码实现 div 对象，只能靠 document.createElement 来创建。这也说明了 JavaScript 的对象机制并非简单的属性集合 + 原型。我们日常工作中，接触到的主要 API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的 API 的一些特性。JavaScript 中的对象分类我们可以把对象分成几类。宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。下面我会为你一一讲解普通对象之外的对象类型。宿主对象首先我们来看看宿主对象。JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。JavaScript 标准中规定了全局对象属性，w3c 的各种标准中规定了 Window 对象的其它属性。宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 dom 对象。宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素，这些我们会在浏览器的 API 部分详细讲解。内置对象·固有对象我们在前面说过，固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。ECMA 标准为我们提供了一份固有对象表，里面含有 150+ 个固有对象。你可以通过这个链接查看。但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部 JavaScript 固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。内置对象·原生对象我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。这些构造器创建的对象多数使用了私有字段, 例如：Error: [[ErrorData]]Boolean: [[BooleanData]]Number: [[NumberData]]Date: [[DateValue]]RegExp: [[RegExpMatcher]]Symbol: [[SymbolData]]Map: [[MapData]]这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。用对象来模拟函数与构造器：函数对象与构造器对象我在前面介绍了对象的一般分类，在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。事实上，JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。JavaScript 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有 [[call]] 私有字段的对象”，就可以被 JavaScript 函数调用语法支持。[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。我们可以这样说，任何对象只需要实现 [[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 [[construct]]，它就是一个构造器对象，可以作为构造器被调用。对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如 Symbol 函数）可以模拟函数和构造器。当然了，用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。对于宿主和内置对象来说，它们实现 [[call]]（作为函数被调用）和 [[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：12console.log(new Date); // 1console.log(Date())而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。12console.log(new Image); console.log(Image());// 抛出错误再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。值得一提的是，在 ES6 之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：1new (a =&gt; 0) // error对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]] 和 [[construct]] 行为总是相似的，它们执行同一段代码。我们看一下示例。12345function f(){ return 1;}var v = f(); // 把 f 作为函数调用var o = new f(); // 把 f 作为构造器调用我们大致可以认为，它们 [[construct]] 的执行过程如下：以 Object.protoype 为原型创建一个新对象；以新对象为 this，执行函数的 [[call]]；如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。123456789function cls(){ this.a = 100; return { getValue:() =&gt; this.a }}var o = new cls;o.getValue(); //100//a 在外面永远无法访问到特殊行为的对象除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。Array：Array 的 length 属性根据最大的下标自动发生变化。Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。Arguments：arguments 的非负整数型下标属性跟对应的变量联动。模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。bind 后的 function：跟原来的函数相关联。总结在这篇文章中，我们介绍了一些不那么常规的对象，并且我还介绍了 JavaScript 中用对象来模拟函数和构造器的机制。这是一些不那么有规律、不那么优雅的知识，而 JavaScript 正是通过这些对象，提供了很多基础的能力。我们这次课程留给大家一个挑战任务：不使用 new 运算符，尽可能找到获得对象的方法。例子：12var o = {}var o = function(){}请大家把自己的答案留言给我，我们来比比看谁找到的多。小实验：获取全部 JavaScript 固有对象我们从 JavaScript 标准中可以找到全部的 JS 对象定义。JS 语言规定了全局对象的属性。三个值：Infinity、NaN、undefined。九个函数：evalisFiniteisNaNparseFloatparseIntdecodeURIdecodeURIComponentencodeURIencodeURIComponent一些构造器：Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeapSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeErrorURIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。四个用于当作命名空间的对象：AtomicsJSONMathReflect我们使用广度优先搜索，查找这些对象所有的属性和 Getter/Setter，就可以获得 JavaScript 中所有的固有对象。请你试着先不看我的代码，在自己的浏览器中计算出来 JavaScript 有多少固有对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var set = new Set();var objects = [ eval, isFinite, isNaN, parseFloat, parseInt, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, Array, Date, RegExp, Promise, Proxy, Map, WeakMap, Set, WeakSet, Function, Boolean, String, Number, Symbol, Object, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, ArrayBuffer, SharedArrayBuffer, DataView, Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Atomics, JSON, Math, Reflect];objects.forEach(o =&gt; set.add(o));for(var i = 0; i &lt; objects.length; i++) { var o = objects[i] for(var p of Object.getOwnPropertyNames(o)) { var d = Object.getOwnPropertyDescriptor(o, p) if( (d.value !== null &amp;&amp; typeof d.value === \"object\") || (typeof d.value === \"function\")) if(!set.has(d.value)) set.add(d.value), objects.push(d.value); if( d.get ) if(!set.has(d.get)) set.add(d.get), objects.push(d.get); if( d.set ) if(!set.has(d.set)) set.add(d.set), objects.push(d.set); }}转自—《重学前端》","link":"/2020/06/06/JavaScript对象：你知道全部的对象分类吗？/"},{"title":"JavaScript对象：面向对象还是基于对象？","text":"与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。 一些新人在学习 JavaScript 面向对象时，往往也会有疑惑： 为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢； 为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢？ 甚至，在一些争论中，有人强调：JavaScript 并非“面向对象的语言”，而是“基于对象的语言”。这个说法一度流传甚广，而事实上，我至今遇到的持有这一说法的人中，无一能够回答“如何定义面向对象和基于对象”这个问题。 实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。 我们可以先看看 JavaScript 标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”。 这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。 那么，在本篇文章中，我会尝试让你去理解面向对象和 JavaScript 中的面向对象究竟是什么。 什么是面向对象？ 我们先来说说什么是对象，因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。 中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。 但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。 那么，我们先来看看在人类思维模式下，对象究竟是什么。 对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。 在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。 在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一： 一个可以触摸或者可以看见的东西； 人的智力可以理解的东西； 可以指导思考或行动（进行想象或施加动作）的东西。 有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。 而 JavaScript 早年却选择了一个更为冷门的方式：原型（关于原型，我在下一篇文章会重点介绍，这里你留个印象就可以了）。这是我在前面说它不合群的原因之一。 然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this等语言特性，使之“看起来更像 Java”。 在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把 JavaScript 变得更像是基于类的编程，进而产生了很多所谓的“框架”，比如 PrototypeJS、Dojo。 事实上，它们成为了某种 JavaScript 的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。 如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。 不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。 首先我们来了解一下 JavaScript 是如何设计对象模型的。 JavaScript 对象的特征 在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。 对象有状态：对象具有状态，同一对象可能处于不同状态之下。 对象具有行为：即对象的状态，可能因为它的行为产生变迁。 我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。 所以，JavaScript 程序员都知道，任何不同的 JavaScript 对象其实是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一模一样的对象，但是打印出来的结果却是 false。123var o1 = { a: 1 };var o2 = { a: 1 };console.log(o1 == o2); // false关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“成员变量”和“成员函数”，Java 中则称它们为“属性”和“方法”。在 JavaScript 中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。123456var o = { d: 1, f() { console.log(this.d); } };所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性。如果你用过 Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。123var o = { a: 1 };o.b = 2;console.log(o.a, o.b); //1 2为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。JavaScript 对象的两类属性对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。 value：就是属性的值。 writable：决定属性能否被赋值。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。在大多数情况下，我们只关心数据属性的值即可。第二类属性是访问器（getter/setter）属性，它也有四个特征。 getter：函数或 undefined，在取属性值时被调用。 setter：函数或 undefined，在设置属性值时被调用。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：12345var o = { a: 1 };o.b = 2;//a 和 b 皆为数据属性Object.getOwnPropertyDescriptor(o,\"a\") // {value: 1, writable: true, enumerable: true, configurable: true}Object.getOwnPropertyDescriptor(o,\"b\") // {value: 2, writable: true, enumerable: true, configurable: true}我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：1234567var o = { a: 1 };Object.defineProperty(o, \"b\", {value: 2, writable: false, enumerable: false, configurable: true});//a 和 b 都是数据属性，但特征值变化了Object.getOwnPropertyDescriptor(o,\"a\"); // {value: 1, writable: true, enumerable: true, configurable: true}Object.getOwnPropertyDescriptor(o,\"b\"); // {value: 2, writable: false, enumerable: false, configurable: true}o.b = 3;console.log(o.b); // 2这里我们使用了 Object.defineProperty 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示：123var o = { get a() { return 1 } };console.log(o.a); // 1访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。这样，我们就理解了，实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下“a”是 key。{writable:true,value:1,configurable:true,enumerable:true} 是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。你甚至可以理解为什么会有“JavaScript 不是面向对象”这样的说法了。这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍 JavaScript中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。结语要想理解 JavaScript 对象，必须清空我们脑子里“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解 JavaScript 面向对象设计的思路。在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了 JavaScript 对象的设计思路。接下来又从运行时的角度，介绍了 JavaScript 对象的具体设计：具有高度动态性的属性集合。很多人在思考 JavaScript 对象时，会带着已有的“对象”观来看问题，最后的结果当然就是“剪不断理还乱”了。在后面的文章中，我会继续带你探索 JavaScript 对象的一些机制，看 JavaScript 如何基于这样的动态对象模型设计自己的原型系统，以及你熟悉的函数、类等基础设施。转自—《重学前端》","link":"/2020/06/06/JavaScript对象：面向对象还是基于对象？/"},{"title":"JavaScript对象：我们真的需要模拟类吗？","text":"早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。 在上一篇文章我们已经讲到，JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。 那么，随着我们理解的思路继续深入，这些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。 尽管我认为，“类”并非面向对象的全部，但我们不应该责备社区出现这样的方案，事实上，因为一些公司的政治原因，JavaScript 推出之时，管理层就要求它去模仿 Java。 所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来语法更像 Java”，而 Java 正是基于类的面向对象的代表语言之一。 但是 JavaScript 这样的半吊子模拟，缺少了继承等关键特性，导致大家试图对它进行修补，进而产生了种种互不相容的解决方案。 庆幸的是，从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。 实际上，我认为“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。 我们从头讲起。 什么是原型？ 原型是顺应人类自然思维的产物。中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。 我们在上一节讲解面向对象的时候提到了：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。 最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。 还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。 “基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。 与此相对，“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。 基于原型的面向对象系统通过“复制”的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。 基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。 这就像专业人士可能喜欢在看到老虎的时候，喜欢用猫科豹属豹亚种来描述它，但是对一些不那么正式的场合，“大猫”可能更为接近直观的感受一些（插播一个冷知识：比起老虎来，美洲狮在历史上相当长时间都被划分为猫科猫属，所以性格也跟猫更相似，比较亲人）。 我们的 JavaScript 并非第一个使用原型的语言，在它之前，self、kevo 等语言已经开始使用原型来描述对象了。 事实上，Brendan 更是曾透露过，他最初的构想是一个拥有基于原型的面向对象能力的 scheme 语言（但是函数式的部分是另外的故事，这篇文章里，我暂时不做详细讲述）。 在 JavaScript 之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，我想，这应该是 Brendan 选择原型系统很重要的理由。 原型系统的“复制操作”有两种实现思路： 一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用； 另一个是切实地复制对象，从此两个对象再无关联。 历史上的基于原型语言因此产生了两个流派，显然，JavaScript 显然选择了前一种方式。 JavaScript 的原型 如果我们抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，我可以用两条概括： 如果所有对象都有私有字段 [[prototype]]，就是对象的原型； 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。 这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为： Object.create 根据指定的原型创建新对象，原型可以是 null； Object.getPrototypeOf 获得一个对象的原型； Object.setPrototypeOf 设置一个对象的原型。 利用这三个方法，我们可以完全抛开类的思维，利用原型来实现抽象和复用。我用下面的代码展示了用原型来抽象猫和虎的例子。12345678910111213141516171819202122232425262728var cat = { say(){ console.log(\"meow~\"); }, jump(){ console.log(\"jump\"); }}var tiger = Object.create(cat, { say:{ writable:true, configurable:true, enumerable:true, value:function(){ console.log(\"roar!\"); } }})var anotherCat = Object.create(cat);anotherCat.say();var anotherTiger = Object.create(tiger);anotherTiger.say();这段代码创建了一个“猫”对象，又根据猫做了一些修改创建了虎，之后我们完全可以用 Object.create 来创建另外的猫和虎对象，我们可以通过“原始猫对象”和“原始虎对象”来控制所有猫和虎的行为。但是，在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，可以说非常别扭。考虑到 new 和 prototype 属性等基础设施今天仍然有效，而且被很多代码使用，学习这些知识也有助于我们理解运行时的原型工作原理，下面我们试着回到过去，追溯一下早年的 JavaScript 中的原型和类。早期版本中的类与原型在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。以下代码展示了所有具有内置 class 属性的对象：1234567891011var o = new Object;var n = new Number;var s = new String;var b = new Boolean;var d = new Date;var arg = function(){ return arguments }();var r = new RegExp;var f = new Function;var arr = new Array;var e = new Error;console.log([o, n, s, b, d, arg, r, f, arr, e].map(v =&gt; Object.prototype.toString.call(v)));因此，在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为：12var o = { [Symbol.toStringTag]: \"MyObject\" }console.log(o + \"\");这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响。但是，考虑到 JavaScript 语法中跟 Java 相似的部分，我们对类的讨论不能用“new 运算是针对构造器对象，而不是类”来试图回避。所以，我们仍然要把 new 理解成 JavaScript 面向对象的一部分，下面我就来讲一下 new 操作具体做了哪些事情。new 运算接受一个构造器和一组调用参数，实际上做了几件事：以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；将 this 和调用参数传给构造器，执行；如果构造器返回的是对象，则返回，否则返回第一步创建的对象。new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。下面代码展示了用构造器模拟类的两种方法:123456789101112131415161718192021function c1(){ this.p1 = 1; this.p2 = function(){ console.log(this.p1); }} var o1 = new c1;o1.p2();function c2(){}c2.prototype.p1 = 1;c2.prototype.p2 = function(){ console.log(this.p1);}var o2 = new c2;o2.p2();第一种方法是直接在构造器中修改 this，给 this 添加属性。第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法（当时的 mozilla 提供了私有属性 proto，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 pollyfill，见以下代码：12345Object.create = function(prototype){ var cls = function(){} cls.prototype = prototype; return new cls;}这段代码创建了一个空函数作为类，并把传入的原型挂在了它的 prototype，最后创建了一个它的实例，根据 new 的行为，这将产生一个以传入的第一个参数为原型的对象。这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型，所以放到今天意义已经不大了。ES6 中的类好在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。下面我们就来看一下 ES6 中的类。ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。我们先看下类的基本写法：1234567891011121314class Rectangle { constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea(); } // Method calcArea() { return this.height * this.width; }}在现有的类语法中，getter/setter 和 method 是兼容性最好的。我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。12345678910111213141516171819202122class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + ' makes a noise.'); }}class Dog extends Animal { constructor(name) { super(name); // call the super class constructor and pass in the name parameter } speak() { console.log(this.name + ' barks.'); }}let d = new Dog('Mitzie');d.speak(); // Mitzie barks.以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。一些激进的观点认为，class 关键字和箭头运算符可以完全替代旧的 function 关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。总结在新的 ES 版本中，我们不再需要模拟类了：我们有了光明正大的新语法。而原型体系同时作为一种编程范式和运行时机制存在。我们可以自由选择原型或者类作为代码的抽象风格，但是无论我们选择哪种，理解运行时的原型系统都是很有必要的一件事。在你的工作中，是使用 class 还是仍然在用 function 来定义“类”？为什么这么做？如何把使用 function 定义类的代码改造到 class 的新语法？欢迎给我留言，我们一起讨论。转自—《重学前端》","link":"/2020/06/06/JavaScript对象：我们真的需要模拟类吗？/"},{"title":"JavaScript执行（三）：你知道现在有多少种函数吗？","text":"在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。 一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。 在 JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。 函数 在 ES2018 中，函数已经是一个很复杂的体系了，我在这里整理了一下。 第一种，普通函数：用 function 关键字定义的函数。 示例：123function foo(){ // code}第二种，箭头函数：用 =&gt; 运算符定义的函数。示例:123const foo = () =&gt; { // code}第三种，方法：在 class 中定义的函数。示例：12345class C { foo(){ //code }}第四种，生成器函数：用 function * 定义的函数。示例：123function foo*(){ // code}第五种，类：用 class 定义的类，实际上也是函数。示例：12345class Foo { constructor(){ //code }}第六 / 七 / 八种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。示例：123456789async function foo(){ // code}const foo = async () =&gt; { // code}async function foo*(){ // code}ES6 以来，大量加入的新语法极大地方便了我们编程的同时，也增加了很多我们理解的心智负担。要想认识这些函数的执行上下文切换，我们必须要对它们行为上的区别有所了解。","link":"/2020/06/06/JavaScript执行（三）：你知道现在有多少种函数吗？/"},{"title":"JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？","text":"这一部分我们来讲一讲 JavaScript 的执行。 首先我们考虑一下，如果我们是浏览器或者 Node 的开发者，我们该如何使用 JavaScript 引擎。 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。 然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。 所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。 但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。 由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。 宏观和微观任务 JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。 不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：1234while(TRUE) { r = wait(); execute(r);}我们可以看到，整个循环做的事情基本上就是反复“等待 - 执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：有了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。接下来，我们来详细介绍一下 Promise。PromisePromise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。Promise 的基本用法示例如下：123456function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); })}sleep(1000).then( ()=&gt; console.log(\"finished\"));这段代码定义了一个函数 sleep，它的作用是等候传入参数指定的时长。Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序，我们来看一段代码示例：123456var r = new Promise(function(resolve, reject){ console.log(\"a\"); resolve()});r.then(() =&gt; console.log(\"c\"));console.log(\"b\")我们执行这段代码后，注意输出的顺序是 a b c。在进入 console.log(“b”) 之前，毫无疑问 r 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。接下来我们试试跟 setTimeout 混用的 Promise。在这段代码中，我设置了两段互不相干的异步操作：通过 setTimeout 执行 console.log(“d”)，通过 Promise 执行 console.log(“c”)1234567var r = new Promise(function(resolve, reject){ console.log(\"a\"); resolve()});setTimeout(()=&gt;console.log(\"d\"), 0)r.then(() =&gt; console.log(\"c\"));console.log(\"b\")我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。为了理解微任务始终先于宏任务，我们设计一个实验：执行一个耗时 1 秒的 Promise。123456789101112setTimeout(()=&gt;console.log(\"d\"), 0)var r1 = new Promise(function(resolve, reject){ resolve()});r.then(() =&gt; { var begin = Date.now(); while(Date.now() - begin &lt; 1000); console.log(\"c1\") new Promise(function(resolve, reject){ resolve() }).then(() =&gt; console.log(\"c2\"))});这里我们强制了 1 秒的执行耗时，这样，我们可以确保任务 c2 是在 d 之后被添加到任务队列。我们可以看到，即使耗时一秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行了，这很好地解释了微任务优先的原理。通过一系列的实验，我们可以总结一下如何分析异步执行的顺序：首先我们分析有多少个宏任务；在每个宏任务中，分析有多少个微任务；根据调用次序，确定宏任务中的微任务执行次序；根据宏任务的触发规则和调用次序，确定宏任务的执行次序；确定整个顺序。我们再来看一个稍微复杂的例子：12345678function sleep(duration) { return new Promise(function(resolve, reject) { console.log(\"b\"); setTimeout(resolve,duration); })}console.log(\"a\");sleep(5000).then(()=&gt;console.log(\"c\"));这是一段非常常用的封装方法，利用 Promise 把 setTimeout 封装成可以用于异步的函数。我们首先来看，setTimeout 把整个代码分割成了 2 个宏观任务，这里不论是 5 秒还是 0 秒，都是一样的。第一个宏观任务中，包含了先后同步执行的 console.log(“a”); 和 console.log(“b”);。setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(“c”)，最终输出的顺序才是： a b c。Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。新特性：async/awaitasync/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise，面对这种比较新的特性，我们先来看一下基本用法。async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。12345678910function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); })}async function foo(){ console.log(\"a\") await sleep(2000) console.log(\"b\")}这段代码利用了我们之前定义的 sleep 函数。在异步函数 foo 中，我们调用 sleep。async 函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。12345678910111213function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); })}async function foo(name){ await sleep(2000) console.log(name)}async function foo2(){ await foo(\"a\"); await foo(\"b\");}这里 foo2 用 await 调用了两次异步函数 foo，可以看到，如果我们把 sleep 这样的异步操作放入某一个框架或者库中，使用者几乎不需要了解 Promise 的概念即可进行异步编程了。此外，generator/iterator 也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。结语在今天的文章里，我们学习了 JavaScript 执行部分的知识，首先我们学习了 JavaScript 的宏观任务和微观任务相关的知识。我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。除此之外，我们还展开介绍了用 Promise 来添加微观任务的方式，并且介绍了 async/await 这个语法的改进。最后，留给你一个小练习：我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色，你会怎样编写这个代码呢？转自—《重学前端》","link":"/2020/06/06/JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？/"},{"title":"JavaScript执行（二）：闭包和执行上下文到底是怎么回事？","text":"在上一课，我们了解了 JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据“由 JavaScript 引擎发起”还是“由宿主发起”，分成了宏观任务和微观任务，接下来我们继续去看一看更细的执行粒度。 一段 JavaScript 代码可能会包含函数调用的相关内容，从今天开始，我们就用两节课的时间来了解一下函数的执行。 我们今天要讲的知识在网上有不同的名字，比较常见的可能有： 闭包； 作用域链； 执行上下文； this 值。 实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。我们可以简单看一下图。 看着也许会有点晕，别着急，我会和你共同理一下它们之间的关系。 当然，除了让你理解函数执行过程的知识，理清这些概念也非常重要。所以我们先来讲讲这个有点复杂的概念：闭包。 闭包 闭包翻译自英文单词 closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。 闭包这个概念第一次出现在 1964 年的《The Computer Journal》上，由 P. J. Landin 在《The mechanical evaluation of expressions》一文中提出了 applicative expression 和 closure 的概念。 在上世纪 60 年代，主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。 我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。 这个古典的闭包定义中，闭包包含两个部分。 环境部分 环境 标识符列表 表达式部分 当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。 环境部分 环境：函数的词法环境（执行上下文的一部分） 标识符列表：函数中用到的未声明的变量 表达式部分：函数体 至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。 这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。 实际上 JavaScript 中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧（其实我早年也是这么理解闭包，直到后来被朋友纠正，查了资料才改正过来）。 执行上下文：执行的基础设施 相比普通函数，JavaScript 函数的主要复杂性来自于它携带的“环境部分”。当然，发展到今天的 JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。 JavaScript 中与闭包“环境部分”相对应的术语是“词法环境”，但是 JavaScript 函数比λ函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ函数中可没有这些东西，所以，在 JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。 JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。 因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。 执行上下文在 ES3 中，包含三个部分。 scope：作用域，也常常被叫做作用域链。 variable object：变量对象，用于存储变量的对象。 this value：this 值。 在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 lexical environment：词法环境，当获取变量时使用。 variable environment：变量环境，当声明变量时使用。 this value：this 值。 在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。 lexical environment：词法环境，当获取变量或者 this 值时使用。 variable environment：变量环境，当声明变量时使用 code evaluation state：用于恢复代码执行位置。 Function：执行的任务是函数时使用，表示正在被执行的函数。 ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。 Realm：使用的基础库和内置对象实例。 Generator：仅生成器上下文有这个属性，表示当前生成器。 我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的 ES2018 中规定的术语定义。 尽管我们介绍了这些定义，但我并不打算按照 JavaScript 标准的思路，从实现的角度去介绍函数的执行过程，这是不容易被理解的。 我想试着从代码实例出发，跟你一起推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分。 比如，我们看以下的这段 JavaScript 代码：123var b = {}let c = 1this.a = 2;要想正确执行它，我们需要知道以下信息：var 把 b 声明到哪里；b 表示哪个变量；b 的原型是哪个对象；let 把 c 声明到哪里；this 指向哪个对象。这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。在这两篇文章中，我会基本覆盖执行上下文的组成部分，本篇我们先讲 var 声明与赋值，let，realm 三个特性来分析上下文提供的信息，分析执行上下文中提供的信息。var 声明与赋值我们来分析一段代码：1var b = 1通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用域函数执行的作用域。也就是说，var 会穿透 for 、if 等语句。在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。12345678910(function(){ var a; //code}());(function(){ var a; //code})();但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。12345678910;(function(){ var a; //code}());(function(){ var a; //code})()我比较推荐的写法是使用 void 关键字。也就是下面的这种形式。1234void function(){ var a; //code}();这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。值得特别注意的是，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，JavaScript 中有特例，那就是使用 with 的时候：1234567891011var b;void function(){ var env = {b:1}; b = 2; console.log(\"In function b:\", b); with(env) { var b = 3; console.log(\"In with b:\", b); }}();console.log(\"Global b:\", b);在这个例子中，我们利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境，并且在里面使用了我们一开头的代码。可以看到，在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。letlet 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。我简单统计了下，以下语句会产生 let 使用的作用域：for；if；switch；try/catch/finally。Realm在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。这个英文的用法就有点比喻的意思，几个翻译都不太适合 JavaScript 语境，所以这里就不翻译啦。我们继续来看这段代码：1var b = {}在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：12345678910var iframe = document.createElement('iframe')document.documentElement.appendChild(iframe)iframe.src=\"javascript:var b = {};\"var b1 = iframe.contentWindow.b;var b2 = {};console.log(typeof b1, typeof b2); //object objectconsole.log(b1 instanceof Object, b2 instanceof Object); //false true可以看到，由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。结语在今天的课程中，我帮你梳理了一些概念：有编程语言的概念闭包，也有各个版本中的 JavaScript 标准中的概念：执行上下文、作用域、this 值等等。之后我们又从代码的角度，分析了一些执行上下文中所需要的信息，并从var、let、对象字面量等语法中，推导出了词法作用域、变量作用域、Realm\b的设计。最后留给你一个问题：你喜欢使用 let 还是 var？转自—《重学前端》","link":"/2020/06/06/JavaScript执行（二）：闭包和执行上下文到底是怎么回事？/"},{"title":"JavaScript执行（四）：try里面放return，finally还会执行吗？","text":"在前面几篇文章中，我们已经了解了关于执行上下文、作用域、闭包之间的关系。 今天，我们则要说一说更为细节的部分：语句。 语句是任何编程语言的基础结构，与 JavaScript 对象一样，JavaScript 语句同样具有“看起来很像其它语言，但是其实一点都不一样”的特点。 我们比较常见的语句包括变量声明、表达式、条件、循环等，这些都是大家非常熟悉的东西，对于它们的行为，我在这里就不赘述了。 为了了解 JavaScript 语句有哪些特别之处，首先我们要看一个不太常见的例子，我会通过这个例子，来向你介绍 JavaScript 语句执行机制涉及的一种基础类型：Completion 类型。 Completion 类型 我们来看一个例子。在函数 foo 中，使用了一组 try 语句。我们可以先来做一个小实验，在 try 中有 return 语句，finally 中的内容还会执行吗？我们来看一段代码。1234567891011function foo(){ try{ return 0; } catch(err) { } finally { console.log(\"a\") }}console.log(foo());通过实际试验，我们可以看到，finally 确实执行了，而且 return 语句也生效了，foo() 返回了结果 0。虽然 return 执行了，但是函数并没有立即返回，又执行了 finally 里面的内容，这样的行为违背了很多人的直觉。如果在这个例子中，我们在 finally 中加入 return 语句，会发生什么呢？1234567891011function foo(){ try{ return 0; } catch(err) { } finally { return 1; }}console.log(foo());通过实际执行，我们看到，finally 中的 return “覆盖”了 try 中的 return。在一个函数中执行了两次 return，这已经超出了很多人的常识，也是其它语言中不会出现的一种行为。面对如此怪异的行为，我们当然可以把它作为一个孤立的知识去记忆，但是实际上，这背后有一套机制在运作。这一机制的基础正是 JavaScript 语句执行的完成状态，我们用一个标准类型来表示：Completion Record（我在类型一节提到过，Completion Record 用于描述异常、跳出等语句执行过程）。Completion Record 表示一个语句执行完之后的结果，它有三个字段： [[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型； [[value]] 表示语句的返回值，如果语句没有，则是 empty； [[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。接下来我们要来了解一下 JavaScript 使用 Completion Record 类型，控制语句执行的过程。首先我们来看看语句有几种分类。普通的语句在 JavaScript 中，我们把不带控制能力的语句称为普通语句。普通语句有下面几种。 声明类语句 var 声明 const 声明 let 声明 函数声明 类声明 表达式语句 空语句 debugger 语句这些语句在执行时，从前到后顺次执行（我们这里先忽略 var 和函数声明的预处理机制），没有任何分支或者重复执行逻辑。普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。如果你经常使用 chrome 自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上 var，就变成了 undefined。Chrome 控制台显示的正是语句的 Completion Record 的 [[value]]。语句块介绍完了普通语句，我们再来介绍一个比较特殊的语句：语句块。语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。语句块本身并不复杂，我们需要注意的是语句块内部的语句的 Completion Record 的 [[type]] 如果不为 normal，会打断语句块后续的语句执行。比如我们考虑，一个 [[type]] 为 return 的语句，出现在一个语句块中的情况。从语句的这个 type 中，我们大概可以猜到它由哪些特定语句产生，我们就来说说最开始的例子中的 return。return 语句可能产生 return 或者 throw 类型的 Completion Record。我们来看一个例子。先给出一个内部为普通语句的语句块：12345{ var i = 1; // normal, empty, empty i ++; // normal, 1, empty console.log(i) //normal, undefined, empty} // normal, undefined, empty在每一行的注释中，我给出了语句的 Completion Record。我们看到，在一个 block 中，如果每一个语句都是 normal 类型，那么它会顺次执行。接下来我们加入 return 试试看。123456{ var i = 1; // normal, empty, empty return i; // return, 1, empty i ++; console.log(i)} // return, 1, empty但是假如我们在 block 中插入了一条 return 语句，产生了一个非 normal 记录，那么整个 block 会成为非 normal。这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。接下来我们就具体讲讲控制类语句。控制型语句控制型语句带有 if、switch 关键字，它们会对不同类型的 Completion Record 产生反应。控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try。另一类是对外部造成影响如 break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟 break 、continue 、return 、throw 四种类型与控制语句两两组合产生的效果。通过这个表，我们不难发现知识的盲点，也就是我们最初的的 case 中的 try 和 return 的组合了。因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。带标签的语句前文我重点讲了 type 在语句控制中的作用，接下来我们重点来讲一下最后一个字段：target，这涉及了 JavaScript 中的一个语法，带标签的语句。实际上，任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：1firstStatement: var i = 1;大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环。123456outer: while(true) { inner: while(true) { break outer; }}console.log(\"finished\")break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它。结语我们以 Completion Record 类型为线索，为你讲解了 JavaScript 语句执行的原理。因为 JavaScript 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行， 树形结构的每一个节点执行后产生 Completion Record，根据语句的结构和 Completion Record，JavaScript 实现了各种分支和跳出逻辑。你遇到哪些语句中的执行的实际效果，是跟你想象的有所出入呢，你可以给我留言，我们一起讨论。转自—《重学前端》","link":"/2020/06/06/JavaScript执行（四）：try里面放return，finally还会执行吗？/"},{"title":"JavaScript类型：关于类型，有哪些你不知道的细节？","text":"这次我们来讲讲 JavaScript 的内容，在这个部分，我首先想跟你聊一聊类型。 JavaScript 类型对每个前端程序员来说，几乎都是最为熟悉的概念了。但是你真的很了解它们吗？我们不妨来看看下面的几个问题。 为什么有的编程规范要求用 void 0 代替 undefined？ 字符串有最大长度吗？ 0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？ ES6 新加入的 Symbol 是个什么东西？ 为什么给对象添加的方法能用在基本类型上？ 如果你答起来还有些犹豫的地方，这就说明你对这部分知识点，还是有些遗漏之处的。没关系，今天我来帮你一一补上。 我在前面提到过，我们的 JavaScript 模块会从运行时、文法和执行过程三个角度去剖析 JS 的知识体系，本篇我们就从运行时的角度去看 JavaScript 的类型系统。 运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都具有运行时类型。 类型 JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是： Undefined； Null； Boolean； String； Number； Symbol； Object。 除了 ES6 中新加入的 Symbol 类型，剩下 6 种类型都是我们日常开发中的老朋友了，但是，要想回答文章一开始的问题，我们需要重新认识一下这些老朋友，下面我们就来从简单到复杂，重新学习一下这些类型。 Undefined、Null 我们的第一个问题，为什么有的编程规范要求用 void 0 代替 undefined？现在我们就分别来看一下。 Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任一一个表达式变成 undefined 值。 但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。 Undefined 跟 null 有一定的表意差别，null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。 Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。 Boolean Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。这个类型很简单，我就不做过多介绍了。 String 我们来看看字符串是否有最大长度。 String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。 因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。 Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。 JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。 JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。 JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。 Number 下面，我们来说说 Number 类型。Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。 JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。 JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况： NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字； Infinity，无穷大； -Infinity，负无穷大。 另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。 根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。 同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：1console.log( 0.1 + 0.2 == 0.3);这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：1console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。SymbolSymbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。在后面的文章中，我会详细叙述 Symbol 跟对象系统。这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：1var mySymbol = Symbol(\"my symbol\");一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：12345678910111213var o = new Objecto[Symbol.iterator] = function() { var v = 0 return { next: function() { return { value: v++, done: v &gt; 10 } } } };for(var v of o) console.log(v); // 0 1 2 3 ... 9代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。ObjectObject 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。下面我们来看一看，为什么给对象添加的方法能用在基本类型上？在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。提到对象，我们必须要提到一个概念：类。因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：Number；String；Boolean；Symbol。所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：1console.log(\"abc\".charAt(0)); //a甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。12345Symbol.prototype.hello = () =&gt; console.log(\"hello\");var a = Symbol(\"a\");console.log(typeof a); //symbol，a 并非对象a.hello(); //hello，有效所以我们文章开头的问题，答案就是 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。类型转换讲完了基本类型，我们来介绍一个现象：类型转换。因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。其中最为臭名昭著的是 JS 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。StringToNumber字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：30；0b111；0o13；0xFF。此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：1e3；-1e-2。需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。NumberToString在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。具体的算法，你可以去参考 JavaScript 的语言标准。由于这个部分内容，我觉得在日常开发中很少用到，所以这里我就不去详细地讲解了。装箱转换每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：12345var symbolObject = (function(){ return this; }).call(Symbol(\"a\"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。12345var symbolObject = Object(Symbol(\"a\"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：123var symbolObject = Object(Symbol(\"a\"));console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。拆箱转换在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。123456789var o = { valueOf : () =&gt; {console.log(\"valueOf\"); return {}}, toString : () =&gt; {console.log(\"toString\"); return {}}}o * 2// valueOf// toString// TypeError我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o2 换成 String(o)，那么你会看到调用顺序就变了。123456789 var o = { valueOf : () =&gt; {console.log(\"valueOf\"); return {}}, toString : () =&gt; {console.log(\"toString\"); return {}} }String(o) // toString // valueOf // TypeError在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。1234567891011var o = { valueOf : () =&gt; {console.log(\"valueOf\"); return {}}, toString : () =&gt; {console.log(\"toString\"); return {}}}o[Symbol.toPrimitive] = () =&gt; {console.log(\"toPrimitive\"); return \"hello\"}console.log(o + \"\")// toPrimitive// hello结语在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。这里回顾一下今天讲解的知识点。除了这七种语言类型，还有一些语言的实现者更关心的规范类型。List 和 Record： 用于描述函数传参过程。Set：主要用于解释字符集等。Completion Record：用于描述异常、跳出等语句执行过程。Reference：用于描述对象属性访问、delete 等。Property Descriptor：用于描述对象的属性。Lexical Environment 和 Environment Record：用于描述变量和作用域。Data Block：用于描述二进制数据。有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。最后我们留一个实践问题，如果我们不用原生的 Number 和 parseInt，用 JS 代码实现 String 到 Number 的转换，该怎么做呢？请你把自己的代码留言给我吧！补充阅读事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JS 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。转自—《重学前端》","link":"/2020/06/06/JavaScript类型：关于类型，有哪些你不知道的细节？/"},{"title":"JavaScript词法：为什么12.toString会报错？","text":"文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。 词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。 从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。 概述 我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类： WhiteSpace 空白字符 LineTerminator 换行符 Comment 注释 Token 词 IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。 Punctuator 符号，我们使用的运算符和大括号等符号。 NumericLiteral 数字直接量，就是我们写的数字。 StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。 Template 字符串模板，用反引号` 括起来的直接量。 这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。 首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。 但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。 JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的： 1`Hello, ${name}` 理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。是否允许“ }”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义： InputElementDiv； InputElementRegExp； InputElementRegExpOrTemplateTail； InputElementTemplateTail。 为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为CommonToken。但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。 对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。 接下来我来给你详细介绍一下。 空白符号Whitespace 说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。 &lt;HT&gt;(或称&lt;TAB&gt;) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \\t 。 &lt;VT&gt;是 U+000B，也就是垂直方向的 TAB 符 \\v，这个字符在键盘上很难打出来，所以很少用到。 &lt;FF&gt;是 U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。 &lt;SP&gt;是 U+0020，就是最普通的空格了。 &lt;NBSP&gt;是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 &amp;nbsp; 最后生成的就是它了。 &lt;ZWNBSP&gt;(旧称&lt;BOM&gt;) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。 此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表： 很多公司的编码规范要求JavaScript 源代码控制在 ASCII 范围内，那么，就只有&lt;TAB&gt; &lt;VT&gt; &lt;FF&gt;&lt;SP&gt; &lt;NBSP&gt;五种空白可用了。换行符 LineTerminator接下来我们来看看换行符，JavaScript 中只提供了 4种字符作为换行符。 &lt;LF&gt; &lt;CR&gt; &lt;LS&gt; &lt;PS&gt; 其中， &lt;LF&gt;是 U+000A，就是最正常换行符，在字符串中的\\n。 &lt;CR&gt;是U+000D，这个字符真正意义上的“回车”，在字符串中是\\r，在一部分 Windows 风格文本编辑器中，换行是两个字符\\r\\n。 &lt;LS&gt;是U+2028，是 Unicode 中的行分隔符。 &lt;PS&gt;是 U+2029，是 Unicode 中的段落分隔符。 大部分 LineTerminator在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。 注释 Comment JavaScript的注释分为单行注释和多行注释两种： 12/* MultiLineCommentChars */// SingleLineCommentChars 多行注释中允许自由地出现MultiLineNotAsteriskChar，也就是除了之外的所有字符。而每一个之后，不能出现正斜杠符/。除了四种LineTerminator 之外，所有字符都可以作为单行注释。我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。 标识符名称 IdentifierName IdentifierName可以以美元符“$”、下划线“_”或者 Unicode字母开始，除了开始字符以外，IdentifierName中还可以使用 Unicode 中的连接标记、数字、以及连接符号。 IdentifierName的任意字符可以使用JavaScript 的 Unicode 转义写法，使用 Unicode转义写法时，没有任何字符限制。 IdentifierName可以是Identifier、NullLiteralBooleanLiteral或者keyword，在ObjectLiteral中，IdentifierName还可以被直接当做属性名称使用。 仅当不是保留字的时候，IdentifierName会被解析为Identifier。 注意&lt;ZWNJ&gt;和&lt;ZWJ&gt;是ES5 新加入的两个格式控制字符，它们都是 0 宽的。 我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有: 12await break case catch class const continue debugger default delete do else export extends finally for function ifimport ininstance of new return super switch this throw try typeof var void while with yield 除了上述的内容之外，还有 1 个为了未来使用而保留的关键字: 1enum 在严格模式下, 有一些额外的为未来使用而保留的关键字: 1implements package protected interface private public 除了这些之外，NullLiteral（null）和BooleanLiteral（true false）也是保留字，不能用于Identifier。符号 Punctuator因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为DivPunctuator，因为前面提到的字符串模板问题，}也被独立拆分。加在一起，所有符号为： 12{ ( ) [ ] . ... ; , &lt;&gt;&lt;=&gt;= == != === !== + - * % ** ++ -- &lt;&lt;&gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= } 数字直接量 NumericLiteral 我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。十进制的 Number可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子： 123.0112.12.01 这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码： 112.toString() 这时候12. 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写： 112 .toString() 数字直接量还支持科学计数法，例如： 1230xFA0o730b10000 这里 e 后面的部分，只允许使用整数。当以0x 0b 或者0o 开头时，表示特定进制的整数： 1230xFA0o730b10000 上面这几种进制都不支持小数，也不支持科学计数法。字符串直接量 StringLiteralJavaScript 中的 StringLiteral 支持单引号和双引号两种写法。 12\" DoubleStringCharacters \"' SingleStringCharacters ' 单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是\\和所有换行符。JavaScript中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。第一种是单字符转义。 即一个反斜杠\\后面跟一个字符这种形式。有特别意义的字符包括有SingleEscapeCharacter所定义的 9 种，见下表：除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过\\转义后都是自身。 正则表达式直接量 RegularExpressionLiteral 正则表达式由 Body 和Flags 两部分组成，例如： 1/RegularExpressionBody/g 其中 Body 部分至少有一个字符，第一个字符不能是 （因为 /跟多行注释有词法冲突）。正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。正则表达式并非机械地见到/就停止，在正则表达式[]中的/就会被认为是普通字符。我们可以看一个例子： 1/[/]/.test(\"/\"); 除了\\、/ 和[ 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。用\\和一个非换行符可以组成一个转义，[]中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。 字符串模板 Template 从语法结构上，Template 是个整体，其中的 ${ } 是并列关系。但是实际上，在JavaScript 词法中，包含 ${ } 的 Template，是被拆开分析的，如： 1`a${b}c${d}e` 它在 JavaScript 中被认为是： 12345`a${b}c${d}e` 它被拆成了五个部分： a${&lt;/code&gt; 这个被称为模板头&lt;/li&gt; &lt;li&gt;&lt;code&gt;}c${&lt;/code&gt; 被称为模板中段&lt;/li&gt; &lt;li&gt;&lt;code&gt;}e 被称为模板尾 b 和 d 都是普通标识符 实际上，这里的词法分析过程已经跟语法分析深度耦合了。不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数： 123456function f(){console.log(arguments);}var a = \"world\"f`Hello ${a}!`; // [[\"Hello\", \"!\"], world] 模板字符串不需要关心大多数字符的转义，但是至少 ${ 和 ` 还是需要处理的。模板中的转义跟字符串几乎完全一样，都是使用 \\。 总结 今天我们一起学习 JavaScript的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。最后，留一个问题：用零宽空格和零宽连接符、零宽非连接符，写一段好玩的代码。","link":"/2020/06/06/JavaScript词法：为什么12.toString会报错？/"},{"title":"JavaScript语法（预备篇）：到底要不要写分号呢？","text":"在我们介绍 JavaScript 语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。 这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。 实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。 但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。 这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。 我们首先来了解一下自动插入分号的规则。 自动插入分号规则 自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。 这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：1234let a = 1void function(a){ console.log(a);}(a);在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入换行符。123456var a = 1, b = 1, c = 1;a++b++c这也是个著名的例子，我们看第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有 [no LineTerminator here] 这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容：123456UpdateExpression[Yield, Await]: LeftHandSideExpression[?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++ LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]-- ++UnaryExpression[?Yield, ?Await] --UnaryExpression[?Yield, ?Await]于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。123456(function(a){ console.log(a);})()(function(a){ console.log(a);})()这个例子是比较有实际价值的例子，这里两个 function 调用的写法被称作 IIFE（立即执行的函数表达式），是个常见技巧。这段代码意图上显然是形成两个 IIFE。我们来看第三行结束的位置，JavaScript 引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。这是一些鼓励不写分号的编码风格会要求大家写 IIFE 时必须在行首加分号的原因。123456function f(){ return/* This is a return value. */1;}f();在这个例子中，return 和 1 被用注释分隔开了。根据 JavaScript 自动插入分号规则，带换行符的注释也被认为是有换行符，而恰好的是，return 也有 [no LineTerminator here] 规则的要求。所以这里会自动插入分号，f 执行的返回值是 undefined。no LineTerminator here 规则好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对 JavaScript 的语法定义做一些数据挖掘工作。no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟 no LineTerminator here 规则强相关，那么我们就找出 JavaScript 语法定义中的这些规则。为了方便你理解，我把产生式换成了实际的代码。下面一段代码展示了，带标签的 continue 语句，不能在 continue 后插入换行。123outer:for(var j = 0; j &lt; 10; j++) for(var i = 0; i &lt; j; i++) continue /*no LineTerminator here*/ outterbreak 跟 continue 是一样的，break 后也不能插入换行：123outer:for(var j = 0; j &lt; 10; j++) for(var i = 0; i &lt; j; i++) break /*no LineTerminator here*/ outter我们前面已经提到过 return 和后自增、后自减运算符。123function f(){ return /*no LineTerminator here*/1;}12i/*no LineTerminator here*/++i/*no LineTerminator here*/--以及，throw 和 Exception 之间也不能插入换行符：1throw/*no LineTerminator here*/new Exception(\"error\")凡是 async 关键字，后面都不能插入换行符：1234async/*no LineTerminator here*/function f(){}const f = async/*no LineTerminator here*/x =&gt; x*x箭头函数的箭头前，也不能插入换行：1const f = x/*no LineTerminator here*/=&gt; x*xyield 之后，不能插入换行：12345function *g(){ var i = 0; while(true) yield/*no LineTerminator here*/i++;}到这里，我已经整理了所有标准中的 no LineTerminator here 规则，实际上，no LineTerminator here 规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript 在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。不写分号需要注意的情况下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。以括号开头的语句我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：123456(function(a){ console.log(a);})()/* 这里没有被自动插入分号 */(function(a){ console.log(a);})()这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。以数组开头的语句除了括号，以数组开头的语句也十分危险：12var a = [[]]/* 这里没有被自动插入分号 */[3, 2, 1, 0].forEach(e =&gt; console.log(e))这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。以正则表达式开头的语句正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。123var x = 1, g = {test:()=&gt;0}, b = 1/* 这里没有被自动插入分号 *//(a)/g.test(\"abc\")console.log(RegExp.$1)这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。以 Template 开头的语句以 Template 开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：123456var f = function(){ return \"\";}var g = f/* 这里没有被自动插入分号 */`Template`.match(/(a)/);console.log(RegExp.$1)这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。总结这一节课，我们讨论了要不要加分号的问题。首先我们介绍了自动插入分号机制，又对 JavaScript 语法中的 no line terminator 规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。最后留一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号。","link":"/2020/06/06/JavaScript语法（预备篇）：到底要不要写分号呢？/"},{"title":"PHP知识点积累","text":"1、关于$_FILES 处理文件上传2、数组的定义和遍历3、关于命名空间的简单介绍","link":"/2020/06/06/PHP知识点积累/"},{"title":"Vue 组件间的通信（六种）","text":"组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。 针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。 本文总结了vue组件间通信的几种方式，如props、$emit/$on、vuex、$parent / $children、$attrs/$listeners和provide/inject，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。 方案一：props/$emit父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。 1.父组件向子组件传值 接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;] 12345678910111213141516171819//App.vue父组件&lt;template&gt; &lt;div id=\"app\"&gt; &lt;users v-bind:users=\"users\"&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Users from \"./components/Users\"export default { name: 'App', data(){ return{ users:[\"Henry\",\"Bucky\",\"Emily\"] } }, components:{ \"users\":Users }} 12345678910111213141516171819//users子组件&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;ul&gt; &lt;li v-for=\"user in users\"&gt;{{user}}&lt;/li&gt;//遍历传递过来的值，然后呈现到页面 &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'HelloWorld', props:{ users:{ //这个就是父组件中子标签自定义名字 type:Array, required:true } }}&lt;/script&gt; 总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 2.子组件向父组件传值（通过事件形式） 接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。 123456789101112131415161718192021// 子组件&lt;template&gt; &lt;header&gt; &lt;h1 @click=\"changeTitle\"&gt;{{title}}&lt;/h1&gt;//绑定一个点击事件 &lt;/header&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'app-header', data() { return { title:\"Vue.js Demo\" } }, methods:{ changeTitle() { this.$emit(\"titleChanged\",\"子向父组件传值\");//自定义事件 传递值“子向父组件传值” } }}&lt;/script&gt; 123456789101112131415161718192021222324252627// 父组件&lt;template&gt; &lt;div id=\"app\"&gt; &lt;app-header v-on:titleChanged=\"updateTitle\" &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致 // updateTitle($event)接受传递过来的文字 &lt;h2&gt;{{title}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Header from \"./components/Header\"export default { name: 'App', data(){ return{ title:\"传递的是一个值\" } }, methods:{ updateTitle(e){ //声明这个函数 this.title = e; } }, components:{ \"app-header\":Header, }}&lt;/script&gt; 总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。 方案二：$emit/$on这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。 1.具体实现方式：123var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data =&gt; {}); 2.举个例子： 假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;div id=\"itany\"&gt; &lt;my-a&gt;&lt;/my-a&gt; &lt;my-b&gt;&lt;/my-b&gt; &lt;my-c&gt;&lt;/my-c&gt;&lt;/div&gt;&lt;template id=\"a\"&gt; &lt;div&gt; &lt;h3&gt;A组件：{{name}}&lt;/h3&gt; &lt;button @click=\"send\"&gt;将数据发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"b\"&gt; &lt;div&gt; &lt;h3&gt;B组件：{{age}}&lt;/h3&gt; &lt;button @click=\"send\"&gt;将数组发送给C组件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"c\"&gt; &lt;div&gt; &lt;h3&gt;C组件：{{name}}，{{age}}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var Event = new Vue();//定义一个空的Vue实例var A = { template: '#a', data() { return { name: 'tom' } }, methods: { send() { Event.$emit('data-a', this.name); } }}var B = { template: '#b', data() { return { age: 20 } }, methods: { send() { Event.$emit('data-b', this.age); } }}var C = { template: '#c', data() { return { name: '', age: \"\" } }, mounted() {//在模板编译完成后执行 Event.$on('data-a',name =&gt; { this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event }) Event.$on('data-b',age =&gt; { this.age = age; }) }}var vm = new Vue({ el: '#itany', components: { 'my-a': A, 'my-b': B, 'my-c': C }}); &lt;/script&gt; $on 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。 方案三：vuex 1.简要介绍Vuex原理 Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。 而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。 2.简要介绍各模块在流程中的功能： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法，由actions中的commit(‘mutation 名称’)来触发。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 3.Vuex与localStorage vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state 1234567891011121314151617181920let defaultCity = \"上海\"try { // 用户关闭了本地存储功能，此时在外层加个try...catch if (!defaultCity){ defaultCity = JSON.parse(window.localStorage.getItem('defaultCity')) }}catch(e){}export default new Vuex.Store({ state: { city: defaultCity }, mutations: { changeCity(state, city) { state.city = city try { window.localStorage.setItem('defaultCity', JSON.stringify(state.city)); // 数据改变的时候把数据拷贝一份保存到localStorage里面 } catch (e) {} } }}) 这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换 12JSON.stringify(state.subscribeList); // array -&gt; stringJSON.parse(window.localStorage.getItem(\"subscribeList\")); // string -&gt; array 方案四：$attrs/$listeners1.简介 多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-$attrs/$listeners $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。 $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件 2.例子 123456789101112131415161718192021222324252627// index.vue&lt;template&gt; &lt;div&gt; &lt;h2&gt;浪里行舟&lt;/h2&gt; &lt;child-com1 :foo=\"foo\" :boo=\"boo\" :coo=\"coo\" :doo=\"doo\" title=\"前端工匠\" &gt;&lt;/child-com1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom1 = () =&gt; import(\"./childCom1.vue\");export default { components: { childCom1 }, data() { return { foo: \"Javascript\", boo: \"Html\", coo: \"CSS\", doo: \"Vue\" }; }};&lt;/script&gt; 1234567891011121314151617181920212223// childCom1.vue&lt;template class=\"border\"&gt; &lt;div&gt; &lt;p&gt;foo: {{ foo }}&lt;/p&gt; &lt;p&gt;childCom1的$attrs: {{ $attrs }}&lt;/p&gt; &lt;child-com2 v-bind=\"$attrs\"&gt;&lt;/child-com2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import(\"./childCom2.vue\");export default { components: { childCom2 }, inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: { foo: String // foo作为props属性绑定 }, created() { console.log(this.$attrs); // { \"boo\": \"Html\", \"coo\": \"CSS\", \"doo\": \"Vue\", \"title\": \"前端工匠\" } }};&lt;/script&gt; 1234567891011121314151617181920212223// childCom2.vue&lt;template&gt; &lt;div class=\"border\"&gt; &lt;p&gt;boo: {{ boo }}&lt;/p&gt; &lt;p&gt;childCom2: {{ $attrs }}&lt;/p&gt; &lt;child-com3 v-bind=\"$attrs\"&gt;&lt;/child-com3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom3 = () =&gt; import(\"./childCom3.vue\");export default { components: { childCom3 }, inheritAttrs: false, props: { boo: String }, created() { console.log(this.$attrs); // { \"coo\": \"CSS\", \"doo\": \"Vue\", \"title\": \"前端工匠\" } }};&lt;/script&gt; 1234567891011121314// childCom3.vue&lt;template&gt; &lt;div class=\"border\"&gt; &lt;p&gt;childCom3: {{ $attrs }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { props: { coo: String, title: String }};&lt;/script&gt; 如上图所示$attrs表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了$attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。 简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。 方案五：provide/inject1.简介 Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 2.例子假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件 123456// A.vueexport default { provide: { name: '浪里行舟' }} 1234567// B.vueexport default { inject: ['name'], mounted () { console.log(this.name); // 浪里行舟 }} 可以看到，在 A.vue 里，我们设置了一个 provide: name，值为 浪里行舟，它的作用就是将 name 这个变量提供给它的所有子组件。而在 B.vue 中，通过 inject 注入了从 A 组件中提供的 name 变量，那么在组件 B 中，就可以直接通过 this.name 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。 需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的—-vue官方文档所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。 3.provide与inject 怎么实现数据响应式 一般来说，有两种办法： provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods 使用2.6最新API Vue.observable 优化响应式 provide(推荐) 我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// A 组件 &lt;div&gt; &lt;h1&gt;A 组件&lt;/h1&gt; &lt;button @click=\"() =&gt; changeColor()\"&gt;改变color&lt;/button&gt; &lt;ChildrenB /&gt; &lt;ChildrenC /&gt;&lt;/div&gt;...... data() { return { color: \"blue\" }; }, // provide() { // return { // theme: { // color: this.color //这种方式绑定的数据并不是可响应的 // } // 即A组件的color变化后，组件D、E、F不会跟着变 // }; // }, provide() { return { theme: this//方法一：提供祖先组件的实例 }; }, methods: { changeColor(color) { if (color) { this.color = color; } else { this.color = this.color === \"blue\" ? \"red\" : \"blue\"; } } } // 方法二:使用2.6最新API Vue.observable 优化响应式 provide // provide() { // this.theme = Vue.observable({ // color: \"blue\" // }); // return { // theme: this.theme // }; // }, // methods: { // changeColor(color) { // if (color) { // this.theme.color = color; // } else { // this.theme.color = this.theme.color === \"blue\" ? \"red\" : \"blue\"; // } // } // } 虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！ 方案六：$parent / $children与 ref ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 ref来访问组件的例子： 12345678910111213// component-a 子组件export default { data () { return { title: 'Vue.js' } }, methods: { sayHello () { window.alert('Hello'); } }} 12345678910111213// 父组件&lt;template&gt; &lt;component-a ref=\"comA\"&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt; export default { mounted () { const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 } }&lt;/script&gt; 不过，这两种方法的弊端是，无法在跨级或兄弟间通信。 1234// parent.vue&lt;component-a&gt;&lt;/component-a&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;component-b&gt;&lt;/component-b&gt; 我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。 总结常见使用场景可以分为三类： 父子通信：父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 / 子链也可以通信（$parent / $children）；ref 也可以访问组件实例；provide / inject API；$attrs/$listeners 兄弟通信：Bus；Vuex 跨级通信：Bus；Vuex；provide / inject API、$attrs/$listeners","link":"/2020/06/06/Vue 组件间的通信（六种）/"},{"title":"node.js学习记录","text":"–node.js入门","link":"/2020/06/06/node.js学习记录/"},{"title":"PHP mysql数据库面向对象简单操作类（增删改查）、分页类和图片验证码类的封装","text":"这篇文章中已经介绍了PHP连接数据库的方法以及最基本的对数据库的操作，但并没有实现模块化，所有的代码全都集中在表现页面中，造成了代码冗余，不仅不利于维护也不利于代码的重用性，那么在这篇文章中将用面向对象的知识对数据库的连接和基本操作方法进行封装，也简单地对地分页功能进行了封装，这样就大大避免了代码的重复。 以下文件放置于space文件夹中 一、封装简单的数据库的增删改查等函数 libs/Db文件夹 1、先写一个db.config.php文件来使用里面是你数据库的信息 123456789&lt;?phpreturn array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'password' =&gt; 'root', 'port' =&gt; '3306', 'dbname' =&gt; 'test', 'charset' =&gt; 'utf8'); 2、通过Idb.class.php文件来定义接口 12345678910&lt;?phpnamespace libs\\Db; //引入命名空间interface Idb { public function add(); public function getOne(); public function getList(); public function update(); public function delete(); public function count();} 什么是命名空间 3、通过Mysql.class.php来封装接口的各个功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;?phpnamespace libs\\Db;class Mysql implements Idb { private $_link = NULL; private $_debug = false; private $_where = NULL; private $_table = NULL; private $_data = NULL; private $_fields = NULL; private $_limit=NULL; private $_order = NULL; private static $_instance = NULL; private function __construct() { if ( $this-&gt;_link == NULL ) { $this-&gt;connect(); } } public static function init() { if ( self::$_instance == NULL ) { self::$_instance = new self(); } return self::$_instance; } private function excute($sql) //执行sql语句 { if ( $this-&gt;_debug == true ) { echo \"EXCUTE SQL: {$sql} &lt;br/&gt;\"; } $ret = $this-&gt;_link-&gt;query($sql); return $ret; } public function setDebug( $debug = true ) //调试函数 { $this-&gt;_debug = $debug; } private function connect() //连接数据库 { $conf = require_once 'db.config.php'; $this-&gt;_link = new \\mysqli($conf['host'], $conf['user'], $conf['password'], $conf['dbname'],$conf['port']); if ($this-&gt;_link-&gt;connect_error) { die('Connect Error (' . $this-&gt;_link-&gt;connect_errno . ') ' . $this-&gt;_link-&gt;connect_error); } date_default_timezone_set('PRC'); //设时区 $this-&gt;_link-&gt;query(\"SET NAME {$conf['charset']}\"); } public function table( $table ) //获取表 { $this-&gt;_table = $table; return $this; } public function where($where= NULL) { $this-&gt;_where = $where; return $this; } public function data($data) { $this-&gt;_data = $data; return $this; } public function field($fields){ $this-&gt;_fields = $fields; return $this; } public function order($order){ $this-&gt;_order = $order; return $this; } public function limit($limit){ $this-&gt;_limit = $limit; return $this; } public function add() //添加数据 { $sql = \"INSERT INTO {$this-&gt;_table} (\"; $fields = \"\"; $values = \"\"; foreach( $this-&gt;_data as $key =&gt; $val ) { if ( $fields == \"\" ) $fields = $key; else $fields .= \",\".$key; if ( $values == \"\" ) $values = \"'{$val}'\"; else $values .= \",\".\"'{$val}'\"; } $sql .= \"{$fields} )VALUES({$values})\"; $ret = $this-&gt;excute($sql); return $ret; } public function getOne() //获取一组数据 { //select id,name from table where id = 10 if ( is_array($this-&gt;_fields) ) $fields = implode(',', $fields); $sql = \"SELECT {$this-&gt;_fields} FROM {$this-&gt;_table}\"; if ( $this-&gt;_where != NULL ) $sql .= \" WHERE {$this-&gt;_where}\"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row; } public function getList() //获取多组数据 { //select id,name from table where id &gt; 10 //若查询字段为一维数组，以,拼接为目标字符串 if ( is_array($this-&gt;_fields) ) $this-&gt;_fields = implode(',', $this-&gt;_fields); $sql = \"SELECT {$this-&gt;_fields} FROM {$this-&gt;_table}\"; if ( $this-&gt;_where != NULL ) $sql .= \" WHERE {$this-&gt;_where}\"; if ($this-&gt;_order !=NULL) $sql .= \" ORDER BY {$this-&gt;_order}\"; if ( $this-&gt;_limit != NULL ) $sql .= \" LIMIT {$this-&gt;_limit}\"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $result = []; while ( ($row = $ret-&gt;fetch_assoc()) != false) { $result[] = $row; } return $result; } public function update() //更新数据 { //update table set name = \"wein\" where id = 1 $sql = \"UPDATE {$this-&gt;_table} SET \"; $fields = \"\"; foreach( $this-&gt;_data as $key =&gt; $val ) { if ( $fields == \"\" ) $fields = \"{$key}='{$val}'\"; else $fields .= \",\".\"{$key}='{$val}'\"; } if ( $this-&gt;_where != NULL ) $sql .= \"{$fields} WHERE {$this-&gt;_where}\"; else $sql .= \"{$fields}\"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $row = $this-&gt;_link-&gt;affected_rows; if ( $row == 0 ) return false; return true; } public function delete()//删除数据 { //拼接sql语句 //delete from table where id =1 $sql = \"DELETE FROM {$this-&gt;_table} WHERE {$this-&gt;_where}\"; $ret = $this-&gt;excute($sql); return $ret; } public function count() //统计数据 { $sql = \"SELECT COUNT({$this-&gt;_fields}) AS num FROM {$this-&gt;_table}\"; if ( $this-&gt;_where != NULL ) $sql .= \" WHERE {$this-&gt;_where}\"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row['num']; } public function __destruct() //断开数据库连接 { $this-&gt;_link-&gt;close(); $this-&gt;_link = NULL; } } 二、分页类的封装 libs/Page文件夹 1、通过Page.class.php文件来封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpnamespace libs\\Page;class Page { private $_totals = 0; private $_pagesize = 0; public function __construct( $pagesize, $total ) { $this-&gt;_totals = $total; $this-&gt;_pagesize = $pagesize; } public function getoffset() //获取展示下一页开始的id值 { $page = isset($_GET['page'])?$_GET['page']:1; $offset = ($page -1) * $this-&gt;_pagesize; return $offset; } public function show($left = 2) { $page = isset($_GET['page'])?$_GET['page']:1; $totalPages = ceil($this-&gt;_totals / $this-&gt;_pagesize); $html = '&lt;ul class=\"page-ui-box\"&gt;'; if ( $page &gt; 1 ){ $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page=1\"&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.($page-1).'\"&gt;上一页&lt;/a&gt;&lt;/li&gt;'; } else { $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;上一页&lt;/a&gt;&lt;/li&gt;'; } //当前页的前面显示两个数字页面 $start = ($page - $left); if ( $start &lt;= 0 ) $start = 1; for( $i = $start; $i &lt; $page; $i++ ) { $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.$i.'\"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; } $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;'.$page.'&lt;/a&gt;&lt;/li&gt;'; //当前页的后面显示两个数字页面 $end = $page + 2; if ( $end &gt; $totalPages ) $end = $totalPages; for( $i = $page + 1; $i &lt;= $end; $i++ ) { $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.$i.'\"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; } if ( $page &lt; $totalPages ) { $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.($page+1).'\"&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.$totalPages.'\"&gt;尾页&lt;/a&gt;&lt;/li&gt;'; } else { $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;尾页&lt;/a&gt;&lt;/li&gt;'; } $html .= '&lt;/ul&gt;'; return $html; }}?&gt; 2、样式文件Page-ui.css 12345678910* {margin: 0px;padding: 0px;}ul, li {list-style: none;}.page-ui-box {overflow: hidden;border-left: 1px solid #CCC;}.page-ui-box li {float: left;padding: 5px 25px;height: 30px;line-height: 30px;border: 1px solid #CCC;border-left:none;cursor: pointer;}.unable {background: #EEE;}.page-ui-box a {text-decoration: none;}.able a {color: blue;}.able a:hover {text-decoration: underline;}table{border-collapse:collapse; border-spacing:0; border-left:1px solid #aaa; border-top:1px solid #aaa; }td{border-right:1px solid #aaa; border-bottom:1px solid #aaa; padding:3px 15px; text-align:left; color:#3C3C3C;} 三、图片验证码类的封装 libs/Verify文件夹 1、Verify.class.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?php namespace libs\\Verify;class Verify{ private $width=100; private $height=30; private $content=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; private $num=4; private $point=100; private $line= 4; public function __construct(){ } public function show(){ /** * 字母+数字的验证码生成 */ // 开启session session_start(); //1.创建黑色画布 $image = imagecreatetruecolor($this-&gt;width, $this-&gt;height); //2.为画布定义(背景)颜色 $bgcolor = imagecolorallocate($image, 255, 255, 255); //3.填充颜色 imagefill($image, 0, 0, $bgcolor); // 4.设置验证码内容 //4.1 定义验证码的内容 //4.1 创建一个变量存储产生的验证码数据，便于用户提交核对 $captcha = \"\"; for ($i = 0; $i &lt; $this-&gt;num; $i++) { // 字体大小 $fontsize = 5; // 字体颜色 随机生成字体颜色 $fontcolor = imagecolorallocate($image, mt_rand(0, 120), mt_rand(0, 120), mt_rand(0, 120)); // 设置字体内容 $fontcontent = substr($this-&gt;content, mt_rand(0, strlen($this-&gt;content)), 1); $captcha .= $fontcontent; // 显示的坐标 $x = ($i * $this-&gt;width / $this-&gt;num) + mt_rand(5, 10); $y = mt_rand($this-&gt;height/3, $this-&gt;height/2); // 填充内容到画布中 imagestring($image, $fontsize, $x, $y, $fontcontent, $fontcolor); } $_SESSION[\"captcha\"] = $captcha; //4.3 设置背景干扰元素 for ($i = 0; $i &lt; $this-&gt;point; $i++) { $pointcolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imagesetpixel($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $pointcolor); } //4.4 设置干扰线 for ($i = 0; $i &lt; $this-&gt;line; $i++) { $linecolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imageline($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $linecolor); } return $image; //6.输出图片到浏览器 // imagepng($image); //7.销毁图片 // imagedestroy($image); } public function width($width) //设置验证码图片的宽度 { $this-&gt;width=$width; return $this; } public function height($height) //设置验证码图片的高度 { $this-&gt;height=$height; return $this; } public function setLine($line) //设置验证码图片的干扰线数量 { $this-&gt;line=$line; return $this; } public function setNum($num) // 设置验证码的位数 { $this-&gt;num=$num; return $this; } public function setChars($content) //设置验证码出现的字符集， 比如设置 123456789,那么验证码中出现的字符只能是这个字符串中的某几个 { $this-&gt;content=$content; return $this; } public function setPoint($point) // 设置验证码图片中出现的杂点数量 { $this-&gt;point=$point; return $this; }}?&gt; 2、Verify类的实例verify.php： 12345678910111213141516171819&lt;?php//5.向浏览器输出图片头信息 header('content-type:image/png');spl_autoload_register(function($class){ //$class = libs\\Db\\Mysql //libs\\Db\\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;}); use libs\\Verify\\Verify; $verify=new Verify(); $char=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; $verifyhtml=$verify-&gt;width(200)-&gt;height(80)-&gt;setLine(6)-&gt;setNum(6)-&gt;setChars($char)-&gt;setPoint(500)-&gt;show(); //链式操作 //6.输出图片到浏览器 imagepng($verifyhtml); //7.销毁图片 imagedestroy($verifyhtml);?&gt; 四、运用实例这里通过start.php文件来运用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php//namespace \"上级文件夹名称\"// require_once 'libs/Db/Mysql.class.php';//引入命名空间spl_autoload_register(function($class){ //$class = libs\\Db\\Mysql //libs\\Db\\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;}); use libs\\Db\\Mysql; use libs\\Page\\Page; $db = Mysql::init(); //新建Mysql对象 $totals = $db-&gt;table(\"contact\")-&gt;field(\"id\")-&gt;count(); $pagesize = 3; //每一页显示的数据条数 $page = new Page($pagesize,$totals); //新建Page对象 $pagehtml = $page-&gt;show(); $left = $page-&gt;getoffset(); $db-&gt;setDebug(true); $data=$db-&gt;table(\"contact\")-&gt;where(NULL)-&gt;field(\"*\")-&gt;order(\"id desc\")-&gt;limit(\"{$left},{$pagesize}\")-&gt;getList(); //链式操作 // $data = $db-&gt;getList('contact', NULL,\"*\", 'id desc', \"{$left}, {$pagesize}\"); // var_dump($data);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"libs/Page/page-ui.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;工作&lt;/td&gt; &lt;td&gt;QQ&lt;/td&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;留言内容&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach ($data as $key =&gt; $val) { ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$val['id']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['userName']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['job']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['qqnum']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['phone']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['remark']?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php } ?&gt; &lt;/table&gt; &lt;?=$pagehtml?&gt; &lt;!-- 显示分页样式 --&gt; &lt;img src=\"http://localhost/space/verify.php\" onclick=\"resetPic(this)\"&gt; &lt;!-- 显示图片验证码 --&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function resetPic(obj) { $(obj).attr('src', \"http://localhost/space/verify.php\"); //点击二维码刷新 } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附：本人建立test数据库contact表的sql文件： 123456789use test; create table contact( id int primary key auto_increment, userName char(20) not null unique, job char(10) not null, qqnum char(10) not null, phone char(100), remark text );","link":"/2020/06/06/php mysql数据库面向对象简单操作类（增删改查）、分页类和图片验证码类的封装/"},{"title":"vue常见问题及解决方法（一）","text":"列表进入详情页的传参问题 路由懒加载（也叫延迟加载） 列表进入详情页的传参问题关联知识点 ——路由跳转的方式声明式的跳转： 1234// query通过path切换路由&lt;router-link :to=\"{path: 'Detail', query: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=\"{name: 'Detail', params: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt; 编程式的跳转： 12345678910111213//跳转到上一次浏览的页面 this.$router.go(-1) //指定跳转的地址，我们自己设置的路由地址this.$router.replace('/pathname') //指定跳转路由的名字下，pathname是我们自身为路由设置的名字this.$router.replace({name:\"pathname\"}) //通过push进行跳转，我们自己设置的路由地址或者我们自己设置的名字this.$router.push('/pathname')this.$router.push({name:'pathname'})this.$router.push({ path: '/pathname/${id}'}) //id为参数 传参的方式：query、params+动态路由传参 两者的区别： query通过path切换路由，params通过name切换路由 1234// query通过path切换路由&lt;router-link :to=\"{path: 'Detail', query: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=\"{name: 'Detail', params: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt; query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。 12345678// query通过this.$route.query接收参数created () { const id = this.$route.query.id;}// params通过this.$route.params来接收参数created () { const id = this.$route.params.id;} query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数 params＋动态路由的url方式：/detail/123 params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面，而query传参则不用： 对应的路由配置： 12345{ path: '/detail/:id', name: 'Detail', component: Detail }, 注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如： 1234567891011121314151617// 定义的路由中，只定义一个id参数{ path: 'detail/:id', name: 'Detail', components: Detail} // template中的路由传参，// 传了一个id参数和一个token参数// id是在路由中已经定义的参数，而token没有定义&lt;router-link :to=\"{name: 'Detail', params: { id: 1, token: '123456' }}\"&gt;前往Detail页面&lt;/router-link&gt;// 在详情页接收created () { // 以下都可以正常获取到 // 但是页面刷新后，id依然可以获取，而token此时就不存在了 const id = this.$route.params.id; const token = this.$route.params.token;} 参考： vue路由传参的三种基本方式 vue 关于路由跳转方法 路由懒加载（也叫延迟加载）路由懒加载可以帮我们在进入首屏时不用加载过度的资源，从而减少首屏加载速度。在路由文件中， 非懒加载写法： 12345678910import Index from '@/page/index/index';export default new Router({ routes: [ { path: '/', name: 'Index', component: Index } ]}) 路由懒加载写法： 123456789export default new Router({ routes: [ { path: '/', name: 'Index', component: resolve =&gt; require(['@/view/index/index'], resolve) } ]})","link":"/2020/06/06/vue常见问题及解决方法（一）/"},{"title":"vue中axios的封装和API接口的管理","text":"一、axios的封装在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步axios文档。 安装1npm install axios; // 安装axios 引入一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。12345// 在http.js中引入axiosimport axios from 'axios'; // 引入axiosimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到// vant的toast提示框组件，大家可根据自己的ui组件更改。import { Toast } from 'vant'; 环境的切换我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。 123456789// 环境的切换if (process.env.NODE_ENV == 'development') { axios.defaults.baseURL = 'https://www.baidu.com';} else if (process.env.NODE_ENV == 'debug') { axios.defaults.baseURL = 'https://www.ceshi.com';} else if (process.env.NODE_ENV == 'production') { axios.defaults.baseURL = 'https://www.production.com';} 设置请求超时通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。 1axios.defaults.timeout = 10000; post请求头的设置post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; 请求拦截我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。 12345678910111213141516// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from '@/store/index';// 请求拦截器axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); }) 这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。 然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊。 响应的拦截1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 响应拦截器axios.interceptors.response.use( response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; { if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast({ message: '登录过期，请重新登录', duration: 1000, forbidClick: true }); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: Toast({ message: '网络请求不存在', duration: 1500, forbidClick: true }); break; // 其他错误，直接抛出错误提示 default: Toast({ message: error.response.data.message, duration: 1500, forbidClick: true }); } return Promise.reject(error.response); } } }); 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。 要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。 封装get方法和post方法我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post。 get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数 123456789101112131415/** * get方法，对应get请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function get(url, params){ return new Promise((resolve, reject) =&gt;{ axios.get(url, { params: params }).then(res =&gt; { resolve(res.data); }).catch(err =&gt;{ reject(err.data) }) });} post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from 'qs';的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。 12345678910111213141516/** * post方法，对应post请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function post(url, params) { return new Promise((resolve, reject) =&gt; { axios.post(url, QS.stringify(params)) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt;{ reject(err.data) }) });} 这里有个小细节说下，axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！ 二、api的统一管理整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。上面说了，我们会新建一个api.js,然后在这个文件中存放我们所有的api接口。 首先我们在api.js中引入我们封装的get和post方法 1234/** * api接口统一管理 */import { get, post } from './http' 现在，例如我们有这样一个接口，是一个post请求： 1http://www.baiodu.com/api/v1/users/my_address/address_edit_before 我们可以在api.js中这样封装： 1export const apiAddress = p =&gt; post('api/v1/users/my_address/address_edit_before', p); 我们定义了一个apiAddress方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的post方法，post方法的第一个参数是我们的接口地址，第二个参数是apiAddress的p参数，即请求接口时携带的参数对象。最后通过export导出apiAddress。 然后在我们的页面中可以这样调用我们的api接口： 1234567891011121314151617181920import { apiAddress } from '@/request/api';// 导入我们的api接口export default { name: 'Address', created () { this.onLoad(); }, methods: { // 获取数据 onLoad() { // 调用api接口，并且提供了两个参数 apiAddress({ type: 0, sort: 1 }).then(res =&gt; { // 获取数据成功后的其他操作 ……………… }) } }} 其他的api接口，就在pai.js中继续往下面扩展就可以了。 友情提示，为每个接口写好注释哦！！！api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就规格gg了。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。 好了，最后把完成的axios封装代码奉上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/**axios封装 * 请求拦截、相应拦截、错误统一处理 */import axios from 'axios';import QS from 'qs';import { Toast } from 'vant';import store from '../store/index'// 环境的切换if (process.env.NODE_ENV == 'development') { axios.defaults.baseURL = '/api';} else if (process.env.NODE_ENV == 'debug') { axios.defaults.baseURL = '';} else if (process.env.NODE_ENV == 'production') { axios.defaults.baseURL = 'http://api.123dailu.com/';}// 请求超时时间axios.defaults.timeout = 10000;// post请求头axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';// 请求拦截器axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); })// 响应拦截器axios.interceptors.response.use( response =&gt; { if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是200的情况 error =&gt; { if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast({ message: '登录过期，请重新登录', duration: 1000, forbidClick: true }); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: Toast({ message: '网络请求不存在', duration: 1500, forbidClick: true }); break; // 其他错误，直接抛出错误提示 default: Toast({ message: error.response.data.message, duration: 1500, forbidClick: true }); } return Promise.reject(error.response); } });/** * get方法，对应get请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function get(url, params){ return new Promise((resolve, reject) =&gt;{ axios.get(url, { params: params }) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt; { reject(err.data) }) });}/** * post方法，对应post请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function post(url, params) { return new Promise((resolve, reject) =&gt; { axios.post(url, QS.stringify(params)) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt; { reject(err.data) }) });} 优化axios的封装根据需求的不同而不同。我也对此进行了思考和针对不同需求的改善。主要有以下改变： 优化axios封装，去掉之前的get和post 断网情况处理 更加模块化的api管理 接口域名有多个的情况 api挂载到vue.prototype上省去引入的步骤 http.js中axios封装的优化，先直接贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from 'axios';import router from '../router';import store from '../store/index';import { Toast } from 'vant';/** * 提示函数 * 禁止点击蒙层、显示一秒后关闭 */const tip = msg =&gt; { Toast({ message: msg, duration: 1000, forbidClick: true });}/** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } });}/** * 请求失败后的错误统一处理 * @param {Number} status 请求失败的状态码 */const errorHandle = (status, other) =&gt; { // 状态码判断 switch (status) { // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip('登录过期，请重新登录'); localStorage.removeItem('token'); store.commit('loginSuccess', null); setTimeout(() =&gt; { toLogin(); }, 1000); break; // 404请求不存在 case 404: tip('请求的资源不存在'); break; default: console.log(other); }}// 创建axios实例var instance = axios.create({ timeout: 1000 * 12});// 设置post请求头instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';/** * 请求拦截器 * 每次请求前，如果存在token则在请求头中携带token */ instance.interceptors.request.use( config =&gt; { // 登录流程控制中，根据本地是否存在token判断用户的登录情况 // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码 // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; Promise.error(error))// 响应拦截器instance.interceptors.response.use( // 请求成功 res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 error =&gt; { const { response } = error; if (response) { // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); } else { // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) { store.commit('changeNetwork', false); } else { return Promise.reject(error); } } });export default instance; 这个axios和之前的大同小异，做了如下几点改变： 去掉了之前get和post方法的封装，通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。 去掉了通过环境变量控制baseUrl的值。考虑到接口会有多个不同域名的情况，所以准备通过js变量来控制接口域名。这点具体在api里会介绍。 增加了请求超时，即断网状态的处理。说下思路，当断网时，通过更新vuex中network的状态来控制断网提示组件的显示隐藏。断网提示一般会有重新加载数据的操作，这步会在后面对应的地方介绍。 公用函数进行抽出，简化代码，尽量保证单一职责原则。 下面说下api这块，考虑到一下需求： 更加模块化 更方便多人开发，有效减少解决命名冲突 处理接口域名有多个情况 这里这里呢新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。 先放index.js代码： 123456789101112/** * api接口的统一出口 */// 文章模块接口import article from '@/api/article';// 其他模块的接口……// 导出接口export default { article, // ……} index.js是一个api接口的出口，这样就可以把api接口根据功能划分为多个模块，利于多人协作开发，比如一个人只负责一个模块的开发等，还能方便每个模块中接口的命名哦。 base.js: 123456789/** * 接口域名的管理 */const base = { sq: 'https://xxxx111111.com/api/v1', bd: 'http://xxxxx22222.com/api'}export default base; 通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。 最后就是接口模块的说明，例如上面的article.js: 123456789101112131415161718192021222324252627/** * article模块接口列表 */import base from './base'; // 导入接口域名列表import axios from '@/utils/http'; // 导入http中创建的axios实例import qs from 'qs'; // 根据需求是否导入qs模块const article = { // 新闻列表 articleList () { return axios.get(`${base.sq}/topics`); }, // 新闻详情,演示 articleDetail (id, params) { return axios.get(`${base.sq}/topic/${id}`, { params: params }); }, // post提交 login (params) { return axios.post(`${base.sq}/accesstoken`, qs.stringify(params)); } // 其他接口…………}export default article; 通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对post请求时提交的数据进行一个qs序列化的处理等。 请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，axios文档说的很清楚，这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。 restful风格的接口，也可以通过这种方式灵活的设置api接口地址。 最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中： 1234567import Vue from 'vue'import App from './App'import router from './router' // 导入路由文件import store from './store' // 导入vuex文件import api from './api' // 导入api接口Vue.prototype.$api = api; // 将api挂载到vue的原型上 然后我们可以在页面中这样调用接口，eg： 123456789methods: { onLoad(id) { this.$api.article.articleDetail(id, { api: 123 }).then(res=&gt; { // 执行某些操作 }) } } 再提一下断网的处理，这里只做一个简单的示例： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div v-if=\"!network\"&gt; &lt;h3&gt;我没网了&lt;/h3&gt; &lt;div @click=\"onRefresh\"&gt;刷新&lt;/div&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { mapState } from 'vuex'; export default { name: 'App', computed: { ...mapState(['network']) }, methods: { // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的 onRefresh () { this.$router.replace('/refresh') } } }&lt;/script&gt; 这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其beforeRouteEnter钩子中再返回当前页面。 123456// refresh.vuebeforeRouteEnter (to, from, next) { next(vm =&gt; { vm.$router.replace(from.fullPath) }) } 这是一种全局通用的断网提示，当然了，也可以根据自己的项目需求操作。具体操作就仁者见仁智者见智了。 如果更多的需求，或者说是不一样的需求，可以根据自己的需求进行一个改进。","link":"/2020/06/06/vue中axios的封装和API接口的管理/"},{"title":"vue常见问题及解决方法（三）","text":"好久没更新博客了，很长一段时间在刚python，不得不说python真是方便，后面可能回更新一些python的学习历程。好，废话不说，进入主题。。 1.监听某个DOM节点，当其失去焦点（鼠标点击到页面其他标签）时，触发相应的事件。以下是一个点击按钮，就会弹出框，点击页面其他地方，就会关闭弹出框的例子。 DOM结构： 12345678910&lt;div ref=\"elLogout\"&gt; &lt;div class=\"userControl\" @click=\"showLogoutdiv = !showLogoutdiv\"&gt; &lt;svg class=\"iconuser\" aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#icon-user\"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div class=\"userLogout\" v-show=\"showLogoutdiv\"&gt; &lt;el-button type=\"primary\" plain size=\"small\" @click=\"toLogout\"&gt;退出&lt;/el-button&gt; &lt;/div&gt;&lt;/div&gt; js部分： 123456789101112131415export default { data () { showLogoutdiv:false, }, mounted() { document.addEventListener('click',e =&gt; { //监听页面的点击事件 if(this.$refs.elLogout){ //判断是否存在该标签对象 //contains()判断DOM元素的包含关系,如果两个DOM对象一样，则返回true if(!this.$refs.elLogout.contains(e.target)){ this.showLogoutdiv = false; //点击其他区域关闭 } } }) }, } 拓展：contains()函数的用法 题目描述: 查找两个节点的最近的一个共同父节点，可以包括节点自身 输入描述: oNode1 和 oNode2 在同一文档中，且不会为相同的节点 递归实现： 1234567function commonParentNode(oNode1, oNode2) { if(oNode1.contains(oNode2)){ return oNode1 }else{ return commonParentNode(oNode1.parentNode, oNode2) } } 迭代实现：方式一： 1234567function commonParentNode(oNode1, oNode2) { for(;;oNode1=oNode1.parentNode){ if(oNode1.contains(oNode2)){ return oNode1; } }} 方式二： 12345678function commonParentNode(oNode1, oNode2) { while(1){ if(oNode1.contains(oNode2)){ return oNode1 } oNode1 = oNode1.parentNode }} 2.计算属性computed方法内传参 index.vue 1234567891011&lt;van-circle v-model=\"Ratedata[index].currentRate\" color=\"#2462E8\" fill=\"#fff\" layer-color=\"#E6E6E6\" :rate=\"Ratedata[index].rate\" :text=\"text(index)\" :speed=\"60\" :clockwise=\"true\" :stroke-width=\"40\" /&gt; computed中text方法传递index，利用了闭包传值 1234567computed: { text() { return function (index) { return this.Ratedata[index].currentRate.toFixed(0) + '%'; } }}","link":"/2020/06/09/vue常见问题及解决方法（三）/"},{"title":"vue常见问题及解决方法（二）","text":"这里给大家分享一下vue中遇到的一些问题和解决技巧，希望对大家有用处。（话不多说上代码） 1.vue路由拦截浏览器后退实现表单保存类似需求（为了防止用户突然离开，没有保存已输入的信息。）12345678910//在路由组件中：mounted(){},beforeRouteLeave (to, from, next) { if(用户已经输入信息){ //出现弹窗提醒保存表单，或者自动后台为其保存 }else{ next(true);//用户离开 } 2.路由懒加载写法:1234567891011121314// 我所采用的方法，个人感觉比较简洁一些，少了一步引入赋值。const router = new VueRouter({ routes: [ path: '/app', component: () =&gt; import('./app'), // 引入组件 ]})// Vue路由文档的写法:const app = () =&gt; import('./app.vue') // 引入组件const router = new VueRouter({ routes: [ { path: '/app', component: app } ]}) 3.路由的项目启动页和404页面一般项目都会设置这个，如果默认进入地址会跳到login页面，如果你输入的是一个没有用的路由或者是空路由会跳转到notFind页面（你自己设置的404页面） 123456789101112export default new Router({ routes: [ { path: '/', // 项目启动页 redirect:'/login' // 重定向到下方声明的路由 }, { path: '*', // 404 页面 component: () =&gt; import('./notFind') // 或者使用component也可以的 }, ] }) 4.setInterval路由跳转继续运行并没有销毁问题12345678910//方法一：beforeDestroy(){ //我通常是把setInterval()定时器赋值给this实例，然后就可以像下面这么暂停。 clearInterval(this.intervalid);},//方法二：this.$once('hook:beforeDestroy', () =&gt; { //清理定时器 clearTimeout(this.timeout);}) 5.setTimeout/setInterval this指向改变，无法用this访问VUe实例这个地方大家的默认方法肯定是:12345//使用变量访问this实例let self=this; setTimeout(function () { console.log(self);//使用self变量访问this实例 },1000); 其实这个地方我们可以用箭头函数，因为箭头函数会改变this的指向，而指向的刚好是自己的父级this，所以我们可以这样用： 1234//箭头函数访问this实例 因为箭头函数本身没有绑定thissetTimeout(() =&gt; { console.log(this);}, 500); 这样我们的this就是指向我们的vue实例了。 6.Vue 数组/对象更新 视图不更新方法一：直接使用最简单也是最有效的方法，深拷贝对象或者数组，视图会进行更新，不过会有一个缺点，深拷贝后的数组或者对象不是原来的那个数组或者对象，是你现在改变了之后的值。 上代码： 12//Obj =&gt; 你的对象或数组this.Obj=JSON.parse(JSON.stringify(this.Obj)); 先进行转字符串，再转回对象，这个就进行了一个拷贝的过程，会触发视图的改变，同时也进行了一个数组的替换，有利有弊。 方法二：this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)12this.$set(this.arr, 0, \"OBKoro1\"); // 改变数组this.$set(this.obj, \"c\", \"OBKoro1\"); // 改变对象 这个是vue专门为改变不了数组设定的一个方法，使用也很简单（如果还是不懂请参考vue文档） 7.深度watch与watch立即触发回调watch很多人都在用，但是这watch中的这两个选项deep、immediate，或许不是很多人都知道，我猜。 选项：deep 在选项参数中指定 deep: true，可以监听对象中属性的变化。 选项：immediate 在选项参数中指定 immediate: true, 代表如果在 wacth 里声明了 step之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。 12345678910111213141516watch: { obj: { handler(val, oldVal) { console.log('属性发生变化触发这个回调',val, oldVal); }, deep: true // 监听这个对象中的每一个属性变化 }, step: { // 属性 //watch handler(val, oldVal) { console.log(\"默认触发一次\", val, oldVal); }, immediate: true // 立即触发一次 },},","link":"/2020/06/06/vue常见问题及解决方法（二）/"},{"title":"关于this的解析（一）","text":"1.1 为什么要用this如果对于有经验的JavaScript开发者来说this都是一种非常复杂的机制，那它到底有用在哪里呢？真的值得我们付出这么大的代价学习吗？的确，在介绍怎么做之前我们需要先明白为什么。 下面我们来解释一下为什么要使用 this： 12345678910111213function identify() { return this.name.toUpperCase(); }function speak() { var greeting = \"Hello, I'm \" + identify.call( this ); console.log( greeting ); }var me = { name: \"Kyle\" };var you = { name: \"Reader\" };identify.call( me ); // KYLE identify.call( you ); // READER speak.call( me ); // Hello, 我是 KYLE speak.call( you ); // Hello, 我是 READER 看不懂这段代码？不用担心！我们很快就会讲解。现在请暂时抛开这些问题，专注于为 什么。 这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。 如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。 123456789function identify(context) { return context.name.toUpperCase(); }function speak(context) { var greeting = \"Hello, I'm \" + identify( context ); console.log( greeting ); }identify( you ); // READER speak( me ); //hello, 我是 KYLE 然而，this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计 得更加简洁并且易于复用。 随着你的使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。当我们介绍对象和原型时，你就会明白函数可以自动引用合适的上下文对象 有多重要。 1.2 误解1.2.1 指向自身人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说得通的。 那么为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函 数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。 JavaScript 的新手开发者通常会认为，既然函数看作一个对象（JavaScript 中的所有函数都 是对象），那就可以在调用函数时存储状态（属性的值）。这是可行的，有些时候也确实有 用，但是在本书即将介绍的许多模式中你会发现，除了函数对象还有许多更合适存储状态 的地方。 不过现在我们先来分析一下这个模式，让大家看到 this 并不像我们所想的那样指向函数 本身。 我们想要记录一下函数 foo 被调用的次数，思考一下下面的代码： 123456789101112131415161718function foo(num) { console.log( \"foo: \" + num ); // 记录 foo 被调用的次数 this.count++; }foo.count = 0;var i;for (i=0; i&lt;10; i++) { if (i &gt; 5) { foo( i ); } } // foo: 6 // foo: 7 // foo: 8 // foo: 9 // foo 被调用了多少次？ console.log( foo.count ); // 0 -- WTF? console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，但是 foo.count 仍然 是 0。显然从字面意思来理解 this 是错误的。 执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相 同，困惑随之产生。 遇到这样的问题时，许多开发者并不会深入思考为什么 this 的行为和预期的不一致，也不 会试图回答那些很难解决但却非常重要的问题。他们只会回避这个问题并使用其他方法来 达到目的，比如创建另一个带有 count 属性的对象。 123456789101112131415161718function foo(num) { console.log( \"foo: \" + num ); // 记录 foo 被调用的次数 data.count++; }var data = { count: 0 };var i;for (i=0; i&lt;10; i++) { if (i &gt; 5) { foo( i ); } }// foo: 6 // foo: 7 // foo: 8 // foo: 9 // foo 被调用了多少次？ console.log( data.count ); // 4 从某种角度来说这个方法确实“解决”了问题，但可惜它忽略了真正的问题——无法理解 this 的含义和工作原理——而是返回舒适区，使用了一种更熟悉的技术：词法作用域。 另一种方法是强制 this 指向 foo 函数对象： 123456789101112131415161718192021function foo(num) { console.log( \"foo: \" + num ); // 记录 foo 被调用的次数 // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo this.count++; }foo.count = 0;var i;for (i=0; i&lt;10; i++) { if (i &gt; 5) { // 使用 call(..) 可以确保 this 指向函数对象 foo 本身 foo.call( foo, i ); } }// foo: 6 // foo: 7 // foo: 8 // foo: 9 // foo 被调用了多少次？ console.log( foo.count ); // 4 这次我们接受了 this，没有回避它。如果你仍然感到困惑的话，不用担心，之后我们会详 细解释具体的原理。 1.2.2 它的作用域第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它 是正确的，但是在其他情况下它却是错误的。 需要明确的是，this 在任何情况下都不指向函数的词法作用域。在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。 思考一下下面的代码，它试图（但是没有成功）跨越边界，使用 this 来隐式引用函数的词 法作用域： 12345678function foo() { var a = 2; this.bar(); }function bar() { console.log( this.a ); }foo(); // ReferenceError: a is not defined 这段代码中的错误不止一个。虽然这段代码看起来好像是我们故意写出来的例子，但是实 际上它出自一个公共社区中互助论坛的精华代码。这段代码非常完美（同时也令人伤感） 地展示了 this 多么容易误导人。 首先，这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的，我们之 后会解释原因。调用 bar() 最自然的方法是省略前面的 this，直接使用词法引用标识符。 此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a。这是不可能实现的，你不能使用 this 来引用一 个词法作用域内部的东西。 每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。 1.3 this到底是什么排除了一些错误理解之后，我们来看看 this 到底是一种什么样的机制。 之前我们说过 this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到。 1.4 小结对于那些没有投入时间学习 this 机制的 JavaScript 开发者来说，this 的绑定一直是一件非常令人困惑的事。 this 是非常重要的，但是猜测、尝试并出错和盲目地从 Stack Overflow 上复制和粘贴答案并不能让你真正理解 this 的机制。 学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域，你也许被 这样的解释误导过，但其实它们都是错误的。 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。","link":"/2020/06/06/关于this的解析（一）/"},{"title":"关于this的解析（二）——调用位置和绑定规则","text":"现在我们已经了解了函数调用中this绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则。但是，如果某个调用位置可以应用多条规则该怎么办？为了 解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。 毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高？我们来测试一下： 12345678910111213141516function foo() { console.log( this.a ); }var obj1 = { a: 2, foo: foo };var obj2 = { a: 3, foo: foo };obj1.foo(); // 2 obj2.foo(); // 3 obj1.foo.call( obj2 ); // 3 obj2.foo.call( obj1 ); // 2 可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低： 1234567891011121314151617function foo(something) { this.a = something; }var obj1 = { foo: foo };var obj2 = {}; obj1.foo( 2 ); console.log( obj1.a ); // 2 obj1.foo.call( obj2, 3 ); console.log( obj2.a ); // 3var bar = new obj1.foo( 4 ); console.log( obj1.a ); // 2 console.log( bar.a ); // 4 可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢？ new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。 在看代码之前先回忆一下硬绑定是如何工作的。Function.prototype.bind(..) 会创建一个 新的包装函数，这个函数会忽略它当前的 this 绑定（无论绑定的对象是什么），并把我们 提供的对象绑定到 this 上。 这样看起来硬绑定（也是显式绑定的一种）似乎比 new 绑定的优先级更高，无法使用 new 来控制 this 绑定。 我们看看是不是这样： 123456789101112function foo(something) { this.a = something; }var obj1 = {};var bar = foo.bind( obj1 ); bar( 2 ); console.log( obj1.a ); // 2var baz = new bar(3); console.log( obj1.a ); // 2 console.log( baz.a ); // 3 出乎意料！ bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。 判断this现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断： 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 1var bar = new foo() 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 1var bar = foo.call(obj2) 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 1var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 1var bar = foo() 就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。","link":"/2020/06/06/关于this的解析（三）——绑定规则的优先级/"},{"title":"关于this的解析（三）——绑定规则的优先级","text":"1.1 调用位置在理解 this 的绑定过程之前首先要理解调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引 用的是什么？ 通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。 最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的 调用位置就在当前正在执行的函数的前一个调用中。 下面我们来看看到底什么是调用栈和调用位置： 123456789101112131415161718function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar 的调用位置 }function bar() { // 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中 console.log( \"bar\" ); foo(); // &lt;-- foo 的调用位置 }function foo() { // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 console.log( \"foo\" ); }baz(); // &lt;-- baz 的调用位置 注意我们是如何（从调用栈中）分析出真正的调用位置的，因为它决定了 this 的绑定。 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所 写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法 是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具， 其中包含 JavaScript 调试器。就本例来说，你可以在工具中给 foo() 函数的 第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger;语句。运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数 调用列表，这就是你的调用栈。因此，如果你想要分析 this 的绑定，使用开 发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。 1.2 绑定规则1.2.1 默认绑定最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用 其他规则时的默认规则。思考一下下面的代码： 12345function foo() { console.log( this.a ); }var a = 2; foo(); // 2 你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。 接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了this 的默认绑定，因此this指向全局对象。 那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。 如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined： 123456function foo() { \"use strict\"; console.log( this.a ); }var a = 2; foo(); // TypeError: this is undefined 这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只 有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo() 的调用位置无关： 12345678function foo() { console.log( this.a ); }var a = 2; (function(){ \"use strict\"; foo(); // 2 })(); 1.2.2隐性绑定另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包 含，不过这种说法可能会造成一些误导。思考下面的代码： 12345678function foo() { console.log( this.a ); }var obj = { a: 2, foo: foo };obj.foo(); // 2 首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。 然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥 有”或者“包含”它。 无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：123456789101112function foo() { console.log( this.a ); }var obj2 = { a: 42, foo: foo };var obj1 = { a: 2, obj2: obj2 };obj1.obj2.foo(); // 42 隐式丢失一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。 思考下面的代码： 12345678910function foo() { console.log( this.a ); }var obj = { a: 2, foo: foo };var bar = obj.foo; // 函数别名！var a = \"oops, global\"; // a 是全局对象的属性 bar(); // \"oops, global\" 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时： 12345678910111213function foo() { console.log( this.a ); }function doFoo(fn) { // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！ }var obj = { a: 2, foo: foo };var a = \"oops, global\"; // a 是全局对象的属性 doFoo( obj.foo ); // \"oops, global\" 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一 个例子一样。 如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一 样的，没有区别： 123456789function foo() { console.log( this.a ); }var obj = { a: 2, foo: foo };var a = \"oops, global\"; // a 是全局对象的属性 setTimeout( obj.foo, 100 ); // \"oops, global\" 1.2.3 显性绑定就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函 数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么 做呢？ JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关——之后我 们会详细介绍原型），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。 这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我 们称之为显式绑定。 思考下面的代码： 1234567function foo() { console.log( this.a ); }var obj = { a:2 };foo.call( obj ); // 2 通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现 在其他的参数上，但是现在我们不用考虑这些。 可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。 1.硬绑定但是显式绑定的一个变种可以解决这个问题。 思考下面的代码： 1234567891011121314function foo() { console.log( this.a ); }var obj = { a:2 };var bar = function() { foo.call( obj ); };bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call( window ); // 2 我们来看看这个变种到底是怎样工作的。我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。 由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype. bind，它的用法如下： 12345678910function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a:2 };var bar = foo.bind( obj );var b = bar( 3 ); // 2 3 console.log( b ); // 5 2.API调用的“上下文”第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。 举例来说： 123456789function foo(el) { console.log( el, this.id ); }var obj = { id: \"awesome\" };// 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些 代码。 1.2.4 new绑定这是第四条也是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见 的关于 JavaScript 中函数和对象的误解。 在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会 调用类中的构造函数。通常的形式是这样的：1something = new MyClass(..); JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。 首先我们重新定义一下 JavaScript 中的“构造函数”。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它： 当 Number 在 new 表达式中被调用时，它是一个构造函数：它会初始化新创建的 对象。 所以，包括内置对象函数（比如 Number(..)，详情请查看第 3 章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 思考下面的代码： 12345function foo(a) { this.a = a; }var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。","link":"/2020/06/06/关于this的解析（二）——调用位置和绑定规则/"},{"title":"关于this的解析（四）——绑定例外和this词法","text":"1.1绑定例外在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用 的可能是默认绑定规则。 1.1.1 被忽略的this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则：12345function foo() { console.log( this.a ); }var a = 2; foo.call( null ); // 2 那么什么情况下你会传入 null 呢？ 一种非常常见的做法是使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。 类似地，bind(..) 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用： 12345678910function foo(a,b) { console.log( \"a:\" + a + \", b:\" + b ); }// 把数组“展开”成参数 foo.apply( null, [2, 3] ); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2 ); bar( 3 ); // a:2, b:3 这两种方法都需要传入一个参数当作 this 的绑定对象。如果函数并不关心 this 的话，你 仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。 然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this（比如第三方库中的一个函数），那默认绑定规则会把 this 绑定到全局对象（在浏览 器中这个对象是 window），这将导致不可预计的后果（比如修改全局对象）。 显而易见，这种方式可能会导致许多难以分析和追踪的 bug。 更安全的this一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序 产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized zone，非军事区）对象——它就是一个空的非委托的对象（下面会讲到）。 如果我们在忽略 this 绑定时总是传入一个 DMZ 对象，那就什么都不用担心了，因为任何 对于 this 的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。 由于这个对象完全是一个空对象，我自己喜欢用变量名 ø（这是数学中表示空集合符号的 小写形式）来表示它。在大多数键盘（比如说 Mac 的 US 布局键盘）上都可以使用⌥ +o （Option-o）来打出这个符号。有些系统允许你为特殊符号设定快捷键。如果你不喜欢 ø 符 号或者你的键盘不太容易打出这个符号，那你可以换一个喜欢的名字来称呼它。 无论你叫它什么，在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null) 。Object.create(null) 和 {} 很 像， 但 是 并 不 会 创 建 Object. prototype 这个委托，所以它比 {}“更空”： 123456789101112function foo(a,b) { console.log( \"a:\" + a + \", b:\" + b ); }// 我们的 DMZ 空对象 var ø = Object.create( null ); // 把数组展开成参数 foo.apply( ø, [2, 3] ); // a:2, b:3 // 使用 bind(..) 进行柯里化var bar = foo.bind( ø, 2 ); bar( 3 ); // a:2, b:3 使用变量名 ø 不仅让函数变得更加“安全”，而且可以提高代码的可读性，因为 ø 表示 “我希望 this 是空”，这比 null 的含义更清楚。不过再说一遍，你可以用任何喜欢的名字 来命名 DMZ 对象。 1.1.2 间接引用另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。 间接引用最容易在赋值时发生： 12345678function foo() { console.log( this.a ); } var a = 2;var o = { a: 3, foo: foo };var p = { a: 4 }; o.foo(); // 3 (p.foo = o.foo)(); // 2 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。 注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。 1.1.3 软绑定之前我们已经看到过，硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相 同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。 可以通过一种被称为软绑定的方法来实现我们想要的效果： 123456789101112131415if (!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有 curried 参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; }; } 除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里 化（详情请查看之前和 bind(..) 相关的介绍）。 下面我们看看 softBind 是否实现了软绑定功能： 123456789101112131415161718function foo() { console.log(\"name: \" + this.name); }var obj = { name: \"obj\" }, obj2 = { name: \"obj2\" }, obj3 = { name: \"obj3\" }; var fooOBJ = foo.softBind( obj ); fooOBJ(); // name: obj obj2.foo = foo.softBind(obj); obj2.foo(); // name: obj2 &lt;---- 看！！！ fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！ setTimeout( obj2.foo, 10 ); // name: obj &lt;---- 应用了软绑定 可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默 认绑定，则会将 this 绑定到 obj。 1.2 this词法我们之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用 这些规则的特殊函数类型：箭头函数。 箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决 定 this。 我们来看看箭头函数的词法作用域： 123456789101112131415function foo() { // 返回一个箭头函数 return (a) =&gt; { //this 继承自 foo() console.log( this.a ); }; }var obj1 = { a:2 };var obj2 = { a:3};var bar = foo.call( obj1 ); bar.call( obj2 ); // 2, 不是 3 ！ foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不 行！） 箭头函数最常用于回调函数中，例如事件处理器或者定时器：12345678910function foo() { setTimeout(() =&gt; { // 这里的 this 在此法上继承自 foo() console.log( this.a ); },100); }var obj = { a:2 };foo.call( obj ); // 2 箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体 现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。12345678910function foo() { var self = this; // lexical capture of this setTimeout( function(){ console.log( self.a ); }, 100 ); }var obj = { a: 2 };foo.call( obj ); // 2 虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替 代的是 this 机制。 如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数 来否定 this 机制，那你或许应当： 只使用词法作用域并完全抛弃错误 this 风格的代码； 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。 当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混 合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。 1.3 总结如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。 由 new 调用？绑定到新创建的对象。 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 由上下文对象调用？绑定到那个上下文对象。 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑 定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这 其实和 ES6 之前代码中的 self = this 机制一样。","link":"/2020/06/06/关于this的解析（四）——绑定例外和this词法/"},{"title":"浅谈PHP面向对象编程","text":"本篇文章给大家分享的内容是关于浅谈PHP面向对象编程 ，有着一定的参考价值，有需要的朋友可以参考一下。 一、PHP面向对象编程基础实践 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** 通过对象的编程方式，可将实现生活中的一切事物以对象的形式表现出来。便于理解、维护、扩展等；* 本示例：定义一个“人”类* $name : 对象中的成员属性，在此类中表示人的姓名* say() : 对象中的成员方法，在此类中表示人说话的方法* $this : PHP中的伪变量，表示自身的类* __construct() : php中的魔术方法，构造函数，在实例化类时自动执行* __destruct() : php中的魔术方法，析构函数，当类调用完成后自动执行*/class Human{ public $name; public $sex; public $age; public function __construct($name,$sex,$age) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } public function say() { echo '大家好，我的名字叫'.$this-&gt;name.'，今年'.$this-&gt;age.'岁，我的性别是'.$this-&gt;sex; } public function __destruct() { $this-&gt;name = null; $this-&gt;sex = null; $this-&gt;age = null; }}//实例化“人”类$male = new Human(\"张三\",\"男\",\"20\");//调用“人”类说话的方法$male-&gt;say(); //输出结果：大家好，我的名字叫张三，今年20岁，我的性别是男?&gt; 二、PHP面向对象高级编程实践知识点：类的继承、方法重写、访问控制、static关键字、final关键字、数据访问、接口、多态、抽象类 2.1、类的继承：extends 关键字例如：一员运行员、一位主持人，他们有人类共同的行为方法，但他们都有自己不同的特长专业。因此在编程时需要给他们创建一个父类并继承； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** 创建一个“人”类做为父类，继承的子类都拥有其父类的成员属性、方法*/class Human{ public $name; public function say() { echo \"父类说话的方法，姓名：\".$this-&gt;name.\"\\n\"; } public function eat() { echo \"父类吃饭的方法\\n\"; }}/** 创建一个“运动员”类，继承“人”类* extends : 关键字，继承某个类*/class Sport extends Human{ public $type; public function __construct($name,$type) { $this-&gt;name = $name; //给父类 $name 属性赋值 $this-&gt;type = $type; } public function run() { $this-&gt;say(); //调用父类“说话”的方法 echo \"我在正跑步，我是一员\".$this-&gt;type.\"运动员.....\\n\"; }}/** 创建一个“主持人”类，继承“人”类* extends : 关键字，继承某个类*/class Host extends Human{ public $television; public function __construct($name,$television) { $this-&gt;name = $name; $this-&gt;television= $television; } public function perform() { $this-&gt;eat(); //调用父类“吃饭”的方法 echo \"我在正表演一个节目，我是\".$this-&gt;television.\"电视台的一名主持人.....\\n\"; }} //实例化“运动员”类$nba = new Sport(\"乔丹\",\"篮球\");$nba-&gt;run(); //实例化“主持人”类$tv = new Host(\"张三\",\"北京卫视\");$tv-&gt;perform(); //输出结果：//父类说话的方法，姓名：乔丹 我在正跑步，我是一员篮球运动员..... //父类吃饭的方法 我在正表演一个节目，我是北京卫视电视台的一名主持人.....?&gt; 2.2、方法重写：子类重写父类的方法 1234567891011121314151617181920&lt;?phpclass Human{ public function say() { echo \"父类说话的方法\"; }}class Sport extends Human{ //重写父类“说话”的方法 public function say() { echo \"子类说话的方法\"; }}$nba = new Sport();$nba-&gt;say();//输出结果：子类说话的方法?&gt; 2.3、访问控制：public 、 protected 、private 关键字 public：定义公共的成员属性或方法，任何地方都可使用protected : 定义受保护的成员属性或方法，只允许类本身或子类使用private : 定义私有的成员属性或方法，只允许类的本身使用 123456789101112&lt;?phpclass Human{ public $name; protected $sex; private $age; }//实例化对象，给公共属性赋值可正常输出结果，外部不能给protected、private受保护的成员属性赋值或使用$worker = new Human();$worker-&gt;name = \"张三\";echo $worker-&gt;name;?&gt; 2.4、static（静态）关键字1）、静态属性用于保存类的公有数据；2）、静态方法里面只能访问静态属性或方法，不能使用 $this 伪变量；3）、静态成员不需要通过 new 关键字来实例化对象就可访问使用； 123456789101112131415&lt;?phpclass Human{ static $name = \"张三\"; static function say() { echo \"我的姓名叫：\".self::$name; }}//外部使用静态成员属性或方法echo Human::$name;Human::say(); //输出结果：张三 我的姓名叫：张三?&gt; 2.5、final关键字：不允许成员方法被重写，不允许被继承例：1、对于父类“吃饭”这个方法，不希望子类重写它；2、对于“运动员”这个类，不希望它再创建子类； 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Human{ final public function eat() { echo \"父类吃饭的方法，不允许子类重写\"; }}final class Sport extends Human{ public function eat() { echo \"子类吃饭的方法。此时程序将会报致命错误\"; }}//创建一个类继承 Sport 这个类。此时程序也将会报致命错误。因为 Sport 类不允许再创建子类class Student extends Sport{ public $name;} //实例化 Sport 类 ，调用 eat() 方法$nba = new Sport();$nba-&gt;eat(); //实例化 Student 类 ，给 name 属性负值$obj = new Student();$obj-&gt;name = \"张三\"; //输出结果：Fatal error: Cannot override final method Human::eat() in ******.php on line 15//Fatal error: Class Student may not inherit from final class (Sport) in ****.php on line 20?&gt; 2.6、数据访问：$this 、 self 、parent 关键字$this ： 伪变量，代表类的本身，可访问本类及父类中的成员属性与方法。self ： 访问类中的静态成员属性或方法parent ：访问父类的成员属性或方法 1234567891011121314151617181920&lt;?phpclass Human{ static $name = \"张三\";}class Sport extends Human{ static function getParentName() { echo parent::$name; } public function get() { self::getParentName(); }}$obj = new Sport();$obj-&gt;get();//输出结果：张三?&gt; 2.7、接口：把不同类的共同行为方法进行定义，但不具体实现，由子类来实现具体的方法；例如：人会吃饭，动物也会吃饭，甚至有些植物也会吃饭，但他们吃饭的方式不一样，因此这时需要定义一个接口类，具体的方式由子类来实现；定义接口关键字：interface实现接口方法关键字：implements 123456789101112131415161718192021222324252627282930313233&lt;?php//定义一个接口类，有吃饭的方法，但不具体实现。interface ICanEat{ public function eat($food);}class Human implements ICanEat{ //eat()方法必须由子类来实现，否则程序将报致命错误 public function eat($food) { echo \"I'm eating \".$food; }}class Animal implements ICanEat{ public function eat($food) { echo \"It's eating \".$food; }}//实例化一个“人”类$people = new Human();$people-&gt;eat('rice'); //实例化一个“动物”类$monkey = new Animal();$monkey-&gt;eat('banana'); //输出结果：I'm eating rice// It's eating banana ?&gt; 2.8、多态：比如接口A有两个实现B和C，B和C对A接口里面定义的方法实现可以是不同的，这种现象称之为多态；上述实例中，ICanEat接口定义了一个eat()方法，人类吃米饭，猴子吃香蕉。他们都实现了一个“吃”的方法，但他们吃东西有不同的行为，称之为多态； 2.9、抽象类：介入接口与类的定义之间，允许类里面一部分方法不实现，实现一部分有相同功能且不会更改的方法。然而接口类里面不允许有任何实现的方法。例如：人和动物都具有吃饭与呼吸的方法，除吃饭不同以外，呼吸方法是相同的，此时需要定义一个抽象类来实现。定义抽象类关键字：abstract 1234567891011121314151617181920212223&lt;?php//定义一个抽象类，里面有吃饭和呼吸的方法。呼吸方法需要在抽象类中具体实现abstract class ICanEat{ abstract function eat($food); public function breath() { echo 'Breath use the air...'; }}class Human extends ICanEat{ public function eat($food) { echo \"I'm eating \".$food; $this-&gt;breath(); }}//实例化“人”类$people = new Human();$people-&gt;eat('rice');//输出结果:I'm eating rice Breath use the air...?&gt; 三、PHP面向对象编程特殊实践PHP语言特定的一些魔术方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Object{ public function __construct() { echo \"当类在被实例化的时候，自动执行该函数\"; } public function __toString() { return \"当对象被当作字符串形式输出时，自动执行该函数\"; } public function __invoke($value) { echo \"当对象被当作函数调用时，自动执行该函数\".$value; } /* * 当对象访问不存在的方法时，自动执行该函数。也称之为“方法重载” * $fun : 方法名称 * $param : 传递的参数 */ public function __call($fun,$param) { echo \"调用\".$fun.\"方法不存在，传递的参数\".implode(',',$param); } /* * 当对象访问不存在的静态方法时，自动执行该函数。 * $fun : 方法名称 * $param : 传递的参数 */ static function __callStatic($fun,$param) { echo \"调用\".$fun.\"静态方法不存在，传递的参数\".implode(',',$param); } public function __get($key) { echo \"当读取对象中不可访问（未定义）的属性值时，自动调用该函数。\".$key.\"属性不可访问或未定义\"; } public function __set($key,$value) { echo \"当给对象中不可访问（未定义）的属性赋值时，自动调用该函数。\".$key.\"属性不可访问或未定义，值\".$value; } public function __isset($key) { echo \"判断对象中的属性不存在时，自动执行该函数。属性：\".$key.\"值未定义\"; } public function __unset($key) { echo \"释放对象中的不存在的属性值时，自动执行该函数。属性：\".$key.\"值未定义\"; } public function __clone() { echo \"当对象被克隆时，自动执行该函数。\"; } public function __destruct() { echo \"当对象执行完成后，自动执行该函数\"; }}$obj = new Object(); //实例化对象时，调用__construct()方法echo $obj; //将对象以字符串形式输出时，调用__toString()方法$obj(123); //当对象以函数形式调用时，执行__invoke()方法$obj-&gt;runTest(); //当调用对象中不存在的方法时，执行__call()方法$obj::runTest(); //当调用对象中不存在的静态方法时，执行__callStatic()方法$obj-&gt;name; //当调用对象中不存在的成员属性时，执行__get()方法$obj-&gt;name = \"张三\"; //当给对象中不存在的成员属性赋值时，执行__set()方法isset($obj-&gt;name) ? 1 : 0; //判断对象中不存在的成员属性时，执行__isset()方法unset($obj-&gt;name); //释放对象中的不存在的属性值时，执行__unset()方法$obj2 = clone $obj; //当对象被克隆时，执行__clone()方法 //对象执行完毕，执行__destruct()方法?&gt;","link":"/2020/06/06/浅谈php面向对象编程/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段三）","text":"前面讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。 我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的。 整体过程 首先我们还是要感性地理解一下这个过程。 首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。 我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS属性计算出来呢？ 答案是肯定的。 在这个过程中，我们依次拿到上一部构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。 我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下： 空格: 后代，选中它的子节点和所有子节点的后代节点。 &gt;: 子代，选中它的子节点。 +：直接后继选择器，选中它的下一个相邻节点。 ~：后继，选中它之后所有的相邻节点。 ||：列，选中表格中的一列。 关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。理解了 CSS 构建的大概过程，我们下面来看看具体的操作。首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector通过前面讲的符号连接起来的。后代选择器 “空格”我们先来分析一下后代选择器，我们来一起看一个例子：123a#b .cls { width: 100px;}可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：12345&lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt;&lt;/a&gt;&lt;span class=cls&gt;3&lt;span&gt;当遇到 &lt;/a&gt; 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。后继选择器“ ~ ”接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：123456789101112.cls~* { border:solid 1px green;}&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它的后继，因此应该被选中。按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。子代选择器“ &gt;”我们继续看，子代选择器是如何实现的。实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。123456789101112div&gt;.cls { border:solid 1px green;}&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。直接后继选择器“ +”直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。列选择器“ || ”列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。其它我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。比如123a#b, .cls {}我们当作两条规则来处理：123a#b {}123.cls {}还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：12345678910#a .cls {}#a span {}#a&gt;span {}这里实际上可以把选择器构造成一棵树： #a &lt; 空格 &gt;.cls &lt; 空格 &gt;span &gt;span 需要注意的是，这里的树，必须要带上连接符。结语这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续继续显式打下了基础。最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。转自—《重学前端》","link":"/2020/06/06/浏览器：一个浏览器是如何工作的（阶段三）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段一）","text":"对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它能做什么，而不知道它是如何做到的。 在我面试和接触过的前端开发者中，70% 的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？ 事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。 在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师实现浏览器”的水准。 那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。 实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。 这个过程是这样的： 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面； 把请求回来的 HTML 代码经过解析，构建成 DOM 树； 计算 DOM 树上的 CSS 属性； 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图； 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度； 合成之后，再绘制到界面上。 我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。 从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。 首先我们来介绍下网络通讯的部分。 HTTP 协议浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议（实际上这个过程之前还有 DNS 查询，不过这里就不详细展开了。） 我先来了解下 HTTP 的标准。 HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份： HTTP1.1 https://tools.ietf.org/html/rfc2616 2.HTTP1.1 https://tools.ietf.org/html/rfc7234 HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。 大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。 下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP 一下： 实验我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具（安装方法）。 首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容： 1telnet time.geekbang.org 80 这个时候，TCP 连接已经建立，我们输入以下字符作为请求： 12GET / HTTP/1.1Host: time.geekbang.org 按下两次回车，我们收到了服务端的回复： 123456789101112131415HTTP/1.1 301 Moved PermanentlyDate: Fri, 25 Jan 2019 13:28:12 GMTContent-Type: text/htmlContent-Length: 182Connection: keep-aliveLocation: https://time.geekbang.org/Strict-Transport-Security: max-age=15768000&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"white\"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。 在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和版本。 在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。 紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 html 代码。 HTTP 协议格式根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分。 我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。 下面我们就来逐个给你介绍其它部分。 HTTP Method（方法）我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型。方法有以下几种定义： GET POST HEAD PUT DELETE CONNECT OPTIONS TRACE浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。 HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起 PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。 CONNECT 现在多用于 HTTPS 和 WebSocket。 OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。 HTTP Status code（状态码）和 Status text（状态文本）接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。 1xx：临时回应，表示客户端请继续。 2xx：请求成功。 200：请求成功。 3xx: 表示请求的目标有变化，希望客户端进一步处理。 301&amp;302：永久性与临时性跳转。 304：跟客户端缓存没有更新。 4xx：客户端请求错误。 403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议） 5xx：服务端请求错误。 500：服务端错误。 503：服务端暂时性错误，可以一会再试。 对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。 3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。 304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。 HTTP Head (HTTP 头)HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，我们现在就来了解一下它们。 在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下： 我们先来看看 Request Header。接下来看一下 Response Header。 这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完整的列表还是请你参考我给出的 rfc2616 标准。 HTTP Request BodyHTTP 请求的 body 主要用于提交表单场景。实际上，http 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是： application/json application/x-www-form-urlencoded multipart/form-data text/xml我们使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。 HTTPS在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。 我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。 HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：https://tools.ietf.org/html/rfc2818 HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP没有任何区别。 HTTP 2HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。https://tools.ietf.org/html/rfc7540 HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。 服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。 TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。 Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。 结语在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的这一过程。 在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head和 HTTP Request Body 几个重点需要注意的部分。 最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。 转自–《重学前端》","link":"/2020/06/06/浏览器：一个浏览器是如何工作的？（阶段一）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段五）","text":"我们的浏览器系列已经进行到最后一篇。 在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM树，并且根据样式信息，计算了每个元素的位置和大小。 那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。 渲染 首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，也有“粉刷墙壁”的意思。 在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。 所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。 我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。 不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。 这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。 浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。 这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。 盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，我们需要一个底层库来支持。 一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。 这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。 盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。 字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++编写的开源的字体库。 在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。 但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。 注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。 合成 合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。 我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。 看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？ 这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。 我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 html 创建一个合成后的位图，把所有子元素都进行合成，那么会发生什么呢？ 那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制所有的元素。 那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。 那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。 我们来举个例子：1234&lt;div id=\"a\"&gt; &lt;div id=\"b\"&gt;...&lt;/div&gt; &lt;div id=\"c\" style=\"transform:translate(0,0)\"&gt;&lt;/div&gt;&lt;/div&gt;假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：1document.getElementById(\"c\").style.transform = \"translate(100px, 0)\";我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。绘制绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。一般最终显式的位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者显式驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。然而如果在实际中这样做, 会带来极其糟糕的性能。有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免”重排”和”重绘”，前者讲的是我们上一课的排版行为，后者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的目标，当然，简单想想就知道，这种事情不可能总是发生的。计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。总结在这一章中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。转自—《重学前端》","link":"/2020/06/06/浏览器：一个浏览器是如何工作的？（阶段五）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段二）","text":"我在上一篇文章中，简要介绍了浏览器的工作大致可以分为 6 个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面的过程。 这次我们主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。 解析代码 我们在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的Response 的 body，就要交给我们今天学习的内容去处理了。 HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA 节点几种。 实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。“&lt;?”和“&lt;%”什么的也是必须要支持好的，报了错也不能吭声。 1. 词（token）是如何被拆分的 首先我们来看看一个非常标准的标签，会被如何拆分：1&lt;p class=\"a\"&gt;text text text如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了（它甚至可以嵌套）。那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“&lt;p” ，所以“ &lt;p” 就是我们的第一个词（token）。我们继续拆分，可以把这段代码依次拆成词（token）： &lt;p“标签开始”的开始； class=“a” 属性； &gt; “标签开始”的结束； text text text 文本； &lt;/p&gt; 标签结束。这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子：根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。比如，假设我们接受了一个字符“ &lt; ” 我们一下子就知道这不是一个文本节点啦。之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。2. 状态机绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看：当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML 官方文档，HTML 官方文档规定了 80 个状态（顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。这里我们为了理解原理，用这个简单的状态机就足够说明问题了。状态机的初始状态，我们仅仅区分 “&lt; ”和 “非 &lt;”： 如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点； 如果获得的是一个 &lt; 字符，那么进入一个标签状态。不过当我们在标签状态时，则会面临着一些可能性。 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。 如果下一个字符是字母，那么可以确定进入了一个开始标签。 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。 我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。接下来就是代码实现的事情了，在 C/C++ 和 JavaScript中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装状态机。为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344var data = function(c){ if(c==\"&amp;\") { return characterReferenceInData; } if(c==\"&lt;\") { return tagOpen; } else if(c==\"\\0\") { error(); emitToken(c); return data; } else if(c==EOF) { emitToken(EOF); return data; } else { emitToken(c); return data; }};var tagOpenState = function tagOpenState(c){ if(c==\"/\") { return endTagOpenState; } if(c.match(/[A-Z]/)) { token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; } if(c.match(/[a-z]/)) { token = new StartTagToken(); token.name = c; return tagNameState; } if(c==\"?\") { return bogusCommentState; } else { error(); return dataState; }};//……这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个“ &lt; ” 字符，来判断标签类型的状态。这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。这样，我们的状态迁移代码非常的简单：1234var state = data;var charwhile(char = getInput()) state = state(char);这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理方式。词法分析器接受字符的方式很简单，就像下面这样：12345678910111213141516function HTMLLexicalParser(){ // 状态函数们…… function data() { // …… } function tagOpen() { // …… } // …… var state = data; this.receiveInput = function(char) { state = state(char); }}至此，我们就把字符流拆成了词（token）了。构建 DOM 树接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。123456789function HTMLSyntaticalParser(){ var stack = [new HTMLDocument]; this.receiveInput = function(token) { //…… } this.getOutput = function(){ return stack[0]; }}我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emmitToken 来调用。在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP的话，我们还需要抽象工厂来创建对象），123456function Element(){ this.childNodes = [];}function Text(value){ this.value = value || \"\";}前面我们的词（token）中，以下两个是需要成对匹配的： tag start tag end根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点同样我们来看看直观的解析过程：12345678&lt;html maaa=a &gt; &lt;head&gt; &lt;title&gt;cool&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"a\" /&gt; &lt;/body&gt;&lt;/html&gt;通过这个栈，我们可以构建 DOM 树： 栈顶元素就是当前节点； 遇到属性，就添加到当前节点； 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点； 遇到注释节点，作为当前节点的子节点； 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点； 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。 当我们的源代码完全遵循 xhtml（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction结语好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。转自—《重学前端》","link":"/2020/06/06/浏览器：一个浏览器是如何工作的？（阶段二）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段四）","text":"我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。 在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到这样了。 尤其是表格相关排版、flex 排版和 grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。 基本概念 首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。 “排版”这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的位置。 在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。 浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。 浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型） 此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。 浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。 在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。 绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由 position 属性控制。 浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。 除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 flex 排版，这些排版方式由外部元素的 display 属性来控制（注意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。 正常流文字排版 我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，我们先从文字来讲起。 要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。 首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。 我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去继续写。 书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。 实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。 我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面： 纵向版本： 这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。 除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、word-spacing 等。 在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。 display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性（例如主轴为横向时的 margin-left 和margin-right）也会被计算进排版前进距离当中。 注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。 这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。 正常流中的盒 在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。 根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而 vertical-align属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。 所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。 块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。 绝对定位元素 position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。 浮动元素排版 float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。 移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。 float 元素排布完成后，float 元素所在的行需要重新确定位置。 其它的排版 CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。 总结 这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 flex排版。这属于进阶版的排版方式了，你可以了解一下。 你平时喜欢使用方式排版呢，欢迎留言告诉我。 转自—《重学前端》","link":"/2020/06/06/浏览器：一个浏览器是如何工作的？（阶段四）/"},{"title":"用jQuery实现简单的图片轮播效果","text":"以下代码使用了jQuery来实现简单的图片轮播效果： html部分： 12345678910111213141516171819202122&lt;div id=\"slider\"&gt; &lt;ul class=\"slider_list\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"4.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"5.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"6.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"7.jpeg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"8.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"slider_icon\"&gt; &lt;i class=\"btn btn_act\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;a href=\"javascript:;\" class=\"arrow left\"&gt; &lt;span class=\"slider_left\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href=\"javascript:;\" class=\"arrow right\"&gt; &lt;span class=\"slider_right\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; css部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#slider{ width: 750px; height: 450px; margin: 10% auto; position: relative; border: 0px red solid }#slider img{ width: 750px; height: 450px; }li{ list-style: none; }.slider_list li{ position: absolute; display: none; }.slider_list li:first-child{ display: block; }.arrow{ display: none; width:40px; height: 60px; background: rgba(0,0,0,.2); position: absolute; top: 50%; margin-top: -40px; }.left{ left: 0px; }.right{ right: 0px; }.arrow span{ display: none; width: 15px; height: 15px; border-bottom: 2px solid #fff; border-left: 2px solid #fff; }.slider_left{ margin-top:25px; margin-left: 15px; transform: rotate(45deg); }.slider_right{ margin-top:25px; margin-left: 5px; transform: rotate(-135deg); }.arrow:hover{background: #444}#slider:hover .arrow{display:block;}#slider:hover .arrow span{display:block;}.slider_icon{ width: 195px; height: 35px; background-color:hsla(0,0%,100%,.3); position: absolute; bottom: 0px; left: 50%; margin-left: -100px; border-radius: 30px; margin-bottom: 15px; z-index: 2; display: block; }.slider_icon i{ display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 11px; margin-left: 11px; margin-top: 13px; }.slider_icon:hover{background-color:rgba(0,0,0,.4);} .btn{ background: #fff; }.btn_act{ background: #FCD705 } js部分：12345678910111213141516171819202122232425var count=0;var $li=$(\".slider_list&gt;li\");var timer=setInterval(\"next()\",4000); function next() { count++; if (count==$li.length) { count=0; } $li.eq(count).fadeIn().siblings().fadeOut(); $(\".slider_icon&gt;i\").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); } $(\".right\").click(function(){next();}); $(\".left\").click(function(){ count--; if (count == -1) { count=$li.length-1; } $li.eq(count).fadeIn().siblings().fadeOut(); $(\".slider_icon&gt;i\").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); }) $(\".slider_icon&gt;i\").mouseenter(function(){ $(this).addClass('btn_act').siblings().removeClass('btn_act'); $li.eq($(this).index()).fadeIn().siblings().fadeOut(); count=$(this).index(); })","link":"/2020/06/06/用jQuery实现简单图片轮播效果 /"},{"title":"记Hexo + Github Pages博客搭建","text":"很早之前就听说可以通过github pages来搭建博客，但是由于种种原因（就是懒），迟迟没有付诸行动，终于，趁着暑假，开始了我的hexo+github pages 搭建博客的踩坑记，折腾了两天，终于成功搭建好了博客，接下来，开始分享搭建本博客的过程中以及各种坑。。。 用Hexo + Gitpages的原因 不用配置服务器 不用数据库 访问速度相当快 没有安全性可言 使用户可更注重博客内容 支持markdown还有就是hexo相对来说轻巧一些，生成文章的速度也比较快（静态博客生成页面时都是要整站生成，所以，页面越多，速度就越慢） 从hexo开始首先本地得装上了node.js、git和hexo 安装git：git 安装nodejs：node.js官网 hexo：hexo官网 hexo使用npm安装（过程如下） 1234npm install hexo-cli -ghexo init blogcd bloghexo server 然后打开http://localhost:4000/就可以查看效果了。如果4000端口打不开，可以通过以下命令更改端口访问(改为3000） 1hexo s -p 3000 注：Hexo依赖Node.js和Git，需要先安装。hexo的使用可参详官网文档。 常用命令： 1234hexo g 生成静态博客，即重新生成public文件夹hexo s 本地预览调试 (一般组合使用 hexo g &amp;&amp; hexo s)hexo d (发布到github)hexo n (执行该命令之后在source/_posts目录下产生&lt; blog name &gt;.md文件，这是你的一篇新博客。可以在markdown工具下编写，markdown工具在网上搜有一大堆，比如本博主使用的csdn的markdown工具，具体怎么使用也可以自己百度啦~） 部署到Github在github上创建一个仓库，仓库必须命名为：你的github账号.github.io(例如我的账号为Abner0101，所以我的仓库名为：Abner0101.github.io) 配置hexo config.yml，修改Deployment 1234deploy: type: git repo: git@github.com:你的帐号/你的帐号.github.com.git branch: master 然后执行命令： 123hexo cleanhexo ghexo d 此时，在博客的根目录下会生成一个文件夹：.deploy 然后我们把这个文件夹里面的文件都push到刚才新建那个项目就OK了。几分钟过后，就可以打开：你的用户名.github.io 看到你的博客了。 绑定域名在项目的根目录，新建名为CNAME的文件，内容为：你的域名，例如我的就是：jdsheng.cn再到把你的域名指向你的用户名.github.io，几分钟过后，就可以看到成功的诞生了。 NexT主题与第三方服务我使用的主题是next，在你的博客根目录下gitbash，安装next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件(_config.yml)，增加一行： 1theme: next 进入themes/next，修改主题配置文件 _config.yml 定位到scheme参数来选择自己喜欢的主题风格： 1scheme: Mist 关于next主题更多的配置（添加评论，分享，喜欢，添加头像等功能）可以参考NexT使用文档 关于更换电脑，如何继续写博客1.将你原来的电脑上已经配置好的源代码项目拷贝到你新的电脑，注意，无需拷贝全部，只需要拷贝一下几个目录： 12345_config.ymlpackage.jsonscaffolds/source/themes/ 将这些目录放在一个目录下，例如：blog/ 2.在你的新电脑上配置hexo环境：安装git、安装node.js3.安装hexo，执行命令： 1npm install -g hexo 4.安装好之后，在hexo目录下gitbash，执行命令： 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 5.部署，执行命令： 12 hexo ghexo d 在执行第5步时，可能会出错，不知道你们会不会遇到，反正我是遇到了，在部署提交代码的时候出现了这个问题： 123456*** Please tell me who you are.Run git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\"to set your account's default identity.Omit --global to set the identity only in this repository. 所以解决方法是当出现这个上述提示后 接着补充你在命令行中执行 12git config --global user.email \"你的邮箱\"git config --global user.name \"你的名字\" （注意 “ 前面是有空格的）输入后在接着执行hexo g、hexo d即可！","link":"/2020/06/06/记Hexo + Github pages博客搭建/"},{"title":"linux python后台运行以及查看log","text":"命令1nohup python -u run.py &gt; run.log 2&gt;&amp;1 &amp; 说明： &gt; 表示把标准输出（STDOUT）重定向到 那个文件，这里重定向到了run.log &amp; 表示在后台执行脚本，这样可以到达目的，但是，我们退出shell窗口的时候，必须用exit命令来退出，否则，退出之后，该进程也会随着shell的消失而消失（退出、关闭），所以有了第3步的指令nohup nohup(not hang up)：不挂断的运行命令 1是标准输出（STDOUT）的文件描述符，2是标准错误（STDERR）的文件描述符。1&gt; run.log 简化为 &gt; run.log，表示把标准输出重定向到run.log这个文件 2&gt;&amp;1 表示把标准错误重定向到标准输出，这里&amp;1表示标准输出 ， 为什么需要将标准错误重定向到标准输出的原因，是因为标准错误没有缓冲区，而STDOUT有。 这就会导致 commond &gt; run.log ，2&gt; run.log 文件python.log被两次打开，而STDOUT和 STDERR将会竞争覆盖，这肯定不是我门想要的 好了，我们现在可以直接关闭shell窗口（我用的是Xshell），而不用再输入exit这个命令来退出shell了，在当我们直接关闭shell窗口，再连接上服务器，查看Python的进程，发现进程还在。但是，在python运行中却查看不到输出！因为： python的输出有缓冲，导致run.log并不能够马上看到输出，使用-u参数，使得python不启用缓冲。 查看log文件如果要实时查看日志文件使用命令 1tail -f run.log 查看全部输出使用命令 1cat run.log 附加：linux常用指令1.查看当前后台运行的命令有两个命令可以用，jobs和ps,区别是jobs用于查看当前终端后台运行的任务，换了终端就看不到了。而ps命令用于查看瞬间进程的动态，可以看到别的终端运行的后台进程。 jobs命令：查看当前终端后台运行的任务 1jobs -l 可显示当前终端所有任务的PID，jobs的状态可以是running，stopped，Terminated。+ 号表示当前任务，- 号表示后一个任务。 ps命令：查看当前的所有进程 1ps -aux | grep python #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分 2.关闭当前后台运行的命令 kill命令：结束进程 通过ps命令查看进程号PID，然后执行 1kill PID 如果是前台进程的话，直接执行 Ctrl+c 就可以终止了 kill命令其他用法： 强制杀死进程 1kill -KILL pid 发送SIGHUP信号，可以使用一下信号 1kill -HUP pid 彻底杀死进程 1kill -9 pid 杀死指定用户所有进程 12kill -9 $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程 kill -u hnlinux //方法二 3.前后台进程的切换与控制 fg命令 功能：将后台中的命令调至前台继续运行 如果后台中有多个命令，可以先用jobs查看jobnun，然后用 fg %jobnum 将选中的命令调出。 Ctrl + z 命令功能：将一个正在前台执行的命令放到后台，并且处于暂停状态 bg命令功能：将一个在后台暂停的命令，变成在后台继续执行如果后台中有多个命令，可以先用jobs查看jobnum，然后用 bg %jobnum 将选中的命令调出继续执行。 4.运行Python示例 运行一个Python脚本，通常设置如下：1python test.py &gt;test.log &amp;","link":"/2020/06/18/linux python后台运行以及查看log/"}],"tags":[{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"echarts","slug":"echarts","link":"/tags/echarts/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Next","slug":"Next","link":"/tags/Next/"},{"name":"seo优化","slug":"seo优化","link":"/tags/seo优化/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java入门","slug":"Java入门","link":"/tags/Java入门/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"验证码","slug":"验证码","link":"/tags/验证码/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"BLOG","slug":"BLOG","link":"/categories/BLOG/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"NODE JS","slug":"NODE-JS","link":"/categories/NODE-JS/"},{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"LINUX","slug":"LINUX","link":"/categories/LINUX/"}]}