{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hexo博客NexT主题SEO优化","text":"刚搭建完博客，发现自己发表的文章在谷歌或者百度都搜索不到，今天看了一些文章，原来是需要seo优化的，所以就来总结一下seo优化的方法，让自己的博文能在谷歌百度上搜索到。本文主要以谷歌搜索为主。 添加站点地图–安装sitemap站点地图自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save –修改站点配置文件将sitemap文件添加到站点配置文件_config.yml中，并修改url字段的值，其值默认为https://yoursite.com(你的博客域名）。 123456sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlurl: https://abner0101.github.io 配置好后，执行hexo g 就能在站点public\\目录中生成sitemap.xml 和 baidusitemap.xml了;其中第一个是一会要提交给google的，后面那个看名字当然就是提交给Baidu的了； 添加蜘蛛协议在站点source文件夹下新建robots.txt文件，文件内容如下：（参考我的） 123456789101112131415User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://abner0101.github.io/sitemap.xmlSitemap: https://abner0101.github.io/baidusitemap.xml 其中Allow后面的就是你的menu请自行将abner0101.github.io改成自己的域名，然后hexo d -g提交一下 提交站点到Google打开Google Search Console，根据提示注册好之后，添加你的博客域名。 站点验证我选择了备用方法中的HTML 标记，将给出的元标记复制到\\themes\\hexo-theme-next\\layout_partials\\head.swig文件中。添加后运行hexo d -g将改动提交。稍后就可以验证成功了。 123456&lt;meta charset=\"UTF-8\"/&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"/&gt;&lt;meta name=\"theme-color\" content=\"{{ theme.android_chrome_color }}\"&gt;&lt;meta name=\"google-site-verification\" content=\"xxxxxxxxxxxxx\" /&gt;&lt;meta name=\"baidu-site-verification\" content=\"xxxxxxxxx\" /&gt; 测试robots.txt点击左侧的robots.txt测试工具，根据提示提交你的robots.txt，其实刚才我们已经提交了。 注意要0错误才可以，如果有错误的话，会有提示，改正确就可以了。 提交站点地图还记得我们刚才创建创建sitemap.xml文件吧,现在它要派上用场了。点击左侧工具栏的站点地图 Google 抓取方式提交站点地图之后，点击左侧的Google 抓取方式 这一步很重要！这一不很重要！这一步很重要！在这里我们填上我们需要抓取的url,不填这表示抓取首页，抓取方式可以选择桌面，智能手机等等，自行根据需要选择。填好url之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，自由这三种情况是可以提交的。提交完成后，提交至索引，根据提示操作就可以了。 网站结构自身优化出站链接添加nofollow标签网络爬虫会在当前页面搜索所有的链接，然后一个个查看，所以就很有可能跳到别的网站就不回来了。这个时候就需要nofollow起作用了。 nofollow标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 修改footer.swig文件路径在your-hexo-site\\themes\\next\\layout_partials，将下面代码中的a标签加上rel=”external nofollow”属性。 1{{ __('footer.powered', '&lt;a rel=\"external nofollow\" class=\"theme-link\" target=\"_blank\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt;') }} 1&lt;a rel=\"external nofollow\" class=\"theme-link\" target=\"_blank\" href=\"https://github.com/iissnan/hexo-theme-next\"&gt; 修改sidebar.swig文件路径在your-hexo-site\\themes\\next\\layout_macro，将下面代码中的a标签加上rel=”external nofollow”属性 1&lt;a href=\"https://creativecommons.org/{% if theme.creative_commons === 'zero' %}publicdomain/zero/1.0{% else %}licenses/{{ theme.creative_commons }}/4.0{% endif %}/\" rel=\"external nofollow\" class=\"cc-opacity\" target=\"_blank\"&gt; 1&lt;a href=\"{{ link }}\" title=\"{{ name }}\" rel=\"external nofollow\" target=\"_blank\"&gt;{{ name }}&lt;/a&gt; 1&lt;a rel=\"external nofollow\" href=\"{{ link.split('||')[0] | trim }}\" target=\"_blank\" title=\"{{ name }}\"&gt; 至此，seo优化得差不多了，还有很多可以优化的地方，博主日后再更新。马上上google搜索一下你的关键词和博客title测试一下吧！","link":"/2018/07/29/Hexo博客NexT主题SEO优化/"},{"title":"Git 基本知识与常用指令","text":"一、Git代码状态转换图其中： 未被Git跟踪的状态为unstage状态； 已被Git跟踪的状态为stage状态（stage：阶段），因此包括staging状态和staged状态。 untrack files：是指尚未被git所管理的文件； changed but not updated：是指文件被git管理，并且发生了改变，但改动还没被git管理；这两种状态，都可以看成是改动还没被git管理的状态，我们这里称unstage状态。 staging是commit和未管理之间的一个状态，也有别名叫index状态，也就是git已经管理了这些改动，但是还没完成提交。 changes to be commited是指进入staged状态的文件。 .gitignore中的文件，不会出现在以上三个状态中。 注： 这个图也解释了为啥从远端库拉代码，不需要add、commit。 代码一旦修改，就会成为未被git库跟踪的状态。需要add、commit。 二、大白话Git Git 管理代码，保证代码版本迭代连续性，即：向A分支merge或者push代码时，A分支代码必须是当前代码的上一个版本，不然会产生冲突。（换句话说：Git确保当前的本地的代码为最新） Git有修改就有提交，就有新的代码版本，git管理维护的是修改。 Git分支存储的是代码副本。 push ：实际上就是将本地分支合并到远端库分支；pull：实际就是将远端分支合并到本地分支。 三、Git本地常用操作指令 1、创建git库 git init #在当前目录中生成一个.git 目录（含有.git目录的目录即是git仓库） 2、注册git用户 —&gt;用于在团队合作开发中，表明代码作者。 12345git config --global user.name XXX #用户名git config --global user.email XXX #用户邮箱git config --list #查看用户信息 注：加–global，全局设置。 3、向git库添加修改 git add [path］ #会把对应目录或文件，添加到stage状态git add . #会把当前所有的untrack files和changed but not updated添加到stage状态 实际上是为修改内容添加index索引。 4、向版本库提交修改 git commit –m “XXXX” #提交修改,添加注释 注：git 提示： 未有add红色字体，未有commit绿色字体，已提交则worktree是干净的 5、查看当前代码库的状态 1git status 6、查看版本信息 —&gt;实际是查看修改提交信息 1git log git log --graph #以图形化（节点）展示当前git库的提交信息。 7、查看指定版本信息 git show sdjf974654dd…. #(show后面为每次提交系统自动生成的一串哈希值) git show sdji97 #一般只使用版本号的前几个字符即可 8、撤销修改 1git reset （1）撤销整体修改 git reset --hard #回到原来编辑的地方,改动会丢失。（同样适用于团队对于其他人的修改恢复）git reset --hard sdv143kvf…... #可回到指定的版本#(hard后面为每次提交系统自动生成的一串哈希值)git reset [path] 会改变path指定的文件或目录的stage状态，到非stage状态。git reset 会将所有stage的文件状态，都改变成非stage状态。 （2）撤销某次修改 回退1个change的写法就是git reset HEAD^，2个为HEAD^^，3个为HEAD~3，以此类推。 9、向远端库推送修改（提交修改） git push origin 分支名 10、暂存修改 git stash可以把当前的改动（stage和unstage，但不包括untrack的文件）暂存。 然后通过git stash list查看。 并通过git stash apply重新取出来。但apply之前要保证worktree是干净的。 四、Git团队开发常用操作指令1、获取远端库项目 1git clone/pull 2、团队开发的基本流程（多分支合并一个分支） git add . #添加改动的文件git commit #（提交至本地）git pull --rebase #（将服务器项目与本地项目合并）git push #（将本地项目上传至远端库）（在提交前要git pull –rebase 一下，确保当前的本地的代码为最新。） 五、Git 分支管理1、建立分支 git branch AAA #建立分支AAA 2、分支切换 git checkout AAA #从当前分支切换到AAA分支 (若AAA分支不存在，则自动新建) 3、将分支与主枝master合并 git checkout master #（首先切换回主枝）git merge AAA #（将分支AAA与主枝合并） 注：git merge：默认情况下，Git执行”快进式合并”（fast-farwardmerge），会直接将Master分支指向Develop分支。 使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰（保持提交曲线为直线），建议采用这种方法。 4、当前分支查看 git branch #默认有master（也称为主枝）git branch -r #查看远端库分支git branch –a #查看当前所有分支（包括本地分支和远端库分支） 5、删除分支 git branch –d AAA #删除分支AAA 6、切下远端库A分支到本地库A分支 git checkout -b A origin/A （若本地A分支不存在，则自动新建） 注：上面只是一些基本的操作命令，更多的命令可通过帮助文档查询。 帮助文档的使用：man git-&lt;需查询的指令&gt; #（git后面有“-”）如commit的查询为 man git-commit 六、本地代码上传Github Gtthub上建立远端仓库，复制下载链接。 本地指定目录下，Gitbash粘贴远端仓库下载链接拉取远端仓库代码 复制本地需要提交的代码到远端仓库目录。 Git add、commit、push 提交本地代码至Github远端仓库。","link":"/2019/10/01/Git 基本知识与常用指令/"},{"title":"JavaScript执行（三）：你知道现在有多少种函数吗？","text":"在前一篇文章中，我们大致了解了执行上下文是什么，也知道了任何语句的执行都会依赖特定的上下文。 一旦上下文被切换，整个语句的效果可能都会发生改变。那么，切换上下文的时机就显得非常重要了。 在 JavaScript，切换上下文最主要的场景是函数调用。在这一课，我们就来讲讲函数调用切换上下文的事情。我们在讲函数调用之前，首先来认识一下函数家族。 函数 在 ES2018 中，函数已经是一个很复杂的体系了，我在这里整理了一下。 第一种，普通函数：用 function 关键字定义的函数。 示例：123function foo(){ // code}第二种，箭头函数：用 =&gt; 运算符定义的函数。示例:123const foo = () =&gt; { // code}第三种，方法：在 class 中定义的函数。示例：12345class C { foo(){ //code }}第四种，生成器函数：用 function * 定义的函数。示例：123function foo*(){ // code}第五种，类：用 class 定义的类，实际上也是函数。示例：12345class Foo { constructor(){ //code }}第六 / 七 / 八种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。示例：123456789async function foo(){ // code}const foo = async () =&gt; { // code}async function foo*(){ // code}ES6 以来，大量加入的新语法极大地方便了我们编程的同时，也增加了很多我们理解的心智负担。要想认识这些函数的执行上下文切换，我们必须要对它们行为上的区别有所了解。","link":"/2019/03/25/JavaScript执行（三）：你知道现在有多少种函数吗？/"},{"title":"PHP知识点积累","text":"1、关于$_FILES 处理文件上传2、数组的定义和遍历3、关于命名空间的简单介绍","link":"/2018/09/17/PHP知识点积累/"},{"title":"node.js学习记录","text":"–node.js入门","link":"/2018/07/27/node.js学习记录/"},{"title":"vue常见问题及解决方法（一）","text":"列表进入详情页的传参问题 路由懒加载（也叫延迟加载） 列表进入详情页的传参问题关联知识点 ——路由跳转的方式声明式的跳转： 1234// query通过path切换路由&lt;router-link :to=\"{path: 'Detail', query: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=\"{name: 'Detail', params: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt; 编程式的跳转： 12345678910111213//跳转到上一次浏览的页面 this.$router.go(-1) //指定跳转的地址，我们自己设置的路由地址this.$router.replace('/pathname') //指定跳转路由的名字下，pathname是我们自身为路由设置的名字this.$router.replace({name:\"pathname\"}) //通过push进行跳转，我们自己设置的路由地址或者我们自己设置的名字this.$router.push('/pathname')this.$router.push({name:'pathname'})this.$router.push({ path: '/pathname/${id}'}) //id为参数 传参的方式：query、params+动态路由传参 两者的区别： query通过path切换路由，params通过name切换路由 1234// query通过path切换路由&lt;router-link :to=\"{path: 'Detail', query: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt;// params通过name切换路由&lt;router-link :to=\"{name: 'Detail', params: { id: 1 }}\"&gt;前往Detail页面&lt;/router-link&gt; query通过this.$route.query来接收参数，params通过this.$route.params来接收参数。 12345678// query通过this.$route.query接收参数created () { const id = this.$route.query.id;}// params通过this.$route.params来接收参数created () { const id = this.$route.params.id;} query传参的url展现方式：/detail?id=1&amp;user=123&amp;identity=1&amp;更多参数 params＋动态路由的url方式：/detail/123 params动态路由传参，一定要在路由中定义参数，然后在路由跳转的时候必须要加上参数，否则就是空白页面，而query传参则不用： 对应的路由配置： 12345{ path: '/detail/:id', name: 'Detail', component: Detail }, 注意，params传参时，如果没有在路由中定义参数，也是可以传过去的，同时也能接收到，但是一旦刷新页面，这个参数就不存在了。这对于需要依赖参数进行某些操作的行为是行不通的，因为你总不可能要求用户不能刷新页面吧。 例如： 1234567891011121314151617// 定义的路由中，只定义一个id参数{ path: 'detail/:id', name: 'Detail', components: Detail} // template中的路由传参，// 传了一个id参数和一个token参数// id是在路由中已经定义的参数，而token没有定义&lt;router-link :to=\"{name: 'Detail', params: { id: 1, token: '123456' }}\"&gt;前往Detail页面&lt;/router-link&gt;// 在详情页接收created () { // 以下都可以正常获取到 // 但是页面刷新后，id依然可以获取，而token此时就不存在了 const id = this.$route.params.id; const token = this.$route.params.token;} 参考： vue路由传参的三种基本方式 vue 关于路由跳转方法 路由懒加载（也叫延迟加载）路由懒加载可以帮我们在进入首屏时不用加载过度的资源，从而减少首屏加载速度。在路由文件中， 非懒加载写法： 12345678910import Index from '@/page/index/index';export default new Router({ routes: [ { path: '/', name: 'Index', component: Index } ]}) 路由懒加载写法： 123456789export default new Router({ routes: [ { path: '/', name: 'Index', component: resolve =&gt; require(['@/view/index/index'], resolve) } ]})","link":"/2019/07/10/vue常见问题及解决方法（一）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段三）","text":"前面讲了浏览器的 DOM 构建过程，但是这个构建的 DOM，实际上信息是不全的，它只有节点和属性，不包含任何的样式信息。 我们这一节课就来讲讲：浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的。 整体过程 首先我们还是要感性地理解一下这个过程。 首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。 我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS属性计算出来呢？ 答案是肯定的。 在这个过程中，我们依次拿到上一部构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。 我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下： 空格: 后代，选中它的子节点和所有子节点的后代节点。 &gt;: 子代，选中它的子节点。 +：直接后继选择器，选中它的下一个相邻节点。 ~：后继，选中它之后所有的相邻节点。 ||：列，选中表格中的一列。 关于选择器的知识，我会在 CSS 的部分继续讲解。这里我们主要介绍浏览器是如何实现这些规则的。不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。理解了 CSS 构建的大概过程，我们下面来看看具体的操作。首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector通过前面讲的符号连接起来的。后代选择器 “空格”我们先来分析一下后代选择器，我们来一起看一个例子：123a#b .cls { width: 100px;}可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：12345&lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt;&lt;/a&gt;&lt;span class=cls&gt;3&lt;span&gt;当遇到 &lt;/a&gt; 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。后继选择器“ ~ ”接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：123456789101112.cls~* { border:solid 1px green;}&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它的后继，因此应该被选中。按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。注意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。子代选择器“ &gt;”我们继续看，子代选择器是如何实现的。实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。123456789101112div&gt;.cls { border:solid 1px green;}&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。直接后继选择器“ +”直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。另外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。你可以尝试一下，告诉我结果。列选择器“ || ”列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。其它我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。比如123a#b, .cls {}我们当作两条规则来处理：123a#b {}123.cls {}还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：12345678910#a .cls {}#a span {}#a&gt;span {}这里实际上可以把选择器构造成一棵树： #a &lt; 空格 &gt;.cls &lt; 空格 &gt;span &gt;span 需要注意的是，这里的树，必须要带上连接符。结语这一节我们讲解了 CSS 计算的过程。CSS 计算是把 CSS 规则应用到 DOM 树上，为 DOM 结构添加显示相关属性的过程。在这一节中，我们主要介绍了选择器的几种复合结构应该如何实现。在这一步骤之后，我们得到了一棵带有 CSS 属性的树，为我们后续继续显式打下了基础。最后留一个问题，你认为 CSS 语法解析成什么结构，最适合我们进行 CSS 计算。转自—《重学前端》","link":"/2019/03/23/浏览器：一个浏览器是如何工作的（阶段三）/"},{"title":"用jQuery实现简单的图片轮播效果","text":"以下代码使用了jQuery来实现简单的图片轮播效果： html部分： 12345678910111213141516171819202122&lt;div id=\"slider\"&gt; &lt;ul class=\"slider_list\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"4.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"5.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"6.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"7.jpeg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"8.jpg\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"slider_icon\"&gt; &lt;i class=\"btn btn_act\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;i class=\"btn\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;a href=\"javascript:;\" class=\"arrow left\"&gt; &lt;span class=\"slider_left\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a href=\"javascript:;\" class=\"arrow right\"&gt; &lt;span class=\"slider_right\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; css部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#slider{ width: 750px; height: 450px; margin: 10% auto; position: relative; border: 0px red solid }#slider img{ width: 750px; height: 450px; }li{ list-style: none; }.slider_list li{ position: absolute; display: none; }.slider_list li:first-child{ display: block; }.arrow{ display: none; width:40px; height: 60px; background: rgba(0,0,0,.2); position: absolute; top: 50%; margin-top: -40px; }.left{ left: 0px; }.right{ right: 0px; }.arrow span{ display: none; width: 15px; height: 15px; border-bottom: 2px solid #fff; border-left: 2px solid #fff; }.slider_left{ margin-top:25px; margin-left: 15px; transform: rotate(45deg); }.slider_right{ margin-top:25px; margin-left: 5px; transform: rotate(-135deg); }.arrow:hover{background: #444}#slider:hover .arrow{display:block;}#slider:hover .arrow span{display:block;}.slider_icon{ width: 195px; height: 35px; background-color:hsla(0,0%,100%,.3); position: absolute; bottom: 0px; left: 50%; margin-left: -100px; border-radius: 30px; margin-bottom: 15px; z-index: 2; display: block; }.slider_icon i{ display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 11px; margin-left: 11px; margin-top: 13px; }.slider_icon:hover{background-color:rgba(0,0,0,.4);} .btn{ background: #fff; }.btn_act{ background: #FCD705 } js部分：12345678910111213141516171819202122232425var count=0;var $li=$(\".slider_list&gt;li\");var timer=setInterval(\"next()\",4000); function next() { count++; if (count==$li.length) { count=0; } $li.eq(count).fadeIn().siblings().fadeOut(); $(\".slider_icon&gt;i\").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); } $(\".right\").click(function(){next();}); $(\".left\").click(function(){ count--; if (count == -1) { count=$li.length-1; } $li.eq(count).fadeIn().siblings().fadeOut(); $(\".slider_icon&gt;i\").eq(count).addClass('btn_act').siblings().removeClass('btn_act'); }) $(\".slider_icon&gt;i\").mouseenter(function(){ $(this).addClass('btn_act').siblings().removeClass('btn_act'); $li.eq($(this).index()).fadeIn().siblings().fadeOut(); count=$(this).index(); })","link":"/2018/09/09/用jQuery实现简单图片轮播效果 /"},{"title":"记Hexo + Github Pages博客搭建","text":"很早之前就听说可以通过github pages来搭建博客，但是由于种种原因（就是懒），迟迟没有付诸行动，终于，趁着暑假，开始了我的hexo+github pages 搭建博客的踩坑记，折腾了两天，终于成功搭建好了博客，接下来，开始分享搭建本博客的过程中以及各种坑。。。 用Hexo + Gitpages的原因 不用配置服务器 不用数据库 访问速度相当快 没有安全性可言 使用户可更注重博客内容 支持markdown还有就是hexo相对来说轻巧一些，生成文章的速度也比较快（静态博客生成页面时都是要整站生成，所以，页面越多，速度就越慢） 从hexo开始首先本地得装上了node.js、git和hexo 安装git：git 安装nodejs：node.js官网 hexo：hexo官网 hexo使用npm安装（过程如下） 1234npm install hexo-cli -ghexo init blogcd bloghexo server 然后打开http://localhost:4000/就可以查看效果了。如果4000端口打不开，可以通过以下命令更改端口访问(改为3000） 1hexo s -p 3000 注：Hexo依赖Node.js和Git，需要先安装。hexo的使用可参详官网文档。 常用命令： 1234hexo g 生成静态博客，即重新生成public文件夹hexo s 本地预览调试 (一般组合使用 hexo g &amp;&amp; hexo s)hexo d (发布到github)hexo n (执行该命令之后在source/_posts目录下产生&lt; blog name &gt;.md文件，这是你的一篇新博客。可以在markdown工具下编写，markdown工具在网上搜有一大堆，比如本博主使用的csdn的markdown工具，具体怎么使用也可以自己百度啦~） 部署到Github在github上创建一个仓库，仓库必须命名为：你的github账号.github.io(例如我的账号为Abner0101，所以我的仓库名为：Abner0101.github.io) 配置hexo config.yml，修改Deployment 1234deploy: type: git repo: git@github.com:你的帐号/你的帐号.github.com.git branch: master 然后执行命令： 123hexo cleanhexo ghexo d 此时，在博客的根目录下会生成一个文件夹：.deploy 然后我们把这个文件夹里面的文件都push到刚才新建那个项目就OK了。几分钟过后，就可以打开：你的用户名.github.io 看到你的博客了。 绑定域名在项目的根目录，新建名为CNAME的文件，内容为：你的域名，例如我的就是：jdsheng.cn再到把你的域名指向你的用户名.github.io，几分钟过后，就可以看到成功的诞生了。 NexT主题与第三方服务我使用的主题是next，在你的博客根目录下gitbash，安装next主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 打开站点配置文件(_config.yml)，增加一行： 1theme: next 进入themes/next，修改主题配置文件 _config.yml 定位到scheme参数来选择自己喜欢的主题风格： 1scheme: Mist 关于next主题更多的配置（添加评论，分享，喜欢，添加头像等功能）可以参考NexT使用文档 关于更换电脑，如何继续写博客1.将你原来的电脑上已经配置好的源代码项目拷贝到你新的电脑，注意，无需拷贝全部，只需要拷贝一下几个目录： 12345_config.ymlpackage.jsonscaffolds/source/themes/ 将这些目录放在一个目录下，例如：blog/ 2.在你的新电脑上配置hexo环境：安装git、安装node.js3.安装hexo，执行命令： 1npm install -g hexo 4.安装好之后，在hexo目录下gitbash，执行命令： 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 5.部署，执行命令： 12 hexo ghexo d 在执行第5步时，可能会出错，不知道你们会不会遇到，反正我是遇到了，在部署提交代码的时候出现了这个问题： 123456*** Please tell me who you are.Run git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\"to set your account's default identity.Omit --global to set the identity only in this repository. 所以解决方法是当出现这个上述提示后 接着补充你在命令行中执行 12git config --global user.email \"你的邮箱\"git config --global user.name \"你的名字\" （注意 “ 前面是有空格的）输入后在接着执行hexo g、hexo d即可！","link":"/2018/07/27/记Hexo + Github pages博客搭建/"},{"title":"JavaScript对象：你知道全部的对象分类吗？","text":"前面讲解了 JavaScript 对象的一些基础知识。但是，我们所讲解的对象，只是特定的一部分，并不能涵盖全部的 JavaScript 对象。比如说，我们不论怎样编写代码，都没法绕开 Array，实现一个跟原生的数组行为一模一样的对象，这是由于原生数组的底层实现了一个自动随着下标变化的 length 属性。并且，在浏览器环境中，我们也无法单纯依靠 JavaScript 代码实现 div 对象，只能靠 document.createElement 来创建。这也说明了 JavaScript 的对象机制并非简单的属性集合 + 原型。我们日常工作中，接触到的主要 API，几乎都是由今天所讲解的这些对象提供的。理解这些对象的性质，我们才能真正理解我们使用的 API 的一些特性。JavaScript 中的对象分类我们可以把对象分成几类。宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。下面我会为你一一讲解普通对象之外的对象类型。宿主对象首先我们来看看宿主对象。JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。JavaScript 标准中规定了全局对象属性，w3c 的各种标准中规定了 Window 对象的其它属性。宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 dom 对象。宿主也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素，这些我们会在浏览器的 API 部分详细讲解。内置对象·固有对象我们在前面说过，固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“类”其实就是固有对象的一种。ECMA 标准为我们提供了一份固有对象表，里面含有 150+ 个固有对象。你可以通过这个链接查看。但是遗憾的是，这个表格并不完整。所以在本篇的末尾，我设计了一个小实验（小实验：获取全部 JavaScript 固有对象），你可以自己尝试一下，数一数一共有多少个固有对象。内置对象·原生对象我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。这些构造器创建的对象多数使用了私有字段, 例如：Error: [[ErrorData]]Boolean: [[BooleanData]]Number: [[NumberData]]Date: [[DateValue]]RegExp: [[RegExpMatcher]]Symbol: [[SymbolData]]Map: [[MapData]]这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。用对象来模拟函数与构造器：函数对象与构造器对象我在前面介绍了对象的一般分类，在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。事实上，JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。JavaScript 用对象模拟函数的设计代替了一般编程语言中的函数，它们可以像其它语言的函数一样被调用、传参。任何宿主只要提供了“具有 [[call]] 私有字段的对象”，就可以被 JavaScript 函数调用语法支持。[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。我们可以这样说，任何对象只需要实现 [[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现 [[construct]]，它就是一个构造器对象，可以作为构造器被调用。对于为 JavaScript 提供运行环境的程序员来说，只要字段符合，我们在上文中提到的宿主对象和内置对象（如 Symbol 函数）可以模拟函数和构造器。当然了，用户用 function 关键字创建的函数必定同时是函数和构造器。不过，它们表现出来的行为效果却并不相同。对于宿主和内置对象来说，它们实现 [[call]]（作为函数被调用）和 [[construct]]（作为构造器被调用）不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数时，则产生字符串，见以下代码：12console.log(new Date); // 1console.log(Date())而浏览器宿主环境中，提供的 Image 构造器，则根本不允许被作为函数调用。12console.log(new Image); console.log(Image());// 抛出错误再比如基本类型（String、Number、Boolean），它们的构造器被当作函数调用，则产生类型转换的效果。值得一提的是，在 ES6 之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用，见以下代码：1new (a =&gt; 0) // error对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]] 和 [[construct]] 行为总是相似的，它们执行同一段代码。我们看一下示例。12345function f(){ return 1;}var v = f(); // 把 f 作为函数调用var o = new f(); // 把 f 作为构造器调用我们大致可以认为，它们 [[construct]] 的执行过程如下：以 Object.protoype 为原型创建一个新对象；以新对象为 this，执行函数的 [[call]]；如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。123456789function cls(){ this.a = 100; return { getValue:() =&gt; this.a }}var o = new cls;o.getValue(); //100//a 在外面永远无法访问到特殊行为的对象除了上面介绍的对象之外，在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同，这里我简单总结一下。Array：Array 的 length 属性根据最大的下标自动发生变化。Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。Arguments：arguments 的非负整数型下标属性跟对应的变量联动。模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。bind 后的 function：跟原来的函数相关联。总结在这篇文章中，我们介绍了一些不那么常规的对象，并且我还介绍了 JavaScript 中用对象来模拟函数和构造器的机制。这是一些不那么有规律、不那么优雅的知识，而 JavaScript 正是通过这些对象，提供了很多基础的能力。我们这次课程留给大家一个挑战任务：不使用 new 运算符，尽可能找到获得对象的方法。例子：12var o = {}var o = function(){}请大家把自己的答案留言给我，我们来比比看谁找到的多。小实验：获取全部 JavaScript 固有对象我们从 JavaScript 标准中可以找到全部的 JS 对象定义。JS 语言规定了全局对象的属性。三个值：Infinity、NaN、undefined。九个函数：evalisFiniteisNaNparseFloatparseIntdecodeURIdecodeURIComponentencodeURIencodeURIComponent一些构造器：Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeapSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeErrorURIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。四个用于当作命名空间的对象：AtomicsJSONMathReflect我们使用广度优先搜索，查找这些对象所有的属性和 Getter/Setter，就可以获得 JavaScript 中所有的固有对象。请你试着先不看我的代码，在自己的浏览器中计算出来 JavaScript 有多少固有对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var set = new Set();var objects = [ eval, isFinite, isNaN, parseFloat, parseInt, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, Array, Date, RegExp, Promise, Proxy, Map, WeakMap, Set, WeakSet, Function, Boolean, String, Number, Symbol, Object, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, ArrayBuffer, SharedArrayBuffer, DataView, Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Atomics, JSON, Math, Reflect];objects.forEach(o =&gt; set.add(o));for(var i = 0; i &lt; objects.length; i++) { var o = objects[i] for(var p of Object.getOwnPropertyNames(o)) { var d = Object.getOwnPropertyDescriptor(o, p) if( (d.value !== null &amp;&amp; typeof d.value === \"object\") || (typeof d.value === \"function\")) if(!set.has(d.value)) set.add(d.value), objects.push(d.value); if( d.get ) if(!set.has(d.get)) set.add(d.get), objects.push(d.get); if( d.set ) if(!set.has(d.set)) set.add(d.set), objects.push(d.set); }}转自—《重学前端》","link":"/2019/03/25/JavaScript对象：你知道全部的对象分类吗？/"},{"title":"JavaScript对象：我们真的需要模拟类吗？","text":"早期的 JavaScript 程序员一般都有过使用 JavaScript“模拟面向对象”的经历。 在上一篇文章我们已经讲到，JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才让很多人产生了误会。 那么，随着我们理解的思路继续深入，这些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。 尽管我认为，“类”并非面向对象的全部，但我们不应该责备社区出现这样的方案，事实上，因为一些公司的政治原因，JavaScript 推出之时，管理层就要求它去模仿 Java。 所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来语法更像 Java”，而 Java 正是基于类的面向对象的代表语言之一。 但是 JavaScript 这样的半吊子模拟，缺少了继承等关键特性，导致大家试图对它进行修补，进而产生了种种互不相容的解决方案。 庆幸的是，从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。 实际上，我认为“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。 我们从头讲起。 什么是原型？ 原型是顺应人类自然思维的产物。中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型，所以，由此我们可以看出，用原型来描述对象的方法可以说是古已有之。 我们在上一节讲解面向对象的时候提到了：在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象。 最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。这个流派叫做基于类的编程语言。 还有一种就是基于原型的编程语言，它们利用原型来描述对象。我们的 JavaScript 就是其中代表。 “基于类”的编程提倡使用一个关注分类和类之间关系开发模型。在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。 与此相对，“基于原型”的编程看起来更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。 基于原型的面向对象系统通过“复制”的方式来创建新对象。一些语言的实现中，还允许复制一个空对象。这实际上就是创建一个全新的对象。 基于原型和基于类都能够满足基本的复用和抽象需求，但是适用的场景不太相同。 这就像专业人士可能喜欢在看到老虎的时候，喜欢用猫科豹属豹亚种来描述它，但是对一些不那么正式的场合，“大猫”可能更为接近直观的感受一些（插播一个冷知识：比起老虎来，美洲狮在历史上相当长时间都被划分为猫科猫属，所以性格也跟猫更相似，比较亲人）。 我们的 JavaScript 并非第一个使用原型的语言，在它之前，self、kevo 等语言已经开始使用原型来描述对象了。 事实上，Brendan 更是曾透露过，他最初的构想是一个拥有基于原型的面向对象能力的 scheme 语言（但是函数式的部分是另外的故事，这篇文章里，我暂时不做详细讲述）。 在 JavaScript 之前，原型系统就更多与高动态性语言配合，并且多数基于原型的语言提倡运行时的原型修改，我想，这应该是 Brendan 选择原型系统很重要的理由。 原型系统的“复制操作”有两种实现思路： 一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用； 另一个是切实地复制对象，从此两个对象再无关联。 历史上的基于原型语言因此产生了两个流派，显然，JavaScript 显然选择了前一种方式。 JavaScript 的原型 如果我们抛开 JavaScript 用于模拟 Java 类的复杂语法设施（如 new、Function Object、函数的 prototype 属性等），原型系统可以说相当简单，我可以用两条概括： 如果所有对象都有私有字段 [[prototype]]，就是对象的原型； 读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。 这个模型在 ES 的各个历史版本中并没有很大改变，但从 ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。三个方法分别为： Object.create 根据指定的原型创建新对象，原型可以是 null； Object.getPrototypeOf 获得一个对象的原型； Object.setPrototypeOf 设置一个对象的原型。 利用这三个方法，我们可以完全抛开类的思维，利用原型来实现抽象和复用。我用下面的代码展示了用原型来抽象猫和虎的例子。12345678910111213141516171819202122232425262728var cat = { say(){ console.log(\"meow~\"); }, jump(){ console.log(\"jump\"); }}var tiger = Object.create(cat, { say:{ writable:true, configurable:true, enumerable:true, value:function(){ console.log(\"roar!\"); } }})var anotherCat = Object.create(cat);anotherCat.say();var anotherTiger = Object.create(tiger);anotherTiger.say();这段代码创建了一个“猫”对象，又根据猫做了一些修改创建了虎，之后我们完全可以用 Object.create 来创建另外的猫和虎对象，我们可以通过“原始猫对象”和“原始虎对象”来控制所有猫和虎的行为。但是，在更早的版本中，程序员只能通过 Java 风格的类接口来操纵原型运行时，可以说非常别扭。考虑到 new 和 prototype 属性等基础设施今天仍然有效，而且被很多代码使用，学习这些知识也有助于我们理解运行时的原型工作原理，下面我们试着回到过去，追溯一下早年的 JavaScript 中的原型和类。早期版本中的类与原型在早期版本的 JavaScript 中，“类”的定义是一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了 [[class]] 属性，以表示它们的类。语言使用者唯一可以访问 [[class]] 属性的方式是 Object.prototype.toString。以下代码展示了所有具有内置 class 属性的对象：1234567891011var o = new Object;var n = new Number;var s = new String;var b = new Boolean;var d = new Date;var arg = function(){ return arguments }();var r = new RegExp;var f = new Function;var arr = new Array;var e = new Error;console.log([o, n, s, b, d, arg, r, f, arr, e].map(v =&gt; Object.prototype.toString.call(v)));因此，在 ES3 和之前的版本，JS 中类的概念是相当弱的，它仅仅是运行时的一个字符串属性。在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为：12var o = { [Symbol.toStringTag]: \"MyObject\" }console.log(o + \"\");这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响。但是，考虑到 JavaScript 语法中跟 Java 相似的部分，我们对类的讨论不能用“new 运算是针对构造器对象，而不是类”来试图回避。所以，我们仍然要把 new 理解成 JavaScript 面向对象的一部分，下面我就来讲一下 new 操作具体做了哪些事情。new 运算接受一个构造器和一组调用参数，实际上做了几件事：以构造器的 prototype 属性（注意与私有字段 [[prototype]] 的区分）为原型，创建新对象；将 this 和调用参数传给构造器，执行；如果构造器返回的是对象，则返回，否则返回第一步创建的对象。new 这样的行为，试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。下面代码展示了用构造器模拟类的两种方法:123456789101112131415161718192021function c1(){ this.p1 = 1; this.p2 = function(){ console.log(this.p1); }} var o1 = new c1;o1.p2();function c2(){}c2.prototype.p1 = 1;c2.prototype.p2 = function(){ console.log(this.p1);}var o2 = new c2;o2.p2();第一种方法是直接在构造器中修改 this，给 this 添加属性。第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法（当时的 mozilla 提供了私有属性 proto，但是多数环境并不支持），所以，当时已经有人试图用它来代替后来的 Object.create，我们甚至可以用它来实现一个 Object.create 的不完整的 pollyfill，见以下代码：12345Object.create = function(prototype){ var cls = function(){} cls.prototype = prototype; return new cls;}这段代码创建了一个空函数作为类，并把传入的原型挂在了它的 prototype，最后创建了一个它的实例，根据 new 的行为，这将产生一个以传入的第一个参数为原型的对象。这个函数无法做到与原生的 Object.create 一致，一个是不支持第二个参数，另一个是不支持 null 作为原型，所以放到今天意义已经不大了。ES6 中的类好在 ES6 中加入了新特性 class，new 跟 function 搭配的怪异行为终于可以退休了（虽然运行时没有改变），在任何场景，我都推荐使用 ES6 的语法来定义类，而令 function 回归原本的函数语义。下面我们就来看一下 ES6 中的类。ES6 中引入了 class 关键字，并且在标准中删除了所有 [[class]] 相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。我们先看下类的基本写法：1234567891011121314class Rectangle { constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea(); } // Method calcArea() { return this.height * this.width; }}在现有的类语法中，getter/setter 和 method 是兼容性最好的。我们通过 get/set 关键字来创建 getter，通过括号和大括号来创建方法，数据型成员最好写在构造器里面。类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。此外，最重要的是，类提供了继承能力。我们来看一下下面的代码。12345678910111213141516171819202122class Animal { constructor(name) { this.name = name; } speak() { console.log(this.name + ' makes a noise.'); }}class Dog extends Animal { constructor(name) { super(name); // call the super class constructor and pass in the name parameter } speak() { console.log(this.name + ' barks.'); }}let d = new Dog('Mitzie');d.speak(); // Mitzie barks.以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。一些激进的观点认为，class 关键字和箭头运算符可以完全替代旧的 function 关键字，它更明确地区分了定义函数和定义类两种意图，我认为这是有一定道理的。总结在新的 ES 版本中，我们不再需要模拟类了：我们有了光明正大的新语法。而原型体系同时作为一种编程范式和运行时机制存在。我们可以自由选择原型或者类作为代码的抽象风格，但是无论我们选择哪种，理解运行时的原型系统都是很有必要的一件事。在你的工作中，是使用 class 还是仍然在用 function 来定义“类”？为什么这么做？如何把使用 function 定义类的代码改造到 class 的新语法？欢迎给我留言，我们一起讨论。转自—《重学前端》","link":"/2019/03/25/JavaScript对象：我们真的需要模拟类吗？/"},{"title":"JavaScript对象：面向对象还是基于对象？","text":"与其它的语言相比，JavaScript 中的“对象”总是显得不那么合群。 一些新人在学习 JavaScript 面向对象时，往往也会有疑惑： 为什么 JavaScript（直到 ES6）有对象的概念，但是却没有像其他的语言那样，有类的概念呢； 为什么在 JavaScript 对象里可以自由添加属性，而其他的语言却不能呢？ 甚至，在一些争论中，有人强调：JavaScript 并非“面向对象的语言”，而是“基于对象的语言”。这个说法一度流传甚广，而事实上，我至今遇到的持有这一说法的人中，无一能够回答“如何定义面向对象和基于对象”这个问题。 实际上，基于对象和面向对象两个形容词都出现在了 JavaScript 标准的各个版本当中。 我们可以先看看 JavaScript 标准对基于对象的定义，这个定义的具体内容是：“语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”。 这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。 那么，在本篇文章中，我会尝试让你去理解面向对象和 JavaScript 中的面向对象究竟是什么。 什么是面向对象？ 我们先来说说什么是对象，因为翻译的原因，中文语境下我们很难理解“对象”的真正含义。事实上，Object（对象）在英文中，是一切事物的总称，这和面向对象编程的抽象思维有互通之处。 中文的“对象”却没有这样的普适性，我们在学习编程的过程中，更多是把它当作一个专业名词来理解。 但不论如何，我们应该认识到，对象并不是计算机领域凭空造出来的概念，它是顺着人类思维模式产生的一种抽象（于是面向对象编程也被认为是：更接近人类思维模式的一种编程范式）。 那么，我们先来看看在人类思维模式下，对象究竟是什么。 对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。 在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。 在《面向对象分析与设计》这本书中，Grady Booch 替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一： 一个可以触摸或者可以看见的东西； 人的智力可以理解的东西； 可以指导思考或行动（进行想象或施加动作）的东西。 有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。 而 JavaScript 早年却选择了一个更为冷门的方式：原型（关于原型，我在下一篇文章会重点介绍，这里你留个印象就可以了）。这是我在前面说它不合群的原因之一。 然而很不幸，因为一些公司政治原因，JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this等语言特性，使之“看起来更像 Java”。 在 ES6 出现之前，大量的 JavaScript 程序员试图在原型体系的基础上，把 JavaScript 变得更像是基于类的编程，进而产生了很多所谓的“框架”，比如 PrototypeJS、Dojo。 事实上，它们成为了某种 JavaScript 的古怪方言，甚至产生了一系列互不相容的社群，显然这样做的收益是远远小于损失的。 如果我们从运行时角度来谈论对象，就是在讨论 JavaScript 实际运行中的模型，这是由于任何代码执行都必定绕不开运行时的对象模型。 不过，幸运的是，从运行时的角度看，可以不必受到这些“基于类的设施”的困扰，这是因为任何语言运行时类的概念都是被弱化的。 首先我们来了解一下 JavaScript 是如何设计对象模型的。 JavaScript 对象的特征 在我看来，不论我们使用什么样的编程语言，我们都先应该去理解对象的本质特征（参考 Grandy Booch《面向对象分析与设计》）。总结来看，对象有如下几个特点。 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。 对象有状态：对象具有状态，同一对象可能处于不同状态之下。 对象具有行为：即对象的状态，可能因为它的行为产生变迁。 我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。 所以，JavaScript 程序员都知道，任何不同的 JavaScript 对象其实是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一模一样的对象，但是打印出来的结果却是 false。123var o1 = { a: 1 };var o2 = { a: 1 };console.log(o1 == o2); // false关于对象的第二个和第三个特征“状态和行为”，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为“成员变量”和“成员函数”，Java 中则称它们为“属性”和“方法”。在 JavaScript 中，将状态和行为统一抽象为“属性”，考虑到 JavaScript 中将函数设计成一种特殊对象（关于这点，我会在后面的文章中详细讲解，此处先不用细究），所以 JavaScript 中的行为和状态都能用属性来抽象。下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。123456var o = { d: 1, f() { console.log(this.d); } };所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性。如果你用过 Java，一定不要觉得奇怪，尽管设计思路有一定差别，但是二者都很好地表现了对象的基本特征：标识性、状态和行为。在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。我来举个例子，比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。123var o = { a: 1 };o.b = 2;console.log(o.a, o.b); //1 2为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类。JavaScript 对象的两类属性对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。 value：就是属性的值。 writable：决定属性能否被赋值。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。在大多数情况下，我们只关心数据属性的值即可。第二类属性是访问器（getter/setter）属性，它也有四个特征。 getter：函数或 undefined，在取属性值时被调用。 setter：函数或 undefined，在设置属性值时被调用。 enumerable：决定 for in 能否枚举该属性。 configurable：决定该属性能否被删除或者改变特征值。访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。我们可以使用内置函数 Object.getOwnPropertyDescripter 来查看，如以下代码所示：12345var o = { a: 1 };o.b = 2;//a 和 b 皆为数据属性Object.getOwnPropertyDescriptor(o,\"a\") // {value: 1, writable: true, enumerable: true, configurable: true}Object.getOwnPropertyDescriptor(o,\"b\") // {value: 2, writable: true, enumerable: true, configurable: true}我们在这里使用了两种语法来定义属性，定义完属性后，我们用 JavaScript 的 API 来查看这个属性，我们可以发现，这样定义出来的属性都是数据属性，writeable、enumerable、configurable 都是默认值为 true。如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty，示例如下：1234567var o = { a: 1 };Object.defineProperty(o, \"b\", {value: 2, writable: false, enumerable: false, configurable: true});//a 和 b 都是数据属性，但特征值变化了Object.getOwnPropertyDescriptor(o,\"a\"); // {value: 1, writable: true, enumerable: true, configurable: true}Object.getOwnPropertyDescriptor(o,\"b\"); // {value: 2, writable: false, enumerable: false, configurable: true}o.b = 3;console.log(o.b); // 2这里我们使用了 Object.defineProperty 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性，代码如下所示：123var o = { get a() { return 1 } };console.log(o.a); // 1访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。这样，我们就理解了，实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。对象是一个属性的索引结构（索引结构是一类常见的数据结构，我们可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。我们以上面的对象 o 为例，你可以想象一下“a”是 key。{writable:true,value:1,configurable:true,enumerable:true} 是 value。我们在前面的类型课程中，已经介绍了 Symbol 类型，能够以 Symbol 为属性名，这是 JavaScript 对象的一个特色。讲到了这里，如果你理解了对象的特征，也就不难理解我开篇提出来的问题。你甚至可以理解为什么会有“JavaScript 不是面向对象”这样的说法了。这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。可事实上，这样的对象系统设计虽然特别，但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式（下一节课我们会给你介绍 JavaScript中两种面向对象编程的范式：基于类和基于原型），所以它也是正统的面向对象语言。JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。所以，我们应该在理解其设计思想的基础上充分挖掘它的能力，而不是机械地模仿其它语言。结语要想理解 JavaScript 对象，必须清空我们脑子里“基于类的面向对象”相关的知识，回到人类对对象的朴素认知和面向对象的语言无关基础理论，我们就能够理解 JavaScript 面向对象设计的思路。在这篇文章中，我从对象的基本理论出发，和你理清了关于对象的一些基本概念，分析了 JavaScript 对象的设计思路。接下来又从运行时的角度，介绍了 JavaScript 对象的具体设计：具有高度动态性的属性集合。很多人在思考 JavaScript 对象时，会带着已有的“对象”观来看问题，最后的结果当然就是“剪不断理还乱”了。在后面的文章中，我会继续带你探索 JavaScript 对象的一些机制，看 JavaScript 如何基于这样的动态对象模型设计自己的原型系统，以及你熟悉的函数、类等基础设施。转自—《重学前端》","link":"/2019/03/25/JavaScript对象：面向对象还是基于对象？/"},{"title":"JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？","text":"这一部分我们来讲一讲 JavaScript 的执行。 首先我们考虑一下，如果我们是浏览器或者 Node 的开发者，我们该如何使用 JavaScript 引擎。 当拿到一段 JavaScript 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。 然而，执行 JavaScript 并非一锤子买卖，宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行，此外，我们可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。 所以，我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。 在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。 但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。 由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。 宏观和微观任务 JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。 不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：1234while(TRUE) { r = wait(); execute(r);}我们可以看到，整个循环做的事情基本上就是反复“等待 - 执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑，这里为了方便你理解，我就把这些都省略掉了。这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：有了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。接下来，我们来详细介绍一下 Promise。PromisePromise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。Promise 的基本用法示例如下：123456function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); })}sleep(1000).then( ()=&gt; console.log(\"finished\"));这段代码定义了一个函数 sleep，它的作用是等候传入参数指定的时长。Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序，我们来看一段代码示例：123456var r = new Promise(function(resolve, reject){ console.log(\"a\"); resolve()});r.then(() =&gt; console.log(\"c\"));console.log(\"b\")我们执行这段代码后，注意输出的顺序是 a b c。在进入 console.log(“b”) 之前，毫无疑问 r 已经得到了 resolve，但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。接下来我们试试跟 setTimeout 混用的 Promise。在这段代码中，我设置了两段互不相干的异步操作：通过 setTimeout 执行 console.log(“d”)，通过 Promise 执行 console.log(“c”)1234567var r = new Promise(function(resolve, reject){ console.log(\"a\"); resolve()});setTimeout(()=&gt;console.log(\"d\"), 0)r.then(() =&gt; console.log(\"c\"));console.log(\"b\")我们发现，不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。为了理解微任务始终先于宏任务，我们设计一个实验：执行一个耗时 1 秒的 Promise。123456789101112setTimeout(()=&gt;console.log(\"d\"), 0)var r1 = new Promise(function(resolve, reject){ resolve()});r.then(() =&gt; { var begin = Date.now(); while(Date.now() - begin &lt; 1000); console.log(\"c1\") new Promise(function(resolve, reject){ resolve() }).then(() =&gt; console.log(\"c2\"))});这里我们强制了 1 秒的执行耗时，这样，我们可以确保任务 c2 是在 d 之后被添加到任务队列。我们可以看到，即使耗时一秒的 c1 执行完毕，再 enque 的 c2，仍然先于 d 执行了，这很好地解释了微任务优先的原理。通过一系列的实验，我们可以总结一下如何分析异步执行的顺序：首先我们分析有多少个宏任务；在每个宏任务中，分析有多少个微任务；根据调用次序，确定宏任务中的微任务执行次序；根据宏任务的触发规则和调用次序，确定宏任务的执行次序；确定整个顺序。我们再来看一个稍微复杂的例子：12345678function sleep(duration) { return new Promise(function(resolve, reject) { console.log(\"b\"); setTimeout(resolve,duration); })}console.log(\"a\");sleep(5000).then(()=&gt;console.log(\"c\"));这是一段非常常用的封装方法，利用 Promise 把 setTimeout 封装成可以用于异步的函数。我们首先来看，setTimeout 把整个代码分割成了 2 个宏观任务，这里不论是 5 秒还是 0 秒，都是一样的。第一个宏观任务中，包含了先后同步执行的 console.log(“a”); 和 console.log(“b”);。setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(“c”)，最终输出的顺序才是： a b c。Promise 是 JavaScript 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是从 ES6 开始，我们有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。新特性：async/awaitasync/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise，面对这种比较新的特性，我们先来看一下基本用法。async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。12345678910function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); })}async function foo(){ console.log(\"a\") await sleep(2000) console.log(\"b\")}这段代码利用了我们之前定义的 sleep 函数。在异步函数 foo 中，我们调用 sleep。async 函数强大之处在于，它是可以嵌套的。我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。12345678910111213function sleep(duration) { return new Promise(function(resolve, reject) { setTimeout(resolve,duration); })}async function foo(name){ await sleep(2000) console.log(name)}async function foo2(){ await foo(\"a\"); await foo(\"b\");}这里 foo2 用 await 调用了两次异步函数 foo，可以看到，如果我们把 sleep 这样的异步操作放入某一个框架或者库中，使用者几乎不需要了解 Promise 的概念即可进行异步编程了。此外，generator/iterator 也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。结语在今天的文章里，我们学习了 JavaScript 执行部分的知识，首先我们学习了 JavaScript 的宏观任务和微观任务相关的知识。我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。除此之外，我们还展开介绍了用 Promise 来添加微观任务的方式，并且介绍了 async/await 这个语法的改进。最后，留给你一个小练习：我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色，你会怎样编写这个代码呢？转自—《重学前端》","link":"/2019/03/23/JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？/"},{"title":"JavaScript执行（二）：闭包和执行上下文到底是怎么回事？","text":"在上一课，我们了解了 JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。并且，我们还根据“由 JavaScript 引擎发起”还是“由宿主发起”，分成了宏观任务和微观任务，接下来我们继续去看一看更细的执行粒度。 一段 JavaScript 代码可能会包含函数调用的相关内容，从今天开始，我们就用两节课的时间来了解一下函数的执行。 我们今天要讲的知识在网上有不同的名字，比较常见的可能有： 闭包； 作用域链； 执行上下文； this 值。 实际上，尽管它们是表示不同的意思的术语，所指向的几乎是同一部分知识，那就是函数执行过程相关的知识。我们可以简单看一下图。 看着也许会有点晕，别着急，我会和你共同理一下它们之间的关系。 当然，除了让你理解函数执行过程的知识，理清这些概念也非常重要。所以我们先来讲讲这个有点复杂的概念：闭包。 闭包 闭包翻译自英文单词 closure，这是个不太好翻译的词，在计算机领域，它就有三个完全不相同的意义：编译原理中，它是处理语法产生式的一个步骤；计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；而在编程语言领域，它表示一种函数。 闭包这个概念第一次出现在 1964 年的《The Computer Journal》上，由 P. J. Landin 在《The mechanical evaluation of expressions》一文中提出了 applicative expression 和 closure 的概念。 在上世纪 60 年代，主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。 我们可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了执行的环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。 这个古典的闭包定义中，闭包包含两个部分。 环境部分 环境 标识符列表 表达式部分 当我们把视角放在 JavaScript 的标准中，我们发现，标准中并没有出现过 closure 这个术语，但是，我们却不难根据古典定义，在 JavaScript 中找到对应的闭包组成部分。 环境部分 环境：函数的词法环境（执行上下文的一部分） 标识符列表：函数中用到的未声明的变量 表达式部分：函数体 至此，我们可以认为，JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。 这里我们容易产生一个常见的概念误区，有些人会把 JavaScript 执行上下文，或者作用域（Scope，ES3 中规定的执行上下文的一部分）这个概念当作闭包。 实际上 JavaScript 中跟闭包对应的概念就是“函数”，可能是这个概念太过于普通，跟闭包看起来又没什么联系，所以大家才不自觉地把这个概念对应到了看起来更特别的“作用域”吧（其实我早年也是这么理解闭包，直到后来被朋友纠正，查了资料才改正过来）。 执行上下文：执行的基础设施 相比普通函数，JavaScript 函数的主要复杂性来自于它携带的“环境部分”。当然，发展到今天的 JavaScript，它所定义的环境部分，已经比当初经典的定义复杂了很多。 JavaScript 中与闭包“环境部分”相对应的术语是“词法环境”，但是 JavaScript 函数比λ函数要复杂得多，我们还要处理 this、变量声明、with 等等一系列的复杂语法，λ函数中可没有这些东西，所以，在 JavaScript 的设计中，词法环境只是 JavaScript 执行上下文的一部分。 JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。 因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。 执行上下文在 ES3 中，包含三个部分。 scope：作用域，也常常被叫做作用域链。 variable object：变量对象，用于存储变量的对象。 this value：this 值。 在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 lexical environment：词法环境，当获取变量时使用。 variable environment：变量环境，当声明变量时使用。 this value：this 值。 在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。 lexical environment：词法环境，当获取变量或者 this 值时使用。 variable environment：变量环境，当声明变量时使用 code evaluation state：用于恢复代码执行位置。 Function：执行的任务是函数时使用，表示正在被执行的函数。 ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。 Realm：使用的基础库和内置对象实例。 Generator：仅生成器上下文有这个属性，表示当前生成器。 我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的 ES2018 中规定的术语定义。 尽管我们介绍了这些定义，但我并不打算按照 JavaScript 标准的思路，从实现的角度去介绍函数的执行过程，这是不容易被理解的。 我想试着从代码实例出发，跟你一起推导函数执行过程中需要哪些信息，它们又对应着执行上下文中的哪些部分。 比如，我们看以下的这段 JavaScript 代码：123var b = {}let c = 1this.a = 2;要想正确执行它，我们需要知道以下信息：var 把 b 声明到哪里；b 表示哪个变量；b 的原型是哪个对象；let 把 c 声明到哪里；this 指向哪个对象。这些信息就需要执行上下文来给出了，这段代码出现在不同的位置，甚至在每次执行中，会关联到不同的执行上下文，所以，同样的代码会产生不一样的行为。在这两篇文章中，我会基本覆盖执行上下文的组成部分，本篇我们先讲 var 声明与赋值，let，realm 三个特性来分析上下文提供的信息，分析执行上下文中提供的信息。var 声明与赋值我们来分析一段代码：1var b = 1通常我们认为它声明了 b，并且为它赋值为 1，var 声明作用域函数执行的作用域。也就是说，var 会穿透 for 、if 等语句。在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。由于语法规定了 function 关键字开头是函数声明，所以要想让函数变成函数表达式，我们必须得加点东西，最常见的做法是加括号。12345678910(function(){ var a; //code}());(function(){ var a; //code})();但是，括号有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。12345678910;(function(){ var a; //code}());(function(){ var a; //code})()我比较推荐的写法是使用 void 关键字。也就是下面的这种形式。1234void function(){ var a; //code}();这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。值得特别注意的是，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，JavaScript 中有特例，那就是使用 with 的时候：1234567891011var b;void function(){ var env = {b:1}; b = 2; console.log(\"In function b:\", b); with(env) { var b = 3; console.log(\"In with b:\", b); }}();console.log(\"Global b:\", b);在这个例子中，我们利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境，并且在里面使用了我们一开头的代码。可以看到，在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。letlet 是 ES6 开始引入的新的变量声明模式，比起 var 的诸多弊病，let 做了非常明确的梳理和规定。为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。我简单统计了下，以下语句会产生 let 使用的作用域：for；if；switch；try/catch/finally。Realm在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。这个英文的用法就有点比喻的意思，几个翻译都不太适合 JavaScript 语境，所以这里就不翻译啦。我们继续来看这段代码：1var b = {}在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：12345678910var iframe = document.createElement('iframe')document.documentElement.appendChild(iframe)iframe.src=\"javascript:var b = {};\"var b1 = iframe.contentWindow.b;var b2 = {};console.log(typeof b1, typeof b2); //object objectconsole.log(b1 instanceof Object, b2 instanceof Object); //false true可以看到，由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。结语在今天的课程中，我帮你梳理了一些概念：有编程语言的概念闭包，也有各个版本中的 JavaScript 标准中的概念：执行上下文、作用域、this 值等等。之后我们又从代码的角度，分析了一些执行上下文中所需要的信息，并从var、let、对象字面量等语法中，推导出了词法作用域、变量作用域、Realm\b的设计。最后留给你一个问题：你喜欢使用 let 还是 var？转自—《重学前端》","link":"/2019/03/23/JavaScript执行（二）：闭包和执行上下文到底是怎么回事？/"},{"title":"JavaScript执行（四）：try里面放return，finally还会执行吗？","text":"在前面几篇文章中，我们已经了解了关于执行上下文、作用域、闭包之间的关系。 今天，我们则要说一说更为细节的部分：语句。 语句是任何编程语言的基础结构，与 JavaScript 对象一样，JavaScript 语句同样具有“看起来很像其它语言，但是其实一点都不一样”的特点。 我们比较常见的语句包括变量声明、表达式、条件、循环等，这些都是大家非常熟悉的东西，对于它们的行为，我在这里就不赘述了。 为了了解 JavaScript 语句有哪些特别之处，首先我们要看一个不太常见的例子，我会通过这个例子，来向你介绍 JavaScript 语句执行机制涉及的一种基础类型：Completion 类型。 Completion 类型 我们来看一个例子。在函数 foo 中，使用了一组 try 语句。我们可以先来做一个小实验，在 try 中有 return 语句，finally 中的内容还会执行吗？我们来看一段代码。1234567891011function foo(){ try{ return 0; } catch(err) { } finally { console.log(\"a\") }}console.log(foo());通过实际试验，我们可以看到，finally 确实执行了，而且 return 语句也生效了，foo() 返回了结果 0。虽然 return 执行了，但是函数并没有立即返回，又执行了 finally 里面的内容，这样的行为违背了很多人的直觉。如果在这个例子中，我们在 finally 中加入 return 语句，会发生什么呢？1234567891011function foo(){ try{ return 0; } catch(err) { } finally { return 1; }}console.log(foo());通过实际执行，我们看到，finally 中的 return “覆盖”了 try 中的 return。在一个函数中执行了两次 return，这已经超出了很多人的常识，也是其它语言中不会出现的一种行为。面对如此怪异的行为，我们当然可以把它作为一个孤立的知识去记忆，但是实际上，这背后有一套机制在运作。这一机制的基础正是 JavaScript 语句执行的完成状态，我们用一个标准类型来表示：Completion Record（我在类型一节提到过，Completion Record 用于描述异常、跳出等语句执行过程）。Completion Record 表示一个语句执行完之后的结果，它有三个字段： [[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型； [[value]] 表示语句的返回值，如果语句没有，则是 empty； [[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。接下来我们要来了解一下 JavaScript 使用 Completion Record 类型，控制语句执行的过程。首先我们来看看语句有几种分类。普通的语句在 JavaScript 中，我们把不带控制能力的语句称为普通语句。普通语句有下面几种。 声明类语句 var 声明 const 声明 let 声明 函数声明 类声明 表达式语句 空语句 debugger 语句这些语句在执行时，从前到后顺次执行（我们这里先忽略 var 和函数声明的预处理机制），没有任何分支或者重复执行逻辑。普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。如果你经常使用 chrome 自带的调试工具，可以知道，输入一个表达式，在控制台可以得到结果，但是在前面加上 var，就变成了 undefined。Chrome 控制台显示的正是语句的 Completion Record 的 [[value]]。语句块介绍完了普通语句，我们再来介绍一个比较特殊的语句：语句块。语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。语句块本身并不复杂，我们需要注意的是语句块内部的语句的 Completion Record 的 [[type]] 如果不为 normal，会打断语句块后续的语句执行。比如我们考虑，一个 [[type]] 为 return 的语句，出现在一个语句块中的情况。从语句的这个 type 中，我们大概可以猜到它由哪些特定语句产生，我们就来说说最开始的例子中的 return。return 语句可能产生 return 或者 throw 类型的 Completion Record。我们来看一个例子。先给出一个内部为普通语句的语句块：12345{ var i = 1; // normal, empty, empty i ++; // normal, 1, empty console.log(i) //normal, undefined, empty} // normal, undefined, empty在每一行的注释中，我给出了语句的 Completion Record。我们看到，在一个 block 中，如果每一个语句都是 normal 类型，那么它会顺次执行。接下来我们加入 return 试试看。123456{ var i = 1; // normal, empty, empty return i; // return, 1, empty i ++; console.log(i)} // return, 1, empty但是假如我们在 block 中插入了一条 return 语句，产生了一个非 normal 记录，那么整个 block 会成为非 normal。这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。接下来我们就具体讲讲控制类语句。控制型语句控制型语句带有 if、switch 关键字，它们会对不同类型的 Completion Record 产生反应。控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try。另一类是对外部造成影响如 break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们需要控制语句跟 break 、continue 、return 、throw 四种类型与控制语句两两组合产生的效果。通过这个表，我们不难发现知识的盲点，也就是我们最初的的 case 中的 try 和 return 的组合了。因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。带标签的语句前文我重点讲了 type 在语句控制中的作用，接下来我们重点来讲一下最后一个字段：target，这涉及了 JavaScript 中的一个语法，带标签的语句。实际上，任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：1firstStatement: var i = 1;大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环。123456outer: while(true) { inner: while(true) { break outer; }}console.log(\"finished\")break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它。结语我们以 Completion Record 类型为线索，为你讲解了 JavaScript 语句执行的原理。因为 JavaScript 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行， 树形结构的每一个节点执行后产生 Completion Record，根据语句的结构和 Completion Record，JavaScript 实现了各种分支和跳出逻辑。你遇到哪些语句中的执行的实际效果，是跟你想象的有所出入呢，你可以给我留言，我们一起讨论。转自—《重学前端》","link":"/2019/03/25/JavaScript执行（四）：try里面放return，finally还会执行吗？/"},{"title":"JavaScript词法：为什么12.toString会报错？","text":"文法是编译原理中对语言的写法的一种规定，一般来说，文法分成词法和语法两种。 词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。 从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。 概述 我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类： WhiteSpace 空白字符 LineTerminator 换行符 Comment 注释 Token 词 IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。 Punctuator 符号，我们使用的运算符和大括号等符号。 NumericLiteral 数字直接量，就是我们写的数字。 StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。 Template 字符串模板，用反引号` 括起来的直接量。 这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。 首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。 但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。 JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的： 1`Hello, ${name}` 理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。是否允许“ }”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义： InputElementDiv； InputElementRegExp； InputElementRegExpOrTemplateTail； InputElementTemplateTail。 为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为CommonToken。但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。 对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。 接下来我来给你详细介绍一下。 空白符号Whitespace 说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。 &lt;HT&gt;(或称&lt;TAB&gt;) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \\t 。 &lt;VT&gt;是 U+000B，也就是垂直方向的 TAB 符 \\v，这个字符在键盘上很难打出来，所以很少用到。 &lt;FF&gt;是 U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。 &lt;SP&gt;是 U+0020，就是最普通的空格了。 &lt;NBSP&gt;是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 &amp;nbsp; 最后生成的就是它了。 &lt;ZWNBSP&gt;(旧称&lt;BOM&gt;) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。 此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表： 很多公司的编码规范要求JavaScript 源代码控制在 ASCII 范围内，那么，就只有&lt;TAB&gt; &lt;VT&gt; &lt;FF&gt;&lt;SP&gt; &lt;NBSP&gt;五种空白可用了。换行符 LineTerminator接下来我们来看看换行符，JavaScript 中只提供了 4种字符作为换行符。 &lt;LF&gt; &lt;CR&gt; &lt;LS&gt; &lt;PS&gt; 其中， &lt;LF&gt;是 U+000A，就是最正常换行符，在字符串中的\\n。 &lt;CR&gt;是U+000D，这个字符真正意义上的“回车”，在字符串中是\\r，在一部分 Windows 风格文本编辑器中，换行是两个字符\\r\\n。 &lt;LS&gt;是U+2028，是 Unicode 中的行分隔符。 &lt;PS&gt;是 U+2029，是 Unicode 中的段落分隔符。 大部分 LineTerminator在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。 注释 Comment JavaScript的注释分为单行注释和多行注释两种： 12/* MultiLineCommentChars */// SingleLineCommentChars 多行注释中允许自由地出现MultiLineNotAsteriskChar，也就是除了之外的所有字符。而每一个之后，不能出现正斜杠符/。除了四种LineTerminator 之外，所有字符都可以作为单行注释。我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。 标识符名称 IdentifierName IdentifierName可以以美元符“$”、下划线“_”或者 Unicode字母开始，除了开始字符以外，IdentifierName中还可以使用 Unicode 中的连接标记、数字、以及连接符号。 IdentifierName的任意字符可以使用JavaScript 的 Unicode 转义写法，使用 Unicode转义写法时，没有任何字符限制。 IdentifierName可以是Identifier、NullLiteralBooleanLiteral或者keyword，在ObjectLiteral中，IdentifierName还可以被直接当做属性名称使用。 仅当不是保留字的时候，IdentifierName会被解析为Identifier。 注意&lt;ZWNJ&gt;和&lt;ZWJ&gt;是ES5 新加入的两个格式控制字符，它们都是 0 宽的。 我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有: 12await break case catch class const continue debugger default delete do else export extends finally for function ifimport ininstance of new return super switch this throw try typeof var void while with yield 除了上述的内容之外，还有 1 个为了未来使用而保留的关键字: 1enum 在严格模式下, 有一些额外的为未来使用而保留的关键字: 1implements package protected interface private public 除了这些之外，NullLiteral（null）和BooleanLiteral（true false）也是保留字，不能用于Identifier。符号 Punctuator因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为DivPunctuator，因为前面提到的字符串模板问题，}也被独立拆分。加在一起，所有符号为： 12{ ( ) [ ] . ... ; , &lt;&gt;&lt;=&gt;= == != === !== + - * % ** ++ -- &lt;&lt;&gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;=&gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= } 数字直接量 NumericLiteral 我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。十进制的 Number可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子： 123.0112.12.01 这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码： 112.toString() 这时候12. 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写： 112 .toString() 数字直接量还支持科学计数法，例如： 1230xFA0o730b10000 这里 e 后面的部分，只允许使用整数。当以0x 0b 或者0o 开头时，表示特定进制的整数： 1230xFA0o730b10000 上面这几种进制都不支持小数，也不支持科学计数法。字符串直接量 StringLiteralJavaScript 中的 StringLiteral 支持单引号和双引号两种写法。 12\" DoubleStringCharacters \"' SingleStringCharacters ' 单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是\\和所有换行符。JavaScript中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。第一种是单字符转义。 即一个反斜杠\\后面跟一个字符这种形式。有特别意义的字符包括有SingleEscapeCharacter所定义的 9 种，见下表：除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过\\转义后都是自身。 正则表达式直接量 RegularExpressionLiteral 正则表达式由 Body 和Flags 两部分组成，例如： 1/RegularExpressionBody/g 其中 Body 部分至少有一个字符，第一个字符不能是 （因为 /跟多行注释有词法冲突）。正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。正则表达式并非机械地见到/就停止，在正则表达式[]中的/就会被认为是普通字符。我们可以看一个例子： 1/[/]/.test(\"/\"); 除了\\、/ 和[ 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。用\\和一个非换行符可以组成一个转义，[]中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier中合法的字符）序列在词法阶段都会被认为是合法的。 字符串模板 Template 从语法结构上，Template 是个整体，其中的 ${ } 是并列关系。但是实际上，在JavaScript 词法中，包含 ${ } 的 Template，是被拆开分析的，如： 1`a${b}c${d}e` 它在 JavaScript 中被认为是： 12345`a${b}c${d}e` 它被拆成了五个部分： a${&lt;/code&gt; 这个被称为模板头&lt;/li&gt; &lt;li&gt;&lt;code&gt;}c${&lt;/code&gt; 被称为模板中段&lt;/li&gt; &lt;li&gt;&lt;code&gt;}e 被称为模板尾 b 和 d 都是普通标识符 实际上，这里的词法分析过程已经跟语法分析深度耦合了。不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数： 123456function f(){console.log(arguments);}var a = \"world\"f`Hello ${a}!`; // [[\"Hello\", \"!\"], world] 模板字符串不需要关心大多数字符的转义，但是至少 ${ 和 ` 还是需要处理的。模板中的转义跟字符串几乎完全一样，都是使用 \\。 总结 今天我们一起学习 JavaScript的词法部分，这部分的内容包括了空白符号、换行符、注释、标识符名称、符号、数字直接量、字符串直接量、正则表达式直接量、字符串模板。掌握词法对我们平时调试代码至关重要。最后，留一个问题：用零宽空格和零宽连接符、零宽非连接符，写一段好玩的代码。","link":"/2019/07/25/JavaScript词法：为什么12.toString会报错？/"},{"title":"JavaScript语法（预备篇）：到底要不要写分号呢？","text":"在我们介绍 JavaScript 语法的全局结构之前，我们先要探讨一个语言风格问题：究竟要不要写分号。 这是一个非常经典的口水问题，“加分号”党和“不写分号”党之间的战争，可谓是经久不息。 实际上，行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。 但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。 这里要特意说一点，在今天的文章中，我并不希望去售卖自己的观点（其实我是属于“加分号”党），而是希望比较中立地给你讲清楚相关的知识，让你具备足够的判断力。 我们首先来了解一下自动插入分号的规则。 自动插入分号规则 自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。 这样描述是比较难以理解的，我们一起看一些实际的例子进行分析：1234let a = 1void function(a){ console.log(a);}(a);在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入换行符。123456var a = 1, b = 1, c = 1;a++b++c这也是个著名的例子，我们看第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有 [no LineTerminator here] 这个字样，这是一个语法定义中的规则，你可以感受一下这个规则的内容：123456UpdateExpression[Yield, Await]: LeftHandSideExpression[?Yield, ?Await] LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]++ LeftHandSideExpression[?Yield, ?Await][no LineTerminator here]-- ++UnaryExpression[?Yield, ?Await] --UnaryExpression[?Yield, ?Await]于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。123456(function(a){ console.log(a);})()(function(a){ console.log(a);})()这个例子是比较有实际价值的例子，这里两个 function 调用的写法被称作 IIFE（立即执行的函数表达式），是个常见技巧。这段代码意图上显然是形成两个 IIFE。我们来看第三行结束的位置，JavaScript 引擎会认为函数返回的可能是个函数，那么，在后面再跟括号形成函数调用就是合理的，因此这里不会自动插入分号。这是一些鼓励不写分号的编码风格会要求大家写 IIFE 时必须在行首加分号的原因。123456function f(){ return/* This is a return value. */1;}f();在这个例子中，return 和 1 被用注释分隔开了。根据 JavaScript 自动插入分号规则，带换行符的注释也被认为是有换行符，而恰好的是，return 也有 [no LineTerminator here] 规则的要求。所以这里会自动插入分号，f 执行的返回值是 undefined。no LineTerminator here 规则好了，到这里我们已经讲清楚了分号自动插入的规则，但是我们要想彻底掌握分号的奥秘，就必须要对 JavaScript 的语法定义做一些数据挖掘工作。no LineTerminator here 规则表示它所在的结构中的这一位置不能插入换行符。自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。跟 no LineTerminator here 规则强相关，那么我们就找出 JavaScript 语法定义中的这些规则。为了方便你理解，我把产生式换成了实际的代码。下面一段代码展示了，带标签的 continue 语句，不能在 continue 后插入换行。123outer:for(var j = 0; j &lt; 10; j++) for(var i = 0; i &lt; j; i++) continue /*no LineTerminator here*/ outterbreak 跟 continue 是一样的，break 后也不能插入换行：123outer:for(var j = 0; j &lt; 10; j++) for(var i = 0; i &lt; j; i++) break /*no LineTerminator here*/ outter我们前面已经提到过 return 和后自增、后自减运算符。123function f(){ return /*no LineTerminator here*/1;}12i/*no LineTerminator here*/++i/*no LineTerminator here*/--以及，throw 和 Exception 之间也不能插入换行符：1throw/*no LineTerminator here*/new Exception(\"error\")凡是 async 关键字，后面都不能插入换行符：1234async/*no LineTerminator here*/function f(){}const f = async/*no LineTerminator here*/x =&gt; x*x箭头函数的箭头前，也不能插入换行：1const f = x/*no LineTerminator here*/=&gt; x*xyield 之后，不能插入换行：12345function *g(){ var i = 0; while(true) yield/*no LineTerminator here*/i++;}到这里，我已经整理了所有标准中的 no LineTerminator here 规则，实际上，no LineTerminator here 规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript 在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现，需要我们格外注意。不写分号需要注意的情况下面我们来看几种不写分号容易造成错误的情况，你可以稍微注意一下，避免发生同样的问题。以括号开头的语句我们在前面的案例中，已经展示了一种情况，那就是以括号开头的语句：123456(function(a){ console.log(a);})()/* 这里没有被自动插入分号 */(function(a){ console.log(a);})()这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。以数组开头的语句除了括号，以数组开头的语句也十分危险：12var a = [[]]/* 这里没有被自动插入分号 */[3, 2, 1, 0].forEach(e =&gt; console.log(e))这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。以正则表达式开头的语句正则表达式开头的语句也值得你去多注意一下。我们来看这个例子。123var x = 1, g = {test:()=&gt;0}, b = 1/* 这里没有被自动插入分号 *//(a)/g.test(\"abc\")console.log(RegExp.$1)这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。注意，我构造的这个例子跟上面的例子一样，同样不会抛错，凡是这一类情况，都非常致命。以 Template 开头的语句以 Template 开头的语句比较少见，但是跟正则配合时，仍然不是不可能出现：123456var f = function(){ return \"\";}var g = f/* 这里没有被自动插入分号 */`Template`.match(/(a)/);console.log(RegExp.$1)这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。总结这一节课，我们讨论了要不要加分号的问题。首先我们介绍了自动插入分号机制，又对 JavaScript 语法中的 no line terminator 规则做了个整理，最后，我挑选了几种情况，为你介绍了不写分号需要注意的一些常见的错误。最后留一个问题，请找一些开源项目，看看它们的编码规范是否要求加分号。","link":"/2019/07/25/JavaScript语法（预备篇）：到底要不要写分号呢？/"},{"title":"PHP mysql数据库面向对象简单操作类（增删改查）、分页类和图片验证码类的封装","text":"这篇文章中已经介绍了PHP连接数据库的方法以及最基本的对数据库的操作，但并没有实现模块化，所有的代码全都集中在表现页面中，造成了代码冗余，不仅不利于维护也不利于代码的重用性，那么在这篇文章中将用面向对象的知识对数据库的连接和基本操作方法进行封装，也简单地对地分页功能进行了封装，这样就大大避免了代码的重复。 以下文件放置于space文件夹中 一、封装简单的数据库的增删改查等函数 libs/Db文件夹 1、先写一个db.config.php文件来使用里面是你数据库的信息 123456789&lt;?phpreturn array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'password' =&gt; 'root', 'port' =&gt; '3306', 'dbname' =&gt; 'test', 'charset' =&gt; 'utf8'); 2、通过Idb.class.php文件来定义接口 12345678910&lt;?phpnamespace libs\\Db; //引入命名空间interface Idb { public function add(); public function getOne(); public function getList(); public function update(); public function delete(); public function count();} 什么是命名空间 3、通过Mysql.class.php来封装接口的各个功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;?phpnamespace libs\\Db;class Mysql implements Idb { private $_link = NULL; private $_debug = false; private $_where = NULL; private $_table = NULL; private $_data = NULL; private $_fields = NULL; private $_limit=NULL; private $_order = NULL; private static $_instance = NULL; private function __construct() { if ( $this-&gt;_link == NULL ) { $this-&gt;connect(); } } public static function init() { if ( self::$_instance == NULL ) { self::$_instance = new self(); } return self::$_instance; } private function excute($sql) //执行sql语句 { if ( $this-&gt;_debug == true ) { echo \"EXCUTE SQL: {$sql} &lt;br/&gt;\"; } $ret = $this-&gt;_link-&gt;query($sql); return $ret; } public function setDebug( $debug = true ) //调试函数 { $this-&gt;_debug = $debug; } private function connect() //连接数据库 { $conf = require_once 'db.config.php'; $this-&gt;_link = new \\mysqli($conf['host'], $conf['user'], $conf['password'], $conf['dbname'],$conf['port']); if ($this-&gt;_link-&gt;connect_error) { die('Connect Error (' . $this-&gt;_link-&gt;connect_errno . ') ' . $this-&gt;_link-&gt;connect_error); } date_default_timezone_set('PRC'); //设时区 $this-&gt;_link-&gt;query(\"SET NAME {$conf['charset']}\"); } public function table( $table ) //获取表 { $this-&gt;_table = $table; return $this; } public function where($where= NULL) { $this-&gt;_where = $where; return $this; } public function data($data) { $this-&gt;_data = $data; return $this; } public function field($fields){ $this-&gt;_fields = $fields; return $this; } public function order($order){ $this-&gt;_order = $order; return $this; } public function limit($limit){ $this-&gt;_limit = $limit; return $this; } public function add() //添加数据 { $sql = \"INSERT INTO {$this-&gt;_table} (\"; $fields = \"\"; $values = \"\"; foreach( $this-&gt;_data as $key =&gt; $val ) { if ( $fields == \"\" ) $fields = $key; else $fields .= \",\".$key; if ( $values == \"\" ) $values = \"'{$val}'\"; else $values .= \",\".\"'{$val}'\"; } $sql .= \"{$fields} )VALUES({$values})\"; $ret = $this-&gt;excute($sql); return $ret; } public function getOne() //获取一组数据 { //select id,name from table where id = 10 if ( is_array($this-&gt;_fields) ) $fields = implode(',', $fields); $sql = \"SELECT {$this-&gt;_fields} FROM {$this-&gt;_table}\"; if ( $this-&gt;_where != NULL ) $sql .= \" WHERE {$this-&gt;_where}\"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row; } public function getList() //获取多组数据 { //select id,name from table where id &gt; 10 //若查询字段为一维数组，以,拼接为目标字符串 if ( is_array($this-&gt;_fields) ) $this-&gt;_fields = implode(',', $this-&gt;_fields); $sql = \"SELECT {$this-&gt;_fields} FROM {$this-&gt;_table}\"; if ( $this-&gt;_where != NULL ) $sql .= \" WHERE {$this-&gt;_where}\"; if ($this-&gt;_order !=NULL) $sql .= \" ORDER BY {$this-&gt;_order}\"; if ( $this-&gt;_limit != NULL ) $sql .= \" LIMIT {$this-&gt;_limit}\"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $result = []; while ( ($row = $ret-&gt;fetch_assoc()) != false) { $result[] = $row; } return $result; } public function update() //更新数据 { //update table set name = \"wein\" where id = 1 $sql = \"UPDATE {$this-&gt;_table} SET \"; $fields = \"\"; foreach( $this-&gt;_data as $key =&gt; $val ) { if ( $fields == \"\" ) $fields = \"{$key}='{$val}'\"; else $fields .= \",\".\"{$key}='{$val}'\"; } if ( $this-&gt;_where != NULL ) $sql .= \"{$fields} WHERE {$this-&gt;_where}\"; else $sql .= \"{$fields}\"; $ret = $this-&gt;excute($sql); if ( $ret == false ) return false; $row = $this-&gt;_link-&gt;affected_rows; if ( $row == 0 ) return false; return true; } public function delete()//删除数据 { //拼接sql语句 //delete from table where id =1 $sql = \"DELETE FROM {$this-&gt;_table} WHERE {$this-&gt;_where}\"; $ret = $this-&gt;excute($sql); return $ret; } public function count() //统计数据 { $sql = \"SELECT COUNT({$this-&gt;_fields}) AS num FROM {$this-&gt;_table}\"; if ( $this-&gt;_where != NULL ) $sql .= \" WHERE {$this-&gt;_where}\"; $ret = $this-&gt;excute($sql); //select 操作query 返回的是结果集 if ( $ret == false ) return false; $row = $ret-&gt;fetch_assoc(); if ( empty($row) ) return false; return $row['num']; } public function __destruct() //断开数据库连接 { $this-&gt;_link-&gt;close(); $this-&gt;_link = NULL; } } 二、分页类的封装 libs/Page文件夹 1、通过Page.class.php文件来封装 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpnamespace libs\\Page;class Page { private $_totals = 0; private $_pagesize = 0; public function __construct( $pagesize, $total ) { $this-&gt;_totals = $total; $this-&gt;_pagesize = $pagesize; } public function getoffset() //获取展示下一页开始的id值 { $page = isset($_GET['page'])?$_GET['page']:1; $offset = ($page -1) * $this-&gt;_pagesize; return $offset; } public function show($left = 2) { $page = isset($_GET['page'])?$_GET['page']:1; $totalPages = ceil($this-&gt;_totals / $this-&gt;_pagesize); $html = '&lt;ul class=\"page-ui-box\"&gt;'; if ( $page &gt; 1 ){ $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page=1\"&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.($page-1).'\"&gt;上一页&lt;/a&gt;&lt;/li&gt;'; } else { $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;上一页&lt;/a&gt;&lt;/li&gt;'; } //当前页的前面显示两个数字页面 $start = ($page - $left); if ( $start &lt;= 0 ) $start = 1; for( $i = $start; $i &lt; $page; $i++ ) { $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.$i.'\"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; } $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;'.$page.'&lt;/a&gt;&lt;/li&gt;'; //当前页的后面显示两个数字页面 $end = $page + 2; if ( $end &gt; $totalPages ) $end = $totalPages; for( $i = $page + 1; $i &lt;= $end; $i++ ) { $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.$i.'\"&gt;'.$i.'&lt;/a&gt;&lt;/li&gt;'; } if ( $page &lt; $totalPages ) { $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.($page+1).'\"&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"able\"&gt;&lt;a href=\"?page='.$totalPages.'\"&gt;尾页&lt;/a&gt;&lt;/li&gt;'; } else { $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;下一页&lt;/a&gt;&lt;/li&gt;'; $html .= '&lt;li class=\"unable\"&gt;&lt;a&gt;尾页&lt;/a&gt;&lt;/li&gt;'; } $html .= '&lt;/ul&gt;'; return $html; }}?&gt; 2、样式文件Page-ui.css 12345678910* {margin: 0px;padding: 0px;}ul, li {list-style: none;}.page-ui-box {overflow: hidden;border-left: 1px solid #CCC;}.page-ui-box li {float: left;padding: 5px 25px;height: 30px;line-height: 30px;border: 1px solid #CCC;border-left:none;cursor: pointer;}.unable {background: #EEE;}.page-ui-box a {text-decoration: none;}.able a {color: blue;}.able a:hover {text-decoration: underline;}table{border-collapse:collapse; border-spacing:0; border-left:1px solid #aaa; border-top:1px solid #aaa; }td{border-right:1px solid #aaa; border-bottom:1px solid #aaa; padding:3px 15px; text-align:left; color:#3C3C3C;} 三、图片验证码类的封装 libs/Verify文件夹 1、Verify.class.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?php namespace libs\\Verify;class Verify{ private $width=100; private $height=30; private $content=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; private $num=4; private $point=100; private $line= 4; public function __construct(){ } public function show(){ /** * 字母+数字的验证码生成 */ // 开启session session_start(); //1.创建黑色画布 $image = imagecreatetruecolor($this-&gt;width, $this-&gt;height); //2.为画布定义(背景)颜色 $bgcolor = imagecolorallocate($image, 255, 255, 255); //3.填充颜色 imagefill($image, 0, 0, $bgcolor); // 4.设置验证码内容 //4.1 定义验证码的内容 //4.1 创建一个变量存储产生的验证码数据，便于用户提交核对 $captcha = \"\"; for ($i = 0; $i &lt; $this-&gt;num; $i++) { // 字体大小 $fontsize = 5; // 字体颜色 随机生成字体颜色 $fontcolor = imagecolorallocate($image, mt_rand(0, 120), mt_rand(0, 120), mt_rand(0, 120)); // 设置字体内容 $fontcontent = substr($this-&gt;content, mt_rand(0, strlen($this-&gt;content)), 1); $captcha .= $fontcontent; // 显示的坐标 $x = ($i * $this-&gt;width / $this-&gt;num) + mt_rand(5, 10); $y = mt_rand($this-&gt;height/3, $this-&gt;height/2); // 填充内容到画布中 imagestring($image, $fontsize, $x, $y, $fontcontent, $fontcolor); } $_SESSION[\"captcha\"] = $captcha; //4.3 设置背景干扰元素 for ($i = 0; $i &lt; $this-&gt;point; $i++) { $pointcolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imagesetpixel($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $pointcolor); } //4.4 设置干扰线 for ($i = 0; $i &lt; $this-&gt;line; $i++) { $linecolor = imagecolorallocate($image, mt_rand(50, 200), mt_rand(50, 200), mt_rand(50, 200)); imageline($image, mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), mt_rand(1, $this-&gt;width), mt_rand(1, $this-&gt;height), $linecolor); } return $image; //6.输出图片到浏览器 // imagepng($image); //7.销毁图片 // imagedestroy($image); } public function width($width) //设置验证码图片的宽度 { $this-&gt;width=$width; return $this; } public function height($height) //设置验证码图片的高度 { $this-&gt;height=$height; return $this; } public function setLine($line) //设置验证码图片的干扰线数量 { $this-&gt;line=$line; return $this; } public function setNum($num) // 设置验证码的位数 { $this-&gt;num=$num; return $this; } public function setChars($content) //设置验证码出现的字符集， 比如设置 123456789,那么验证码中出现的字符只能是这个字符串中的某几个 { $this-&gt;content=$content; return $this; } public function setPoint($point) // 设置验证码图片中出现的杂点数量 { $this-&gt;point=$point; return $this; }}?&gt; 2、Verify类的实例verify.php： 12345678910111213141516171819&lt;?php//5.向浏览器输出图片头信息 header('content-type:image/png');spl_autoload_register(function($class){ //$class = libs\\Db\\Mysql //libs\\Db\\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;}); use libs\\Verify\\Verify; $verify=new Verify(); $char=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; $verifyhtml=$verify-&gt;width(200)-&gt;height(80)-&gt;setLine(6)-&gt;setNum(6)-&gt;setChars($char)-&gt;setPoint(500)-&gt;show(); //链式操作 //6.输出图片到浏览器 imagepng($verifyhtml); //7.销毁图片 imagedestroy($verifyhtml);?&gt; 四、运用实例这里通过start.php文件来运用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?php//namespace \"上级文件夹名称\"// require_once 'libs/Db/Mysql.class.php';//引入命名空间spl_autoload_register(function($class){ //$class = libs\\Db\\Mysql //libs\\Db\\Mysql -&gt; libs/Db/Mysql $class_path = str_replace('\\\\', '/', $class); $class_path .= '.class.php'; require_once $class_path;}); use libs\\Db\\Mysql; use libs\\Page\\Page; $db = Mysql::init(); //新建Mysql对象 $totals = $db-&gt;table(\"contact\")-&gt;field(\"id\")-&gt;count(); $pagesize = 3; //每一页显示的数据条数 $page = new Page($pagesize,$totals); //新建Page对象 $pagehtml = $page-&gt;show(); $left = $page-&gt;getoffset(); $db-&gt;setDebug(true); $data=$db-&gt;table(\"contact\")-&gt;where(NULL)-&gt;field(\"*\")-&gt;order(\"id desc\")-&gt;limit(\"{$left},{$pagesize}\")-&gt;getList(); //链式操作 // $data = $db-&gt;getList('contact', NULL,\"*\", 'id desc', \"{$left}, {$pagesize}\"); // var_dump($data);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"libs/Page/page-ui.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;工作&lt;/td&gt; &lt;td&gt;QQ&lt;/td&gt; &lt;td&gt;手机号码&lt;/td&gt; &lt;td&gt;留言内容&lt;/td&gt; &lt;/tr&gt; &lt;?php foreach ($data as $key =&gt; $val) { ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$val['id']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['userName']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['job']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['qqnum']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['phone']?&gt;&lt;/td&gt; &lt;td&gt;&lt;?=$val['remark']?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php } ?&gt; &lt;/table&gt; &lt;?=$pagehtml?&gt; &lt;!-- 显示分页样式 --&gt; &lt;img src=\"http://localhost/space/verify.php\" onclick=\"resetPic(this)\"&gt; &lt;!-- 显示图片验证码 --&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function resetPic(obj) { $(obj).attr('src', \"http://localhost/space/verify.php\"); //点击二维码刷新 } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附：本人建立test数据库contact表的sql文件： 123456789use test; create table contact( id int primary key auto_increment, userName char(20) not null unique, job char(10) not null, qqnum char(10) not null, phone char(100), remark text );","link":"/2018/09/17/php mysql数据库面向对象简单操作类（增删改查）、分页类和图片验证码类的封装/"},{"title":"浅谈PHP面向对象编程","text":"本篇文章给大家分享的内容是关于浅谈PHP面向对象编程 ，有着一定的参考价值，有需要的朋友可以参考一下。 一、PHP面向对象编程基础实践 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** 通过对象的编程方式，可将实现生活中的一切事物以对象的形式表现出来。便于理解、维护、扩展等；* 本示例：定义一个“人”类* $name : 对象中的成员属性，在此类中表示人的姓名* say() : 对象中的成员方法，在此类中表示人说话的方法* $this : PHP中的伪变量，表示自身的类* __construct() : php中的魔术方法，构造函数，在实例化类时自动执行* __destruct() : php中的魔术方法，析构函数，当类调用完成后自动执行*/class Human{ public $name; public $sex; public $age; public function __construct($name,$sex,$age) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } public function say() { echo '大家好，我的名字叫'.$this-&gt;name.'，今年'.$this-&gt;age.'岁，我的性别是'.$this-&gt;sex; } public function __destruct() { $this-&gt;name = null; $this-&gt;sex = null; $this-&gt;age = null; }}//实例化“人”类$male = new Human(\"张三\",\"男\",\"20\");//调用“人”类说话的方法$male-&gt;say(); //输出结果：大家好，我的名字叫张三，今年20岁，我的性别是男?&gt; 二、PHP面向对象高级编程实践知识点：类的继承、方法重写、访问控制、static关键字、final关键字、数据访问、接口、多态、抽象类 2.1、类的继承：extends 关键字例如：一员运行员、一位主持人，他们有人类共同的行为方法，但他们都有自己不同的特长专业。因此在编程时需要给他们创建一个父类并继承； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** 创建一个“人”类做为父类，继承的子类都拥有其父类的成员属性、方法*/class Human{ public $name; public function say() { echo \"父类说话的方法，姓名：\".$this-&gt;name.\"\\n\"; } public function eat() { echo \"父类吃饭的方法\\n\"; }}/** 创建一个“运动员”类，继承“人”类* extends : 关键字，继承某个类*/class Sport extends Human{ public $type; public function __construct($name,$type) { $this-&gt;name = $name; //给父类 $name 属性赋值 $this-&gt;type = $type; } public function run() { $this-&gt;say(); //调用父类“说话”的方法 echo \"我在正跑步，我是一员\".$this-&gt;type.\"运动员.....\\n\"; }}/** 创建一个“主持人”类，继承“人”类* extends : 关键字，继承某个类*/class Host extends Human{ public $television; public function __construct($name,$television) { $this-&gt;name = $name; $this-&gt;television= $television; } public function perform() { $this-&gt;eat(); //调用父类“吃饭”的方法 echo \"我在正表演一个节目，我是\".$this-&gt;television.\"电视台的一名主持人.....\\n\"; }} //实例化“运动员”类$nba = new Sport(\"乔丹\",\"篮球\");$nba-&gt;run(); //实例化“主持人”类$tv = new Host(\"张三\",\"北京卫视\");$tv-&gt;perform(); //输出结果：//父类说话的方法，姓名：乔丹 我在正跑步，我是一员篮球运动员..... //父类吃饭的方法 我在正表演一个节目，我是北京卫视电视台的一名主持人.....?&gt; 2.2、方法重写：子类重写父类的方法 1234567891011121314151617181920&lt;?phpclass Human{ public function say() { echo \"父类说话的方法\"; }}class Sport extends Human{ //重写父类“说话”的方法 public function say() { echo \"子类说话的方法\"; }}$nba = new Sport();$nba-&gt;say();//输出结果：子类说话的方法?&gt; 2.3、访问控制：public 、 protected 、private 关键字 public：定义公共的成员属性或方法，任何地方都可使用protected : 定义受保护的成员属性或方法，只允许类本身或子类使用private : 定义私有的成员属性或方法，只允许类的本身使用 123456789101112&lt;?phpclass Human{ public $name; protected $sex; private $age; }//实例化对象，给公共属性赋值可正常输出结果，外部不能给protected、private受保护的成员属性赋值或使用$worker = new Human();$worker-&gt;name = \"张三\";echo $worker-&gt;name;?&gt; 2.4、static（静态）关键字1）、静态属性用于保存类的公有数据；2）、静态方法里面只能访问静态属性或方法，不能使用 $this 伪变量；3）、静态成员不需要通过 new 关键字来实例化对象就可访问使用； 123456789101112131415&lt;?phpclass Human{ static $name = \"张三\"; static function say() { echo \"我的姓名叫：\".self::$name; }}//外部使用静态成员属性或方法echo Human::$name;Human::say(); //输出结果：张三 我的姓名叫：张三?&gt; 2.5、final关键字：不允许成员方法被重写，不允许被继承例：1、对于父类“吃饭”这个方法，不希望子类重写它；2、对于“运动员”这个类，不希望它再创建子类； 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Human{ final public function eat() { echo \"父类吃饭的方法，不允许子类重写\"; }}final class Sport extends Human{ public function eat() { echo \"子类吃饭的方法。此时程序将会报致命错误\"; }}//创建一个类继承 Sport 这个类。此时程序也将会报致命错误。因为 Sport 类不允许再创建子类class Student extends Sport{ public $name;} //实例化 Sport 类 ，调用 eat() 方法$nba = new Sport();$nba-&gt;eat(); //实例化 Student 类 ，给 name 属性负值$obj = new Student();$obj-&gt;name = \"张三\"; //输出结果：Fatal error: Cannot override final method Human::eat() in ******.php on line 15//Fatal error: Class Student may not inherit from final class (Sport) in ****.php on line 20?&gt; 2.6、数据访问：$this 、 self 、parent 关键字$this ： 伪变量，代表类的本身，可访问本类及父类中的成员属性与方法。self ： 访问类中的静态成员属性或方法parent ：访问父类的成员属性或方法 1234567891011121314151617181920&lt;?phpclass Human{ static $name = \"张三\";}class Sport extends Human{ static function getParentName() { echo parent::$name; } public function get() { self::getParentName(); }}$obj = new Sport();$obj-&gt;get();//输出结果：张三?&gt; 2.7、接口：把不同类的共同行为方法进行定义，但不具体实现，由子类来实现具体的方法；例如：人会吃饭，动物也会吃饭，甚至有些植物也会吃饭，但他们吃饭的方式不一样，因此这时需要定义一个接口类，具体的方式由子类来实现；定义接口关键字：interface实现接口方法关键字：implements 123456789101112131415161718192021222324252627282930313233&lt;?php//定义一个接口类，有吃饭的方法，但不具体实现。interface ICanEat{ public function eat($food);}class Human implements ICanEat{ //eat()方法必须由子类来实现，否则程序将报致命错误 public function eat($food) { echo \"I'm eating \".$food; }}class Animal implements ICanEat{ public function eat($food) { echo \"It's eating \".$food; }}//实例化一个“人”类$people = new Human();$people-&gt;eat('rice'); //实例化一个“动物”类$monkey = new Animal();$monkey-&gt;eat('banana'); //输出结果：I'm eating rice// It's eating banana ?&gt; 2.8、多态：比如接口A有两个实现B和C，B和C对A接口里面定义的方法实现可以是不同的，这种现象称之为多态；上述实例中，ICanEat接口定义了一个eat()方法，人类吃米饭，猴子吃香蕉。他们都实现了一个“吃”的方法，但他们吃东西有不同的行为，称之为多态； 2.9、抽象类：介入接口与类的定义之间，允许类里面一部分方法不实现，实现一部分有相同功能且不会更改的方法。然而接口类里面不允许有任何实现的方法。例如：人和动物都具有吃饭与呼吸的方法，除吃饭不同以外，呼吸方法是相同的，此时需要定义一个抽象类来实现。定义抽象类关键字：abstract 1234567891011121314151617181920212223&lt;?php//定义一个抽象类，里面有吃饭和呼吸的方法。呼吸方法需要在抽象类中具体实现abstract class ICanEat{ abstract function eat($food); public function breath() { echo 'Breath use the air...'; }}class Human extends ICanEat{ public function eat($food) { echo \"I'm eating \".$food; $this-&gt;breath(); }}//实例化“人”类$people = new Human();$people-&gt;eat('rice');//输出结果:I'm eating rice Breath use the air...?&gt; 三、PHP面向对象编程特殊实践PHP语言特定的一些魔术方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Object{ public function __construct() { echo \"当类在被实例化的时候，自动执行该函数\"; } public function __toString() { return \"当对象被当作字符串形式输出时，自动执行该函数\"; } public function __invoke($value) { echo \"当对象被当作函数调用时，自动执行该函数\".$value; } /* * 当对象访问不存在的方法时，自动执行该函数。也称之为“方法重载” * $fun : 方法名称 * $param : 传递的参数 */ public function __call($fun,$param) { echo \"调用\".$fun.\"方法不存在，传递的参数\".implode(',',$param); } /* * 当对象访问不存在的静态方法时，自动执行该函数。 * $fun : 方法名称 * $param : 传递的参数 */ static function __callStatic($fun,$param) { echo \"调用\".$fun.\"静态方法不存在，传递的参数\".implode(',',$param); } public function __get($key) { echo \"当读取对象中不可访问（未定义）的属性值时，自动调用该函数。\".$key.\"属性不可访问或未定义\"; } public function __set($key,$value) { echo \"当给对象中不可访问（未定义）的属性赋值时，自动调用该函数。\".$key.\"属性不可访问或未定义，值\".$value; } public function __isset($key) { echo \"判断对象中的属性不存在时，自动执行该函数。属性：\".$key.\"值未定义\"; } public function __unset($key) { echo \"释放对象中的不存在的属性值时，自动执行该函数。属性：\".$key.\"值未定义\"; } public function __clone() { echo \"当对象被克隆时，自动执行该函数。\"; } public function __destruct() { echo \"当对象执行完成后，自动执行该函数\"; }}$obj = new Object(); //实例化对象时，调用__construct()方法echo $obj; //将对象以字符串形式输出时，调用__toString()方法$obj(123); //当对象以函数形式调用时，执行__invoke()方法$obj-&gt;runTest(); //当调用对象中不存在的方法时，执行__call()方法$obj::runTest(); //当调用对象中不存在的静态方法时，执行__callStatic()方法$obj-&gt;name; //当调用对象中不存在的成员属性时，执行__get()方法$obj-&gt;name = \"张三\"; //当给对象中不存在的成员属性赋值时，执行__set()方法isset($obj-&gt;name) ? 1 : 0; //判断对象中不存在的成员属性时，执行__isset()方法unset($obj-&gt;name); //释放对象中的不存在的属性值时，执行__unset()方法$obj2 = clone $obj; //当对象被克隆时，执行__clone()方法 //对象执行完毕，执行__destruct()方法?&gt;","link":"/2018/09/12/浅谈php面向对象编程/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段二）","text":"我在上一篇文章中，简要介绍了浏览器的工作大致可以分为 6 个阶段，我们昨天讲完了第一个阶段，也就是通讯的部分：浏览器使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面的过程。 这次我们主要来看两个过程：如何解析请求回来的 HTML 代码，DOM 树又是如何构建的。 解析代码 我们在前面讲到了 HTTP 的构成，但是我们有一部分没有详细讲解，那就是 Response 的 body 部分，这正是因为 HTTP 的Response 的 body，就要交给我们今天学习的内容去处理了。 HTML 的结构不算太复杂，我们日常开发需要的 90% 的“词”（指编译原理的术语 token，表示最小的有意义的单元），种类大约只有标签开始、属性、标签结束、注释、CDATA 节点几种。 实际上有点麻烦的是，由于 HTML 跟 SGML 的千丝万缕的联系，我们需要做不少容错处理。“&lt;?”和“&lt;%”什么的也是必须要支持好的，报了错也不能吭声。 1. 词（token）是如何被拆分的 首先我们来看看一个非常标准的标签，会被如何拆分：1&lt;p class=\"a\"&gt;text text text如果我们从最小有意义单元的定义来拆分，第一个词（token）是什么呢？显然，作为一个词（token），整个 p 标签肯定是过大了（它甚至可以嵌套）。那么，只用 p 标签的开头是不是合适吗？我们考虑到起始标签也是会包含属性的，最小的意义单元其实是“&lt;p” ，所以“ &lt;p” 就是我们的第一个词（token）。我们继续拆分，可以把这段代码依次拆成词（token）： &lt;p“标签开始”的开始； class=“a” 属性； &gt; “标签开始”的结束； text text text 文本； &lt;/p&gt; 标签结束。这是一段最简单的例子，类似的还有什么呢？现在我们可以来来看看这些词（token）长成啥样子：根据这样的分析，现在我们讲讲浏览器是如何用代码实现，我们设想，代码开始从 HTTP 协议收到的字符流读取字符。在接受第一个字符之前，我们完全无法判断这是哪一个词（token），不过，随着我们接受的字符越来越多，拼出其他的内容可能性就越来越少。比如，假设我们接受了一个字符“ &lt; ” 我们一下子就知道这不是一个文本节点啦。之后我们再读一个字符，比如就是 x，那么我们一下子就知道这不是注释和 CDATA 了，接下来我们就一直读，直到遇到“&gt;”或者空格，这样就得到了一个完整的词（token）了。实际上，我们每读入一个字符，其实都要做一次决策，而且这些决定是跟“当前状态”有关的。在这样的条件下，浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。2. 状态机绝大多数语言的词法部分都是用状态机实现的。那么我们来把部分词（token）的解析画成一个状态机看看：当然了，我们这里的分析比较粗略，真正完整的 HTML 词法状态机，比我们描述的要复杂的多。更详细的内容，你可以参考HTML 官方文档，HTML 官方文档规定了 80 个状态（顺便一说，HTML 是我见过唯一一个标准中规定了状态机实现的语言，对大部分语言来说，状态机是一种实现而非定义）。这里我们为了理解原理，用这个简单的状态机就足够说明问题了。状态机的初始状态，我们仅仅区分 “&lt; ”和 “非 &lt;”： 如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点； 如果获得的是一个 &lt; 字符，那么进入一个标签状态。不过当我们在标签状态时，则会面临着一些可能性。 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。 如果下一个字符是字母，那么可以确定进入了一个开始标签。 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。 我们可以看到，用状态机做词法分析，其实正是把每个词的“特征字符”逐个拆开成独立状态，然后再把所有词的特征字符链合并起来，形成一个联通图结构。由于状态机设计属于编译原理的基本知识，这里我们仅作一个简要的介绍。接下来就是代码实现的事情了，在 C/C++ 和 JavaScript中，实现状态机的方式大同小异：我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。（这里我希望再次强调下，状态机真的是一种没有办法封装的东西，所以我们永远不要试图封装状态机。为了方便理解和试验，我们这里用 JavaScript 来讲解，图上的 data 状态大概就像下面这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344var data = function(c){ if(c==\"&amp;\") { return characterReferenceInData; } if(c==\"&lt;\") { return tagOpen; } else if(c==\"\\0\") { error(); emitToken(c); return data; } else if(c==EOF) { emitToken(EOF); return data; } else { emitToken(c); return data; }};var tagOpenState = function tagOpenState(c){ if(c==\"/\") { return endTagOpenState; } if(c.match(/[A-Z]/)) { token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; } if(c.match(/[a-z]/)) { token = new StartTagToken(); token.name = c; return tagNameState; } if(c==\"?\") { return bogusCommentState; } else { error(); return dataState; }};//……这段代码给出了状态机的两个状态示例：data 即为初始状态，tagOpenState 是接受了一个“ &lt; ” 字符，来判断标签类型的状态。这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。这样，我们的状态迁移代码非常的简单：1234var state = data;var charwhile(char = getInput()) state = state(char);这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。状态函数通过代码中的 emitToken 函数来输出解析好的 token（词），我们只需要覆盖 emitToken，即可指定对解析结果的处理方式。词法分析器接受字符的方式很简单，就像下面这样：12345678910111213141516function HTMLLexicalParser(){ // 状态函数们…… function data() { // …… } function tagOpen() { // …… } // …… var state = data; this.receiveInput = function(char) { state = state(char); }}至此，我们就把字符流拆成了词（token）了。构建 DOM 树接下来我们要把这些简单的词变成 DOM 树，这个过程我们是使用栈来实现的，任何语言几乎都有栈，为了给你跑着玩，我们还是用 JavaScript 来实现吧，毕竟 JavaScript 中的栈只要用数组就好了。123456789function HTMLSyntaticalParser(){ var stack = [new HTMLDocument]; this.receiveInput = function(token) { //…… } this.getOutput = function(){ return stack[0]; }}我们这样来设计 HTML 的语法分析器，receiveInput 负责接收词法部分产生的词（token），通常可以由 emmitToken 来调用。在接收的同时，即开始构建 DOM 树，所以我们的主要构建 DOM 树的算法，就写在 receiveInput 当中。当接收完所有输入，栈顶就是最后的根节点，我们 DOM 树的产出，就是这个 stack 的第一项。为了构建 DOM 树，我们需要一个 Node 类，接下来我们所有的节点都会是这个 Node 类的实例。在完全符合标准的浏览器中，不一样的 HTML 节点对应了不同的 Node 的子类，我们为了简化，就不完整实现这个继承体系了。我们仅仅把 Node 分为 Element 和 Text（如果是基于类的 OOP的话，我们还需要抽象工厂来创建对象），123456function Element(){ this.childNodes = [];}function Text(value){ this.value = value || \"\";}前面我们的词（token）中，以下两个是需要成对匹配的： tag start tag end根据一些编译原理中常见的技巧，我们使用的栈正是用于匹配开始和结束标签的方案。对于 Text 节点，我们则需要把相邻的 Text 节点合并起来，我们的做法是当词（token）入栈时，检查栈顶是否是 Text 节点，如果是的话就合并 Text 节点同样我们来看看直观的解析过程：12345678&lt;html maaa=a &gt; &lt;head&gt; &lt;title&gt;cool&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"a\" /&gt; &lt;/body&gt;&lt;/html&gt;通过这个栈，我们可以构建 DOM 树： 栈顶元素就是当前节点； 遇到属性，就添加到当前节点； 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点； 遇到注释节点，作为当前节点的子节点； 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点； 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。我在文章里面放了一个视频，你可以点击查看用栈构造 DOM 树的全过程。 当我们的源代码完全遵循 xhtml（这是一种比较严谨的 HTML 语法）时，这非常简单问题，然而 HTML 具有很强的容错能力，奥妙在于当 tag end 跟栈顶的 start tag 不匹配的时候如何处理。于是，这又有一个极其复杂的规则，幸好 W3C 又一次很贴心地把全部规则都整理地很好，我们只要翻译成对应的代码就好了，以下这个网站呈现了全部规则。你可以点击查看。http://www.w3.org/html/wg/drafts/html/master/syntax.html#tree-construction结语好了，总结一下。在今天的文章中，我带你继续探索了浏览器的工作原理，我们主要研究了解析代码和构建 DOM 树两个步骤。在解析代码的环节里，我们一起详细地分析了一个词（token）被拆分的过程，并且给出了实现它所需要的一个简单的状态机。在构建 DOM 树的环节中，基本思路是使用栈来构建 DOM 树为了方便你动手实践，我用 JavaScript 实现了这一过程。转自—《重学前端》","link":"/2019/03/22/浏览器：一个浏览器是如何工作的？（阶段二）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段一）","text":"对于前端开发来说，我们平时与浏览器打交道的时间是最多的。可浏览器对前端同学来说更多像一个神秘黑盒子的存在。我们仅仅知道它能做什么，而不知道它是如何做到的。 在我面试和接触过的前端开发者中，70% 的前端同学对这部分的知识内容只能达到“一知半解”的程度。甚至还有一部分同学会质疑这部分知识是否重要：这与我们的工作相关吗，学多了会不会偏移前端工作的方向？ 事实上，我们这里所需要了解的浏览器工作原理只是它的大致过程，这部分浏览器工作原理不但是前端面试的常考知识点，它还会辅助你的实际工作，学习浏览器的内部工作原理和个中缘由，对于我们做性能优化、排查错误都有很大的好处。 在我们的课程中，我也会控制浏览器相关知识的粒度，把它保持在“给前端工程师了解浏览器”的水准，而不是详细到“给浏览器开发工程师实现浏览器”的水准。 那么，我们今天开始，来共同思考一下。一个浏览器到底是如何工作的。 实际上，对浏览器的实现者来说，他们做的事情，就是把一个 URL 变成一个屏幕上显示的网页。 这个过程是这样的： 浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面； 把请求回来的 HTML 代码经过解析，构建成 DOM 树； 计算 DOM 树上的 CSS 属性； 最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图； 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度； 合成之后，再绘制到界面上。 我们在开始详细介绍之前，要建立一个感性认识。我们从 HTTP 请求回来开始，这个过程并非一般想象中的一步做完再做下一步，而是一条流水线。 从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出：即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。 首先我们来介绍下网络通讯的部分。 HTTP 协议浏览器首先要做的事就是根据 URL 把数据取回来，取回数据使用的是 HTTP 协议（实际上这个过程之前还有 DNS 查询，不过这里就不详细展开了。） 我先来了解下 HTTP 的标准。 HTTP 标准由 IETF 组织制定，跟它相关的标准主要有两份： HTTP1.1 https://tools.ietf.org/html/rfc2616 2.HTTP1.1 https://tools.ietf.org/html/rfc7234 HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。 大部分情况下，浏览器的实现者只需要用一个 TCP 库，甚至一个现成的 HTTP 库就可以搞定浏览器的网络通讯部分。HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。 下面，我们试着用一个纯粹的 TCP 客户端来手工实现 HTTP 一下： 实验我们的实验需要使用 telnet 客户端，这个客户端是一个纯粹的 TCP 连接工具（安装方法）。 首先我们运行 telnet，连接到极客时间主机，在命令行里输入以下内容： 1telnet time.geekbang.org 80 这个时候，TCP 连接已经建立，我们输入以下字符作为请求： 12GET / HTTP/1.1Host: time.geekbang.org 按下两次回车，我们收到了服务端的回复： 123456789101112131415HTTP/1.1 301 Moved PermanentlyDate: Fri, 25 Jan 2019 13:28:12 GMTContent-Type: text/htmlContent-Length: 182Connection: keep-aliveLocation: https://time.geekbang.org/Strict-Transport-Security: max-age=15768000&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"white\"&gt;&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 这就是一次完整的 HTTP 请求的过程了，我们可以看到，在 TCP 通道中传输的，完全是文本。 在请求部分，第一行被称作 request line，它分为三个部分，HTTP Method，也就是请求的“方法”，请求的路径和请求的协议和版本。 在响应部分，第一行被称作 response line，它也分为三个部分，协议和版本、状态码和状态文本。 紧随在 request line 或者 response line 之后，是请求头 / 响应头，这些头由若干行组成，每行是用冒号分隔的名称和值。在头之后，以一个空行（两个换行符）为分隔，是请求体 / 响应体，请求体可能包含文件或者表单数据，响应体则是 html 代码。 HTTP 协议格式根据上面的分析，我们可以知道 HTTP 协议，大概可以划分成如下部分。 我们简单看一下，在这些部分中，path 是请求的路径完全由服务端来定义，没有很多的特别内容；而 version 几乎都是固定字符串；response body 是我们最熟悉的 HTML，我在后面会有专门的课程介绍，这里也就不多讲了。 下面我们就来逐个给你介绍其它部分。 HTTP Method（方法）我们首先来介绍一下 request line 里面的方法部分。这里的方法跟我们编程中的方法意义类似，表示我们此次 HTTP 请求希望执行的操作类型。方法有以下几种定义： GET POST HEAD PUT DELETE CONNECT OPTIONS TRACE浏览器通过地址栏访问页面都是 GET 方法。表单提交产生 POST 方法。 HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起 PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。 CONNECT 现在多用于 HTTPS 和 WebSocket。 OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。 HTTP Status code（状态码）和 Status text（状态文本）接下来我们看看 response line 的状态码和状态文本。常见的状态码有以下几种。 1xx：临时回应，表示客户端请继续。 2xx：请求成功。 200：请求成功。 3xx: 表示请求的目标有变化，希望客户端进一步处理。 301&amp;302：永久性与临时性跳转。 304：跟客户端缓存没有更新。 4xx：客户端请求错误。 403：无权限。 404：表示请求的页面不存在。 418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。（超文本咖啡壶控制协议） 5xx：服务端请求错误。 500：服务端错误。 503：服务端暂时性错误，可以一会再试。 对我们前端来说，1xx 系列的状态码是非常陌生的，原因是 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。2xx 系列的状态最熟悉的就是 200，这通常是网页请求成功的标志，也是大家最喜欢的状态码。 3xx 系列比较复杂，301 和 302 两个状态表示当前资源已经被转移，只不过一个是永久性转移，一个是临时性转移。实际上 301 更接近于一种报错，提示客户端下次别来了。 304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。 HTTP Head (HTTP 头)HTTP 头可以看作一个键值对。原则上，HTTP 头也是一种数据，我们可以自由定义 HTTP 头和值。不过在 HTTP 规范中，规定了一些特殊的 HTTP 头，我们现在就来了解一下它们。 在 HTTP 标准中，有完整的请求 / 响应头规定，这里我们挑几个重点的说一下： 我们先来看看 Request Header。接下来看一下 Response Header。 这里仅仅列出了我认为比较常见的 HTTP 头，这些头是我认为前端工程师应该做到不需要查阅，看到就可以知道意思的 HTTP 头。完整的列表还是请你参考我给出的 rfc2616 标准。 HTTP Request BodyHTTP 请求的 body 主要用于提交表单场景。实际上，http 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是： application/json application/x-www-form-urlencoded multipart/form-data text/xml我们使用 html 的 form 标签提交产生的 html 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。 HTTPS在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 Request-Response 模式。 我们首先来了解下 HTTPS。HTTPS 有两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被网络中间节点窃听或者篡改。 HTTPS 的标准也是由 RFC 规定的，你可以查看它的详情链接：https://tools.ietf.org/html/rfc2818 HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP没有任何区别。 HTTP 2HTTP 2 是 HTTP 1.1 的升级版本，你可以查看它的详情链接。https://tools.ietf.org/html/rfc7540 HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。 服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。 TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。 Note: 其实很多优化涉及更下层的协议。IP 层的分包情况，和物理层的建连时间是需要被考虑的。 结语在这一节内容中，我们一起学习了浏览器的第一步工作，也就是“浏览器首先使用 HTTP 协议或 HTTPS 协议，向服务端请求页面”的这一过程。 在这个过程中，掌握 HTTP 协议是重中之重。我从一个小实验开始，带你体验了一次完整的 HTTP 请求过程。我们一起先分析了 HTTP 协议的结构。接下来，我分别介绍了 HTTP 方法、HTTP 状态码和状态文本、HTTP Head和 HTTP Request Body 几个重点需要注意的部分。 最后，我还介绍了 HTTPS 和 HTTP 2 这两个补充版本，以便你可以更好地熟悉并理解新的特性。 转自–《重学前端》","link":"/2019/03/22/浏览器：一个浏览器是如何工作的？（阶段一）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段四）","text":"我们书接上文。浏览器进行到这一步，我们已经给 DOM 元素添加了用于展现的 CSS 属性，接下来，浏览器的工作就是确定每一个元素的位置了。我们的基本原则仍然不变，就是尽可能流式地处理上一步骤的输出。 在构建 DOM 树和计算 CSS 属性这两个步骤，我们的产出都是一个一个的元素，但是在排版这个步骤中，有些情况下，我们就没法做到这样了。 尤其是表格相关排版、flex 排版和 grid 排版，它们有一个显著的特点，那就是子元素之间具有关联性。 基本概念 首先我们先来介绍一些基本概念，使你可以感性地认识一下我们平常说的各种术语。 “排版”这个概念最初来自活字印刷，是指我们把一个一个的铅字根据文章顺序，放入板框当中的步骤，排版的意思是确定每一个字的位置。 在现代浏览器中，仍然借用了这个概念，但是排版的内容更加复杂，包括文字、图片、图形、表格等等，我们把浏览器确定它们位置的过程，叫作排版。 浏览器最基本的排版方案是正常流排版，它包含了顺次排布和折行等规则，这是一个跟我们提到的印刷排版类似的排版方案，也跟我们平时书写文字的方式一致，所以我们把它叫做正常流。 浏览器的文字排版遵循公认的文字排版规范，文字排版是一个复杂的系统，它规定了行模型和文字在行模型中的排布。行模型规定了行顶、行底、文字区域、基线等对齐方式。（你还记得小时候写英语的英语本吗？英语本上的四条线就是一个简单的行模型） 此外，浏览器支持不同语言，因为不同语言的书写顺序不一致，所以浏览器的文本排版还支持双向文字系统。 浏览器又可以支持元素和文字的混排，元素被定义为占据长方形的区域，还允许边框、边距和留白，这个就是所谓的盒模型。 在正常流的基础上，浏览器还支持两类元素：绝对定位元素和浮动元素。 绝对定位元素把自身从正常流抽出，直接由 top 和 left 等属性确定自身的位置，不参加排版计算，也不影响其它元素。绝对定位元素由 position 属性控制。 浮动元素则是使得自己在正常流的位置向左或者向右移动到边界，并且占据一块排版空间。浮动元素由 float 属性控制。 除了正常流，浏览器还支持其它排版方式，比如现在非常常用的 flex 排版，这些排版方式由外部元素的 display 属性来控制（注意，display 同时还控制元素在正常流中属于 inline 等级还是 block 等级）。 正常流文字排版 我们会在 CSS 部分详细介绍正常流排版的行为，我们这里主要介绍浏览器中的正常流。正常流是唯一一个文字和盒混排的排版方式，我们先从文字来讲起。 要想理解正常流，我们首先要回忆一下自己如何在纸上写文章。 首先，纸是有固定宽度的，虽然纸有固定高度，但是我们可以通过下一页纸的方式来接续，因此我们不存在写不下的场景。 我们书写文字的时候，是从左到右依次书写，每一个字跟上一个字都不重叠，文字之间有一定间距，当写满一行时，我们换到下一行去继续写。 书写中文时，文字的上、下、中轴线都对齐，书写英文时，不同字母的高度不同，但是有一条基线对齐。 实际上浏览器环境也很类似。但是因为浏览器支持改变排版方向，不一定是从左到右从上到下，所以我们把文字依次书写的延伸方向称为主轴或者主方向，换行延伸的方向，跟主轴垂直交叉，称为交叉轴或者交叉方向。 我们一般会从某个字体文件中获取某个特定文字的相关信息。我们获取到的信息大概类似下面： 纵向版本： 这两张图片来自著名开源字体解析库 freetype，实际上，各个库对字体的理解大同小异，我们注意一下，advance 代表每一个文字排布后在主轴上的前进距离，它跟文字的宽 / 高不相等，是字体中最重要的属性。 除了字体提供的字形本身包含的信息，文字排版还受到一些 CSS 属性影响，如 line-height、letter-spacing、word-spacing 等。 在正常流的文字排版中，多数元素被当作长方形盒来排版，而只有 display 为 inline 的元素，是被拆成文本来排版的（还有一种 run-in 元素，它有时作为盒，有时作为文字，不太常用，这里不详细讲了）。 display 值为 inline 的元素中的文字排版时会被直接排入文字流中，inline 元素主轴方向的 margin 属性和 border 属性（例如主轴为横向时的 margin-left 和margin-right）也会被计算进排版前进距离当中。 注意，当没有强制指定文字书写方向时，在左到右文字中插入右到左向文字，会形成一个双向文字盒，反之亦然。 这样，即使没有元素包裹，混合书写方向的文字也可以形成一个盒结构，我们在排版时，遇到这样的双向文字盒，会先排完盒内再排盒外。 正常流中的盒 在正常流中，display 不为 inline 的元素或者伪元素，会以盒的形式跟文字一起排版。多数 display 属性都可以分成两部分：内部的排版和是否 inline，带有 inline- 前缀的盒，被称作行内级盒。 根据盒模型，一个盒具有 margin、border、padding、width/height 等属性，它在主轴方向占据的空间是由对应方向的这几个属性之和决定的，而 vertical-align属性决定了盒在交叉轴方向的位置，同时也会影响实际行高。 所以，浏览器对行的排版，一般是先行内布局，再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。 块级盒比较简单，它总是单独占据一整行，计算出交叉轴方向的高度即可。 绝对定位元素 position 属性为 absolute 的元素，我们需要根据它的包含块来确定位置，这是完全跟正常流无关的一种独立排版模式，逐层找到其父级的 position 非 static 元素即可。 浮动元素排版 float 元素非常特别，浏览器对 float 的处理是先排入正常流，再移动到排版宽度的最左 / 最右（这里实际上是主轴的最前和最后）。 移动之后，float 元素占据了一块排版的空间，因此，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。 float 元素排布完成后，float 元素所在的行需要重新确定位置。 其它的排版 CSS 的每一种排版都有一个很复杂的规定，实际实现形式也各不相同。比如如 flex 排版，支持了 flex 属性，flex 属性将每一行排版后的剩余空间平均分配给主轴方向的 width/height属性。浏览器支持的每一种排版方式，都是按照对应的标准来实现的。 总结 这一部分，我们以正常流为主，介绍了浏览器的排版基本概念及一些算法。这里，我主要介绍了正常流中的文字排版、正常流中的盒、绝对定位元素、浮动元素排版这几种情况。最后，我还简单介绍了一下 flex排版。这属于进阶版的排版方式了，你可以了解一下。 你平时喜欢使用方式排版呢，欢迎留言告诉我。 转自—《重学前端》","link":"/2019/03/23/浏览器：一个浏览器是如何工作的？（阶段四）/"},{"title":"浏览器：一个浏览器是如何工作的？（阶段五）","text":"我们的浏览器系列已经进行到最后一篇。 在之前的几篇文章中，我们已经经历了把 URL 变成字符流，把字符流变成词（token）流，把词（token）流构造成 DOM 树，把不含样式信息的 DOM 树应用 CSS 规则，变成包含样式信息的 DOM树，并且根据样式信息，计算了每个元素的位置和大小。 那么，我们最后的步骤，就是根据这些样式信息和大小信息，为每个元素在内存中渲染它的图形，并且把它绘制到对应的位置。 渲染 首先我们来谈谈渲染这个词，渲染也是个外来词，它是英文词 render 的翻译，render 这个词在英文里面，有“导致”“变成”的意思，也有“粉刷墙壁”的意思。 在计算机图形学领域里，英文 render 这个词是一个简写，它是特指把模型变成位图的过程。我们把 render 翻译成“渲染”，是个非常有意思的翻译，中文里“渲染”这个词是一种绘画技法，是指沾清水把墨涂开的意思。 所以，render 翻译成“渲染”，我认为是非常高明的，对 render 这个过程，用国画的渲染手法来概括，是颇有神似的。 我们现在的一些框架，也会把“从数据变成 HTML 代码的过程”称为 render，其实我觉得这是非常具有误导性的，我个人是非常不喜欢这种命名方式，当然了，所谓“文无第一”，在自然语言的范围里，我们很难彻底否定这种用法的合理性。 不过，在本篇文章中，我们可以约定一下，本文中出现的“渲染”一词，统一指的是它在图形学的意义，也就是把模型变成位图的过程。 这里的位图就是在内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去（位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分）。 浏览器中渲染这个过程，就是把每一个元素对应的盒变成位图。这里的元素包括 HTML 元素和伪元素，一个元素可能对应多个盒（比如 inline 元素，可能会分成多行）。每一个盒对应着一张位图。 这个渲染过程是非常复杂的，但是总体来说，可以分成两个大类：图形和文字。 盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类。这就像我们实现 HTTP 协议必须要基于 TCP 库一样，这一部分，我们需要一个底层库来支持。 一般的操作系统会提供一个底层库，比如在 Android 中，有大名鼎鼎的 Skia，而 Windows 平台则有 GDI，一般的浏览器会做一个兼容层来处理掉平台差异。 这些盒的特性如何绘制，每一个都有对应的标准规定，而每一个的实现都可以作为一个独立的课题来研究，当年圆角 + 虚线边框，可是难倒了各个浏览器的工程师。考虑到这些知识互相都比较独立，对前端工程师来说也不是特别重要的细节，我们这里就不详细探究了。 盒中的文字，也需要用底层库来支持，叫做字体库。字体库提供读取字体文件的基本能力，它能根据字符的码点抽取出字形。 字形分为像素字形和矢量字形两种。通常的字体，会在 6px 8px 等小尺寸提供像素字形，比较大的尺寸则提供矢量字形。矢量字形本身就需要经过渲染才能继续渲染到元素的位图上去。目前最常用的字体库是 Freetype，这是一个 C++编写的开源的字体库。 在最普遍的情况下，渲染过程生成的位图尺寸跟它在上一步排版时占据的尺寸相同。 但是理想和现实是有差距的，很多属性会影响渲染位图的大小，比如阴影，它可能非常巨大，或者渲染到非常遥远的位置，所以为了优化，浏览器实际的实现中会把阴影作为一个独立的盒来处理。 注意，我们这里讲的渲染过程，是不会把子元素绘制到渲染的位图上的，这样，当父子元素的相对位置发生变化时，可以保证渲染的结果能够最大程度被缓存，减少重新渲染。 合成 合成是英文术语 compositing 的翻译，这个过程实际上是一个性能考量，它并非实现浏览器的必要一环。 我们上一小节中讲到，渲染过程不会把子元素渲染到位图上面，合成的过程，就是为一些元素创建一个“合成后的位图”（我们把它称为合成层），把一部分子元素渲染到合成的位图上面。 看到这句话，我想你一定会问问题，到底是为哪些元素创建合成后的位图，把哪些子元素渲染到合成的位图上面呢？ 这就是我们要讲的合成的策略。我们前面讲了，合成是一个性能考量，那么合成的目标就是提高性能，根据这个目标，我们建立的原则就是最大限度减少绘制次数原则。 我们举一个极端的例子。如果我们把所有元素都进行合成，比如我们为根元素 html 创建一个合成后的位图，把所有子元素都进行合成，那么会发生什么呢？ 那就是，一旦我们用 JavaScript 或者别的什么方式，改变了任何一个 CSS 属性，这份合成后的位图就失效了，我们需要重新绘制所有的元素。 那么如果我们所有的元素都不合成，会怎样呢？结果就是，相当于每次我们都必须要重新绘制所有的元素，这也不是对性能友好的选择。 那么好的合成策略是什么呢，好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。 我们来举个例子：1234&lt;div id=\"a\"&gt; &lt;div id=\"b\"&gt;...&lt;/div&gt; &lt;div id=\"c\" style=\"transform:translate(0,0)\"&gt;&lt;/div&gt;&lt;/div&gt;假设我们的合成策略能够把 a、b 两个 div 合成，而不把 c 合成，那么，当我执行以下代码时：1document.getElementById(\"c\").style.transform = \"translate(100px, 0)\";我们绘制的时候，就可以只需要绘制 a 和 b 合成好的位图和 c，从而减少了绘制次数。这里需要注意的是，在实际场景中，我们的 b 可能有很多复杂的子元素，所以当合成命中时，性能提升收益非常之高。目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 will-change 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。绘制绘制是把“位图最终绘制到屏幕上，变成肉眼可见的图像”的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。一般最终显式的位图位于显存中，也有一些情况下，浏览器只需要把内存中的一张位图提交给操作系统或者显式驱动就可以了，这取决于浏览器运行的环境。不过无论如何，我们把任何位图合成到这个“最终位图”的操作称为绘制。这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 z-index 把它们依次绘制到屏幕上。然而如果在实际中这样做, 会带来极其糟糕的性能。有一个一度非常流行于前端群体的说法，讲做 CSS 性能优化，应该尽量避免”重排”和”重绘”，前者讲的是我们上一课的排版行为，后者模糊地指向了我们本课程三小节讲的三个步骤，而实际上，这个说法大体不能算错，却不够准确。因为，实际上，“绘制”发生的频率比我们想象中要高得多。我们考虑一个情况：鼠标划过浏览器显示区域。这个过程中，鼠标的每次移动，都造成了重新绘制，如果我们不重新绘制，就会产生大量的鼠标残影。这个时候，限制绘制的面积就很重要了。如果鼠标某次位置恰巧遮盖了某个较小的元素，我们完全可以重新绘制这个元素来完成我们的目标，当然，简单想想就知道，这种事情不可能总是发生的。计算机图形学中，我们使用的方案就是“脏矩形”算法，也就是把屏幕均匀地分成若干矩形区域。当鼠标移动、元素移动或者其它导致需要重绘的场景发生时，我们只重新绘制它所影响到的几个矩形区域就够了。比矩形区域更小的影响最多只会涉及 4 个矩形，大型元素则覆盖多个矩形。设置合适的矩形区域大小，可以很好地控制绘制时的消耗。设置过大的矩形会造成绘制面积增大，而设置过小的矩形则会造成计算复杂。我们重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交集部分绘制即可。总结在这一章中，我们讲解了浏览器中的位图操作部分，这包括了渲染、合成和绘制三个部分。渲染过程把元素变成位图，合成把一部分位图变成合成层，最终的绘制过程把合成层显示到屏幕上。当绘制完成时，就完成了浏览器的最终任务，把一个 URL 最后变成了一个可以看的网页图像。当然了，我们对每一个部分的讲解，都省略了大量的细节，比如我们今天讲到的绘制，就有意地无视了滚动区域。尽管如此，对浏览器工作原理的感性认识，仍然可以帮助我们理解很多前端技术的设计和应用技巧，浏览器的工作原理和性能部分非常强相关，我们在实践部分的性能优化部分，会再次跟你做一些探讨。实际上，如果你认真阅读浏览器系列的课程，是可以用 JavaScript 实现一个玩具浏览器的，我非常希望学习课程的同学中能有人这样做，一旦你做到了，收益会非常大。这就是我今天留给你的课外作业，你可以尝试一下。转自—《重学前端》","link":"/2019/03/23/浏览器：一个浏览器是如何工作的？（阶段五）/"},{"title":"JavaScript类型：关于类型，有哪些你不知道的细节？","text":"这次我们来讲讲 JavaScript 的内容，在这个部分，我首先想跟你聊一聊类型。 JavaScript 类型对每个前端程序员来说，几乎都是最为熟悉的概念了。但是你真的很了解它们吗？我们不妨来看看下面的几个问题。 为什么有的编程规范要求用 void 0 代替 undefined？ 字符串有最大长度吗？ 0.1 + 0.2 不是等于 0.3 么？为什么 JavaScript 里不是这样的？ ES6 新加入的 Symbol 是个什么东西？ 为什么给对象添加的方法能用在基本类型上？ 如果你答起来还有些犹豫的地方，这就说明你对这部分知识点，还是有些遗漏之处的。没关系，今天我来帮你一一补上。 我在前面提到过，我们的 JavaScript 模块会从运行时、文法和执行过程三个角度去剖析 JS 的知识体系，本篇我们就从运行时的角度去看 JavaScript 的类型系统。 运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都具有运行时类型。 类型 JavaScript 语言的每一个值都属于某一种数据类型。JavaScript 语言规定了 7 种语言类型。语言类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 7 种语言类型是： Undefined； Null； Boolean； String； Number； Symbol； Object。 除了 ES6 中新加入的 Symbol 类型，剩下 6 种类型都是我们日常开发中的老朋友了，但是，要想回答文章一开始的问题，我们需要重新认识一下这些老朋友，下面我们就来从简单到复杂，重新学习一下这些类型。 Undefined、Null 我们的第一个问题，为什么有的编程规范要求用 void 0 代替 undefined？现在我们就分别来看一下。 Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值，或者 void 运算来把任一一个表达式变成 undefined 值。 但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，我建议使用 void 0 来获取 undefined 值。 Undefined 跟 null 有一定的表意差别，null 表示的是：“定义了但是为空”。所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。 Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。 Boolean Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。这个类型很简单，我就不做过多介绍了。 String 我们来看看字符串是否有最大长度。 String 用于表示文本数据。String 有最大长度是 2^53 - 1，这在一般开发中都是够用的，但是有趣的是，这个所谓最大长度，并不完全是你理解中的字符数。 因为 String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。所以，字符串的最大长度，实际上是受字符串的编码长度影响的。 Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。 JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。 JavaScript 字符串把每个 UTF16 单元当作一个字符来处理，所以处理非 BMP（超出 U+0000 - U+FFFF 范围）的字符时，你应该格外小心。 JavaScript 这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到 BMP 之外的字符。 Number 下面，我们来说说 Number 类型。Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。 JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。 JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况： NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字； Infinity，无穷大； -Infinity，负无穷大。 另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。 根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。 同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，这也正是我们第三题的问题，为什么在 JavaScript 中，0.1+0.2 不能 =0.3：1console.log( 0.1 + 0.2 == 0.3);这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：1console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。SymbolSymbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。在后面的文章中，我会详细叙述 Symbol 跟对象系统。这里我们只介绍 Symbol 类型本身：它有哪些部分，它表示什么意思，以及如何创建 Symbol 类型。Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：1var mySymbol = Symbol(\"my symbol\");一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为：12345678910111213var o = new Objecto[Symbol.iterator] = function() { var v = 0 return { next: function() { return { value: v++, done: v &gt; 10 } } } };for(var v of o) console.log(v); // 0 1 2 3 ... 9代码中我们定义了 iterator 之后，用 for(var v of o) 就可以调用这个函数，然后我们可以根据函数的行为，产生一个 for…of 的行为。这里我们给对象 o 添加了 Symbol.iterator 属性，并且按照迭代器的要求定义了一个 0 到 10 的迭代器，之后我们就可以在 for of 中愉快地使用这个 o 对象啦。这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。ObjectObject 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。下面我们来看一看，为什么给对象添加的方法能用在基本类型上？在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。关于对象的机制，后面会有单独的一篇来讲述，这里我重点从类型的角度来介绍对象类型。提到对象，我们必须要提到一个概念：类。因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的。JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：Number；String；Boolean；Symbol。所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：1console.log(\"abc\".charAt(0)); //a甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。12345Symbol.prototype.hello = () =&gt; console.log(\"hello\");var a = Symbol(\"a\");console.log(typeof a); //symbol，a 并非对象a.hello(); //hello，有效所以我们文章开头的问题，答案就是 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。类型转换讲完了基本类型，我们来介绍一个现象：类型转换。因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误。其中最为臭名昭著的是 JS 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。这里我们当然也不打算讲解 == 的规则，它属于设计失误，并非语言中有价值的部分，很多实践中推荐禁止使用“ ==”，而要求程序员进行显式地类型转换后，用 === 比较。其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：在这个里面，较为复杂的部分是 Number 和 String 之间的转换，以及对象跟基本类型之间的转换。我们分别来看一看这几种转换的规则。StringToNumber字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：30；0b111；0o13；0xFF。此外，JavaScript 支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的 e 来表示：1e3；-1e-2。需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。NumberToString在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这个算法细节繁多，我们从感性的角度认识，它其实就是保证了产生的字符串不会过长。具体的算法，你可以去参考 JavaScript 的语言标准。由于这个部分内容，我觉得在日常开发中很少用到，所以这里我就不去详细地讲解了。装箱转换每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：12345var symbolObject = (function(){ return this; }).call(Symbol(\"a\"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。12345var symbolObject = Object(Symbol(\"a\"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：123var symbolObject = Object(Symbol(\"a\"));console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。拆箱转换在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。123456789var o = { valueOf : () =&gt; {console.log(\"valueOf\"); return {}}, toString : () =&gt; {console.log(\"toString\"); return {}}}o * 2// valueOf// toString// TypeError我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从 o2 换成 String(o)，那么你会看到调用顺序就变了。123456789 var o = { valueOf : () =&gt; {console.log(\"valueOf\"); return {}}, toString : () =&gt; {console.log(\"toString\"); return {}} }String(o) // toString // valueOf // TypeError在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为。1234567891011var o = { valueOf : () =&gt; {console.log(\"valueOf\"); return {}}, toString : () =&gt; {console.log(\"toString\"); return {}}}o[Symbol.toPrimitive] = () =&gt; {console.log(\"toPrimitive\"); return \"hello\"}console.log(o + \"\")// toPrimitive// hello结语在本篇文章中，我们介绍了 JavaScript 运行时的类型系统。这里回顾一下今天讲解的知识点。除了这七种语言类型，还有一些语言的实现者更关心的规范类型。List 和 Record： 用于描述函数传参过程。Set：主要用于解释字符集等。Completion Record：用于描述异常、跳出等语句执行过程。Reference：用于描述对象属性访问、delete 等。Property Descriptor：用于描述对象的属性。Lexical Environment 和 Environment Record：用于描述变量和作用域。Data Block：用于描述二进制数据。有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以我们要对它格外重视。最后我们留一个实践问题，如果我们不用原生的 Number 和 parseInt，用 JS 代码实现 String 到 Number 的转换，该怎么做呢？请你把自己的代码留言给我吧！补充阅读事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。从一般语言使用者的角度来看，毫无疑问，我们应该按照 typeof 的结果去理解语言的类型系统。但 JS 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。转自—《重学前端》","link":"/2019/03/25/JavaScript类型：关于类型，有哪些你不知道的细节？/"},{"title":"vue中axios的封装和API接口的管理","text":"一、axios的封装在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步axios文档。 安装1npm install axios; // 安装axios 引入一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。12345// 在http.js中引入axiosimport axios from 'axios'; // 引入axiosimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到// vant的toast提示框组件，大家可根据自己的ui组件更改。import { Toast } from 'vant'; 环境的切换我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。 123456789// 环境的切换if (process.env.NODE_ENV == 'development') { axios.defaults.baseURL = 'https://www.baidu.com';} else if (process.env.NODE_ENV == 'debug') { axios.defaults.baseURL = 'https://www.ceshi.com';} else if (process.env.NODE_ENV == 'production') { axios.defaults.baseURL = 'https://www.production.com';} 设置请求超时通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。 1axios.defaults.timeout = 10000; post请求头的设置post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'; 请求拦截我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。 12345678910111213141516// 先导入vuex,因为我们要使用到里面的状态对象// vuex的路径根据自己的路径去写import store from '@/store/index';// 请求拦截器axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); }) 这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。 然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊。 响应的拦截1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 响应拦截器axios.interceptors.response.use( response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; { if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast({ message: '登录过期，请重新登录', duration: 1000, forbidClick: true }); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: Toast({ message: '网络请求不存在', duration: 1500, forbidClick: true }); break; // 其他错误，直接抛出错误提示 default: Toast({ message: error.response.data.message, duration: 1500, forbidClick: true }); } return Promise.reject(error.response); } } }); 响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。 要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。 封装get方法和post方法我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post。 get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数 123456789101112131415/** * get方法，对应get请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function get(url, params){ return new Promise((resolve, reject) =&gt;{ axios.get(url, { params: params }).then(res =&gt; { resolve(res.data); }).catch(err =&gt;{ reject(err.data) }) });} post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from 'qs';的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。 12345678910111213141516/** * post方法，对应post请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function post(url, params) { return new Promise((resolve, reject) =&gt; { axios.post(url, QS.stringify(params)) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt;{ reject(err.data) }) });} 这里有个小细节说下，axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！ 二、api的统一管理整齐的api就像电路板一样，即使再复杂也能很清晰整个线路。上面说了，我们会新建一个api.js,然后在这个文件中存放我们所有的api接口。 首先我们在api.js中引入我们封装的get和post方法 1234/** * api接口统一管理 */import { get, post } from './http' 现在，例如我们有这样一个接口，是一个post请求： 1http://www.baiodu.com/api/v1/users/my_address/address_edit_before 我们可以在api.js中这样封装： 1export const apiAddress = p =&gt; post('api/v1/users/my_address/address_edit_before', p); 我们定义了一个apiAddress方法，这个方法有一个参数p，p是我们请求接口时携带的参数对象。而后调用了我们封装的post方法，post方法的第一个参数是我们的接口地址，第二个参数是apiAddress的p参数，即请求接口时携带的参数对象。最后通过export导出apiAddress。 然后在我们的页面中可以这样调用我们的api接口： 1234567891011121314151617181920import { apiAddress } from '@/request/api';// 导入我们的api接口export default { name: 'Address', created () { this.onLoad(); }, methods: { // 获取数据 onLoad() { // 调用api接口，并且提供了两个参数 apiAddress({ type: 0, sort: 1 }).then(res =&gt; { // 获取数据成功后的其他操作 ……………… }) } }} 其他的api接口，就在pai.js中继续往下面扩展就可以了。 友情提示，为每个接口写好注释哦！！！api接口管理的一个好处就是，我们把api统一集中起来，如果后期需要修改接口，我们就直接在api.js中找到对应的修改就好了，而不用去每一个页面查找我们的接口然后再修改会很麻烦。关键是，万一修改的量比较大，就规格gg了。还有就是如果直接在我们的业务代码修改接口，一不小心还容易动到我们的业务代码造成不必要的麻烦。 好了，最后把完成的axios封装代码奉上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/**axios封装 * 请求拦截、相应拦截、错误统一处理 */import axios from 'axios';import QS from 'qs';import { Toast } from 'vant';import store from '../store/index'// 环境的切换if (process.env.NODE_ENV == 'development') { axios.defaults.baseURL = '/api';} else if (process.env.NODE_ENV == 'debug') { axios.defaults.baseURL = '';} else if (process.env.NODE_ENV == 'production') { axios.defaults.baseURL = 'http://api.123dailu.com/';}// 请求超时时间axios.defaults.timeout = 10000;// post请求头axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';// 请求拦截器axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; { return Promise.error(error); })// 响应拦截器axios.interceptors.response.use( response =&gt; { if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是200的情况 error =&gt; { if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast({ message: '登录过期，请重新登录', duration: 1000, forbidClick: true }); // 清除token localStorage.removeItem('token'); store.commit('loginSuccess', null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: Toast({ message: '网络请求不存在', duration: 1500, forbidClick: true }); break; // 其他错误，直接抛出错误提示 default: Toast({ message: error.response.data.message, duration: 1500, forbidClick: true }); } return Promise.reject(error.response); } });/** * get方法，对应get请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function get(url, params){ return new Promise((resolve, reject) =&gt;{ axios.get(url, { params: params }) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt; { reject(err.data) }) });}/** * post方法，对应post请求 * @param {String} url [请求的url地址] * @param {Object} params [请求时携带的参数] */export function post(url, params) { return new Promise((resolve, reject) =&gt; { axios.post(url, QS.stringify(params)) .then(res =&gt; { resolve(res.data); }) .catch(err =&gt; { reject(err.data) }) });} 优化axios的封装根据需求的不同而不同。我也对此进行了思考和针对不同需求的改善。主要有以下改变： 优化axios封装，去掉之前的get和post 断网情况处理 更加模块化的api管理 接口域名有多个的情况 api挂载到vue.prototype上省去引入的步骤 http.js中axios封装的优化，先直接贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * axios封装 * 请求拦截、响应拦截、错误统一处理 */import axios from 'axios';import router from '../router';import store from '../store/index';import { Toast } from 'vant';/** * 提示函数 * 禁止点击蒙层、显示一秒后关闭 */const tip = msg =&gt; { Toast({ message: msg, duration: 1000, forbidClick: true });}/** * 跳转登录页 * 携带当前页面路由，以期在登录页面完成登录后返回当前页面 */const toLogin = () =&gt; { router.replace({ path: '/login', query: { redirect: router.currentRoute.fullPath } });}/** * 请求失败后的错误统一处理 * @param {Number} status 请求失败的状态码 */const errorHandle = (status, other) =&gt; { // 状态码判断 switch (status) { // 401: 未登录状态，跳转登录页 case 401: toLogin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: tip('登录过期，请重新登录'); localStorage.removeItem('token'); store.commit('loginSuccess', null); setTimeout(() =&gt; { toLogin(); }, 1000); break; // 404请求不存在 case 404: tip('请求的资源不存在'); break; default: console.log(other); }}// 创建axios实例var instance = axios.create({ timeout: 1000 * 12});// 设置post请求头instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';/** * 请求拦截器 * 每次请求前，如果存在token则在请求头中携带token */ instance.interceptors.request.use( config =&gt; { // 登录流程控制中，根据本地是否存在token判断用户的登录情况 // 但是即使token存在，也有可能token是过期的，所以在每次的请求头中携带token // 后台根据携带的token判断用户的登录情况，并返回给我们对应的状态码 // 而后我们可以在响应拦截器中，根据状态码进行一些统一的操作。 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; }, error =&gt; Promise.error(error))// 响应拦截器instance.interceptors.response.use( // 请求成功 res =&gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 error =&gt; { const { response } = error; if (response) { // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); } else { // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 if (!window.navigator.onLine) { store.commit('changeNetwork', false); } else { return Promise.reject(error); } } });export default instance; 这个axios和之前的大同小异，做了如下几点改变： 去掉了之前get和post方法的封装，通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。 去掉了通过环境变量控制baseUrl的值。考虑到接口会有多个不同域名的情况，所以准备通过js变量来控制接口域名。这点具体在api里会介绍。 增加了请求超时，即断网状态的处理。说下思路，当断网时，通过更新vuex中network的状态来控制断网提示组件的显示隐藏。断网提示一般会有重新加载数据的操作，这步会在后面对应的地方介绍。 公用函数进行抽出，简化代码，尽量保证单一职责原则。 下面说下api这块，考虑到一下需求： 更加模块化 更方便多人开发，有效减少解决命名冲突 处理接口域名有多个情况 这里这里呢新建了一个api文件夹，里面有一个index.js和一个base.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，base.js管理接口域名，其他js则用来管理各个模块的接口。 先放index.js代码： 123456789101112/** * api接口的统一出口 */// 文章模块接口import article from '@/api/article';// 其他模块的接口……// 导出接口export default { article, // ……} index.js是一个api接口的出口，这样就可以把api接口根据功能划分为多个模块，利于多人协作开发，比如一个人只负责一个模块的开发等，还能方便每个模块中接口的命名哦。 base.js: 123456789/** * 接口域名的管理 */const base = { sq: 'https://xxxx111111.com/api/v1', bd: 'http://xxxxx22222.com/api'}export default base; 通过base.js来管理我们的接口域名，不管有多少个都可以通过这里进行接口的定义。即使修改起来，也是很方便的。 最后就是接口模块的说明，例如上面的article.js: 123456789101112131415161718192021222324252627/** * article模块接口列表 */import base from './base'; // 导入接口域名列表import axios from '@/utils/http'; // 导入http中创建的axios实例import qs from 'qs'; // 根据需求是否导入qs模块const article = { // 新闻列表 articleList () { return axios.get(`${base.sq}/topics`); }, // 新闻详情,演示 articleDetail (id, params) { return axios.get(`${base.sq}/topic/${id}`, { params: params }); }, // post提交 login (params) { return axios.post(`${base.sq}/accesstoken`, qs.stringify(params)); } // 其他接口…………}export default article; 通过直接引入我们封装好的axios实例，然后定义接口、调用axios实例并返回，可以更灵活的使用axios，比如你可以对post请求时提交的数据进行一个qs序列化的处理等。 请求的配置更灵活，你可以针对某个需求进行一个不同的配置。关于配置的优先级，axios文档说的很清楚，这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。 restful风格的接口，也可以通过这种方式灵活的设置api接口地址。 最后，为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中： 1234567import Vue from 'vue'import App from './App'import router from './router' // 导入路由文件import store from './store' // 导入vuex文件import api from './api' // 导入api接口Vue.prototype.$api = api; // 将api挂载到vue的原型上 然后我们可以在页面中这样调用接口，eg： 123456789methods: { onLoad(id) { this.$api.article.articleDetail(id, { api: 123 }).then(res=&gt; { // 执行某些操作 }) } } 再提一下断网的处理，这里只做一个简单的示例： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div v-if=\"!network\"&gt; &lt;h3&gt;我没网了&lt;/h3&gt; &lt;div @click=\"onRefresh\"&gt;刷新&lt;/div&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { mapState } from 'vuex'; export default { name: 'App', computed: { ...mapState(['network']) }, methods: { // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的 onRefresh () { this.$router.replace('/refresh') } } }&lt;/script&gt; 这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其beforeRouteEnter钩子中再返回当前页面。 123456// refresh.vuebeforeRouteEnter (to, from, next) { next(vm =&gt; { vm.$router.replace(from.fullPath) }) } 这是一种全局通用的断网提示，当然了，也可以根据自己的项目需求操作。具体操作就仁者见仁智者见智了。 如果更多的需求，或者说是不一样的需求，可以根据自己的需求进行一个改进。","link":"/2019/10/01/vue中axios的封装和API接口的管理/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Next","slug":"Next","link":"/tags/Next/"},{"name":"seo优化","slug":"seo优化","link":"/tags/seo优化/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"VUE","slug":"VUE","link":"/tags/VUE/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"验证码","slug":"验证码","link":"/tags/验证码/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[{"name":"BLOG","slug":"BLOG","link":"/categories/BLOG/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"NODE JS","slug":"NODE-JS","link":"/categories/NODE-JS/"},{"name":"WEB","slug":"WEB","link":"/categories/WEB/"}]}